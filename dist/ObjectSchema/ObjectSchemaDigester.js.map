{"version":3,"sources":["ObjectSchema/ObjectSchemaDigester.ts"],"names":[],"mappings":"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","file":"ObjectSchemaDigester.js","sourcesContent":["import { IllegalArgumentError } from \"../Errors/IllegalArgumentError\";\nimport { InvalidJSONLDSyntaxError } from \"../Errors/InvalidJSONLDSyntaxError\";\n\nimport { URI } from \"../RDF/URI\";\n\nimport * as Utils from \"../Utils\";\n\nimport { XSD } from \"../Vocabularies/XSD\";\n\nimport { ContainerType } from \"./ContainerType\";\nimport { DigestedObjectSchema } from \"./DigestedObjectSchema\";\nimport { DigestedObjectSchemaProperty } from \"./DigestedObjectSchemaProperty\";\nimport { ObjectSchema } from \"./ObjectSchema\";\nimport { ObjectSchemaProperty } from \"./ObjectSchemaProperty\";\nimport { ObjectSchemaUtils } from \"./ObjectSchemaUtils\";\nimport { PointerType } from \"./PointerType\";\n\n\nexport class ObjectSchemaDigester {\n\n\tstatic digestSchema( schema:ObjectSchema ):DigestedObjectSchema;\n\tstatic digestSchema( schemas:ObjectSchema[] ):DigestedObjectSchema;\n\tstatic digestSchema( schemas:ObjectSchema | ObjectSchema[] ):DigestedObjectSchema {\n\t\tif( ! Array.isArray( schemas ) ) return ObjectSchemaDigester._digestSchema( schemas );\n\n\t\tconst digestedSchemas:DigestedObjectSchema[] = schemas\n\t\t\t.map( schema => ObjectSchemaDigester._digestSchema( schema ) );\n\n\t\treturn ObjectSchemaDigester._combineSchemas( digestedSchemas );\n\t}\n\n\tstatic digestProperty( name:string, definition:ObjectSchemaProperty, digestedSchema?:DigestedObjectSchema ):DigestedObjectSchemaProperty {\n\t\tconst digestedDefinition:DigestedObjectSchemaProperty = new DigestedObjectSchemaProperty();\n\n\t\tif( \"@id\" in definition ) {\n\t\t\tconst uri:any = definition[ \"@id\" ];\n\n\t\t\tif( URI.isPrefixed( name ) ) throw new IllegalArgumentError( \"A prefixed property cannot have assigned another URI.\" );\n\t\t\tif( ! Utils.isString( uri ) ) throw new IllegalArgumentError( \"@id needs to point to a string\" );\n\n\t\t\tdigestedDefinition.uri = uri;\n\t\t} else {\n\t\t\tdigestedDefinition.uri = name;\n\t\t}\n\n\t\tif( \"@type\" in definition ) {\n\t\t\tlet type:any = definition[ \"@type\" ];\n\t\t\tif( ! Utils.isString( type ) ) throw new IllegalArgumentError( \"@type needs to point to a string\" );\n\n\t\t\tif( type === \"@id\" || type === \"@vocab\" ) {\n\t\t\t\tdigestedDefinition.literal = false;\n\t\t\t\tdigestedDefinition.pointerType = type === \"@id\" ? PointerType.ID : PointerType.VOCAB;\n\n\t\t\t} else {\n\t\t\t\tif( URI.isRelative( type ) && type in XSD ) type = XSD[ type ];\n\n\t\t\t\tdigestedDefinition.literal = true;\n\t\t\t\tdigestedDefinition.literalType = type;\n\t\t\t}\n\t\t}\n\n\t\tif( \"@language\" in definition ) {\n\t\t\tconst language:string = definition[ \"@language\" ];\n\t\t\tif( language !== null && ! Utils.isString( language ) ) throw new IllegalArgumentError( \"@language needs to point to a string or null.\" );\n\n\t\t\tdigestedDefinition.literal = true;\n\t\t\tdigestedDefinition.language = language;\n\t\t}\n\n\t\tif( \"@container\" in definition ) {\n\t\t\tswitch( definition[ \"@container\" ] ) {\n\t\t\t\tcase \"@set\":\n\t\t\t\t\tdigestedDefinition.containerType = ContainerType.SET;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"@list\":\n\t\t\t\t\tdigestedDefinition.containerType = ContainerType.LIST;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"@language\":\n\t\t\t\t\tif( Utils.isString( digestedDefinition.language ) ) throw new IllegalArgumentError( \"@container cannot be set to @language when the property definition already contains an @language tag.\" );\n\t\t\t\t\tdigestedDefinition.containerType = ContainerType.LANGUAGE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalArgumentError( \"@container needs to be equal to '@list', '@set', or '@language'\" );\n\t\t\t}\n\t\t}\n\n\t\treturn digestedSchema ?\n\t\t\tObjectSchemaUtils._resolveProperty( digestedSchema, digestedDefinition, true ) :\n\t\t\tdigestedDefinition;\n\t}\n\n\tstatic combineDigestedObjectSchemas( digestedSchemas:DigestedObjectSchema[] ):DigestedObjectSchema {\n\t\tif( digestedSchemas.length === 0 ) throw new IllegalArgumentError( \"At least one DigestedObjectSchema needs to be specified.\" );\n\n\t\tdigestedSchemas.unshift( new DigestedObjectSchema() );\n\t\treturn ObjectSchemaDigester._combineSchemas( digestedSchemas );\n\t}\n\n\tstatic _digestSchema( schema:ObjectSchema ):DigestedObjectSchema {\n\t\tconst digestedSchema:DigestedObjectSchema = new DigestedObjectSchema();\n\n\t\tfor( const propertyName of [ \"@base\", \"@vocab\" ] as [ \"@base\", \"@vocab\" ] ) {\n\t\t\tif( ! (propertyName in schema) ) continue;\n\t\t\tconst value:string = schema[ propertyName ];\n\n\t\t\tif( value !== null && ! Utils.isString( value ) ) throw new IllegalArgumentError( `The value of '${ propertyName }' must be a string or null.` );\n\t\t\tif( (propertyName === \"@vocab\" && value === \"\") || ! URI.isAbsolute( value ) && ! URI.isBNodeID( value ) ) throw new IllegalArgumentError( `The value of '${ propertyName }' must be an absolute URI${ propertyName === \"@base\" ? \" or an empty string\" : \"\" }.` );\n\n\t\t\tdigestedSchema[ propertyName.substr( 1 ) ] = value;\n\t\t}\n\t\tdigestedSchema.base = digestedSchema.base || \"\";\n\n\t\tif( \"@language\" in schema ) {\n\t\t\tconst value:string = schema[ \"@language\" ];\n\t\t\tif( value !== null && ! Utils.isString( value ) ) throw new InvalidJSONLDSyntaxError( `The value of '@language' must be a string or null.` );\n\t\t\tdigestedSchema.language = value;\n\t\t}\n\n\t\tfor( const propertyName in schema ) {\n\t\t\tif( ! schema.hasOwnProperty( propertyName ) ) continue;\n\n\t\t\tif( propertyName === \"@reverse\" ) continue;\n\t\t\tif( propertyName === \"@index\" ) continue;\n\t\t\tif( propertyName === \"@base\" ) continue;\n\t\t\tif( propertyName === \"@vocab\" ) continue;\n\t\t\tif( propertyName === \"@language\" ) continue;\n\n\t\t\tlet propertyValue:(string | ObjectSchemaProperty) = schema[ propertyName ];\n\n\t\t\tif( Utils.isString( propertyValue ) ) {\n\t\t\t\tif( URI.isPrefixed( propertyName ) ) throw new IllegalArgumentError( \"A prefixed property cannot be equal to another URI.\" );\n\t\t\t\tdigestedSchema.prefixes.set( propertyName, propertyValue );\n\n\t\t\t} else if( ! ! propertyValue && Utils.isObject( propertyValue ) ) {\n\t\t\t\tconst definition:DigestedObjectSchemaProperty = ObjectSchemaDigester.digestProperty( propertyName, propertyValue );\n\t\t\t\tdigestedSchema.properties.set( propertyName, definition );\n\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentError( \"ObjectSchema Properties can only have string values or object values.\" );\n\t\t\t}\n\t\t}\n\n\t\treturn digestedSchema;\n\t}\n\n\tstatic _combineSchemas( digestedSchemas:DigestedObjectSchema[] ):DigestedObjectSchema {\n\t\tconst [ targetSchema, ...restSchemas ] = digestedSchemas;\n\n\t\trestSchemas.forEach( schema => {\n\t\t\tif( schema.vocab !== void 0 ) targetSchema.vocab = schema.vocab;\n\t\t\tif( schema.base !== \"\" ) targetSchema.base = schema.base;\n\t\t\tif( schema.language !== null ) targetSchema.language = schema.language;\n\n\t\t\tUtils.MapUtils.extend( targetSchema.prefixes, schema.prefixes );\n\t\t\tUtils.MapUtils.extend( targetSchema.properties, schema.properties );\n\t\t} );\n\n\t\treturn targetSchema;\n\t}\n\n}\n"]}