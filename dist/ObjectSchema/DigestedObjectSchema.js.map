{"version":3,"sources":["ObjectSchema/DigestedObjectSchema.ts"],"names":[],"mappings":";;AAAA,kCAAiC;AAKjC;IAOC;QACC,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;QACf,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,CAAC;QACpB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAAkB,CAAC;QAC1C,IAAI,CAAC,UAAU,GAAG,IAAI,GAAG,EAAwC,CAAC;IACnE,CAAC;IAED,yCAAU,GAAV,UAAY,GAAU,EAAE,UAAiD;QAAjD,2BAAA,EAAA,eAAiD;QACxE,IAAI,GAAG,KAAK,IAAI,IAAI,SAAG,CAAC,UAAU,CAAE,GAAG,CAAE,IAAI,SAAG,CAAC,SAAS,CAAE,GAAG,CAAE;YAAG,OAAO,GAAG,CAAC;QAEzE,IAAA,mBAAsF,EAApF,cAAM,EAAE,UAAc,EAAd,mCAAc,CAA+D;QAE7F,IAAM,gBAAgB,GAAU,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,MAAM,CAAE,CAAC,CAAC;YAC5D,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAE,MAAM,CAAE,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAE,MAAM,CAAE,CAAC,CAAC;YAC5D,IAAI,CAAC,UAAU,CAAC,GAAG,CAAE,MAAM,CAAE,CAAC,GAAG;YACjC,CAAC,CAAC,IAAI,CAAC;QAET,IAAI,gBAAgB,KAAK,IAAI,IAAI,gBAAgB,KAAK,MAAM,EAAG;YAC9D,OAAO,IAAI,CAAC,UAAU,CAAE,gBAAgB,GAAG,SAAS,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,CAAE,CAAC;SACxE;QAED,IAAI,SAAS;YAAG,OAAO,GAAG,CAAC;QAE3B,IAAI,UAAU,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK;YAAG,OAAO,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC;QAC7D,IAAI,UAAU,CAAC,IAAI;YAAG,OAAO,SAAG,CAAC,OAAO,CAAE,IAAI,CAAC,IAAI,EAAE,GAAG,CAAE,CAAC;QAE3D,OAAO,GAAG,CAAC;IACZ,CAAC;IAEF,2BAAC;AAAD,CArCA,AAqCC,IAAA;AArCY,oDAAoB","file":"DigestedObjectSchema.js","sourcesContent":["import { URI } from \"../RDF/URI\";\n\nimport { DigestedObjectSchemaProperty } from \"./DigestedObjectSchemaProperty\";\n\n\nexport class DigestedObjectSchema {\n\tbase:string;\n\tlanguage:string;\n\tvocab:string;\n\tprefixes:Map<string, string>;\n\tproperties:Map<string, DigestedObjectSchemaProperty>;\n\n\tconstructor() {\n\t\tthis.base = \"\";\n\t\tthis.vocab = void 0;\n\t\tthis.language = null;\n\t\tthis.prefixes = new Map<string, string>();\n\t\tthis.properties = new Map<string, DigestedObjectSchemaProperty>();\n\t}\n\n\tresolveURI( uri:string, relativeTo:{ vocab?:boolean, base?:boolean } = {} ):string {\n\t\tif( uri === null || URI.isAbsolute( uri ) || URI.isBNodeID( uri ) ) return uri;\n\n\t\tconst [ prefix, localName = \"\" ]:[ string, string ] = uri.split( \":\" ) as [ string, string ];\n\n\t\tconst definedReference:string = this.prefixes.has( prefix ) ?\n\t\t\tthis.prefixes.get( prefix ) : this.properties.has( prefix ) ?\n\t\t\t\tthis.properties.get( prefix ).uri\n\t\t\t\t: null;\n\n\t\tif( definedReference !== null && definedReference !== prefix ) {\n\t\t\treturn this.resolveURI( definedReference + localName, { vocab: true } );\n\t\t}\n\n\t\tif( localName ) return uri;\n\n\t\tif( relativeTo.vocab && this.vocab ) return this.vocab + uri;\n\t\tif( relativeTo.base ) return URI.resolve( this.base, uri );\n\n\t\treturn uri;\n\t}\n\n}\n"]}