{"version":3,"sources":["Pointer/Pointer.ts"],"names":[],"mappings":";;;;;;;;;AACA,oCAA8C;AAG9C,8CAAkC;AAoClC;IACC,OAAO,IAAI,CAAC,SAAS,CAAC;AACvB,CAAC;AAFD,8CAEC;AAED;IACC,OAAO,OAAO,CAAC,MAAM,CAAE,IAAI,0BAAiB,CAAE,iDAAiD,CAAE,CAAE,CAAC;AACrG,CAAC;AAFD,4DAEC;AAEY,QAAA,OAAO,GAAkB;IACrC,WAAW,EAAX,UAAa,MAAa;QACzB,OAAO,CACN,KAAK,CAAC,kBAAkB,CAAE,MAAM,EAAE,KAAK,CAAE;YACzC,KAAK,CAAC,kBAAkB,CAAE,MAAM,EAAE,WAAW,CAAE;YAE/C,KAAK,CAAC,kBAAkB,CAAE,MAAM,EAAE,IAAI,CAAE;YAExC,KAAK,CAAC,WAAW,CAAE,MAAM,EAAE,YAAY,CAAE;YACzC,KAAK,CAAC,WAAW,CAAE,MAAM,EAAE,SAAS,CAAE,CACtC,CAAC;IACH,CAAC;IAED,EAAE,EAAF,UAAI,KAAS;QACZ,OAAO,CACN,KAAK,CAAC,QAAQ,CAAE,KAAK,CAAE;YACvB,eAAO,CAAC,WAAW,CAAE,KAAK,CAAE,CAC5B,CAAC;IACH,CAAC;IAGD,MAAM,EAAN,UAA+B,IAAM;QACpC,IAAM,KAAK,GAAK,MAAM,CAAC,MAAM,CAAE,EAAE,EAAE,IAAI,CAAE,CAAC;QAC1C,OAAO,eAAO,CAAC,UAAU,CAAK,KAAK,CAAE,CAAC;IACvC,CAAC;IAED,UAAU,EAAV,UAAmC,MAAQ;QAC1C,OAAO,eAAO,CAAC,QAAQ,CAAK,MAAM,CAAE,CAAC;IACtC,CAAC;IAED,QAAQ,EAAR,UAA4B,MAAQ;QACnC,IAAI,eAAO,CAAC,WAAW,CAAE,MAAM,CAAE;YAAG,OAAO,MAAM,CAAC;QAElD,IAAM,OAAO,GAAe,MAAqB,CAAC;QAClD,MAAM,CAAC,gBAAgB,CAAE,OAAO,EAAE;YACjC,KAAK,EAAE;gBACN,QAAQ,EAAE,IAAI;gBACd,YAAY,EAAE,IAAI;gBAClB,KAAK,EAAE,OAAO,CAAC,EAAE,IAAI,EAAE;aACvB;YACD,WAAW,EAAE;gBACZ,QAAQ,EAAE,IAAI;gBACd,YAAY,EAAE,IAAI;gBAClB,KAAK,EAAE,OAAO,CAAC,SAAS,IAAI,KAAK;aACjC;YACD,IAAI,EAAE;gBACL,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;gBAClB,GAAG,EAAH;oBACC,OAAO,IAAI,CAAC,GAAG,CAAC;gBACjB,CAAC;gBACD,GAAG,EAAH,UAAmB,KAAY;oBAC9B,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC;gBAClB,CAAC;aACD;YACD,YAAY,EAAE;gBACb,YAAY,EAAE,IAAI;gBAClB,KAAK,EAAE,iBAAiB;aACxB;YACD,SAAS,EAAE;gBACV,QAAQ,EAAE,KAAK;gBACf,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;gBAClB,KAAK,EAAE,wBAAwB;aAC/B;SACD,CAAE,CAAC;QAEJ,OAAO,OAAO,CAAC;IAChB,CAAC;IAGD,QAAQ,EAAR,UAAU,QAAgB,EAAE,QAAgB;QAC3C,OAAO,QAAQ,CAAC,EAAE,KAAK,QAAQ,CAAC,EAAE,CAAC;IACpC,CAAC;IAED,MAAM,EAAN,UAAQ,QAAkB;QACzB,OAAO,QAAQ;aACb,GAAG,CAAE,UAAA,OAAO,IAAI,OAAA,OAAO,CAAC,EAAE,EAAV,CAAU,CAAE,CAC5B;IACH,CAAC;CACD,CAAC","file":"Pointer.js","sourcesContent":["import { Document } from \"../Document\";\nimport { IllegalStateError } from \"../Errors\";\nimport { GETOptions } from \"../HTTP\";\nimport { QueryDocumentBuilder } from \"../SPARQL/QueryDocument\";\nimport * as Utils from \"../Utils\";\nimport { BasePointer } from \"./BasePointer\";\n\n\nexport interface Pointer {\n\t_id:string;\n\t_resolved:boolean;\n\n\tid:string;\n\n\tisResolved():boolean;\n\n\tresolve<T extends object>( requestOptions?:GETOptions, queryBuilderFn?:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<T & this & Document>;\n\tresolve<T extends object>( queryBuilderFn?:( queryBuilder:QueryDocumentBuilder ) => QueryDocumentBuilder ):Promise<T & this & Document>;\n}\n\n\nexport interface PointerFactory {\n\tisDecorated( object:object ):object is Pointer;\n\n\tis( value:any ):value is Pointer;\n\n\n\tcreate<T extends BasePointer>( data?:T ):T & Pointer;\n\n\tcreateFrom<T extends BasePointer>( object:T ):T & Pointer;\n\n\tdecorate<T extends object>( object:T ):T & Pointer;\n\n\n\tareEqual( pointer1:Pointer, pointer2:Pointer ):boolean;\n\n\tgetIDs( pointers:Pointer[] ):string[];\n}\n\n\nexport function isPointerResolved( this:Pointer ):boolean {\n\treturn this._resolved;\n}\n\nexport function resolveStandalonePointer( this:Pointer ):Promise<never> {\n\treturn Promise.reject( new IllegalStateError( \"The pointer has not been assigned to a context.\" ) );\n}\n\nexport const Pointer:PointerFactory = {\n\tisDecorated( object:object ):object is Pointer {\n\t\treturn (\n\t\t\tUtils.hasPropertyDefined( object, \"_id\" ) &&\n\t\t\tUtils.hasPropertyDefined( object, \"_resolved\" ) &&\n\n\t\t\tUtils.hasPropertyDefined( object, \"id\" ) &&\n\n\t\t\tUtils.hasFunction( object, \"isResolved\" ) &&\n\t\t\tUtils.hasFunction( object, \"resolve\" )\n\t\t);\n\t},\n\n\tis( value:any ):value is Pointer {\n\t\treturn (\n\t\t\tUtils.isObject( value ) &&\n\t\t\tPointer.isDecorated( value )\n\t\t);\n\t},\n\n\n\tcreate<T extends BasePointer>( data:T ):T & Pointer {\n\t\tconst clone:T = Object.assign( {}, data );\n\t\treturn Pointer.createFrom<T>( clone );\n\t},\n\n\tcreateFrom<T extends BasePointer>( object:T ):T & Pointer {\n\t\treturn Pointer.decorate<T>( object );\n\t},\n\n\tdecorate<T extends object>( object:T ):T & Pointer {\n\t\tif( Pointer.isDecorated( object ) ) return object;\n\n\t\tconst pointer:T & Pointer = object as T & Pointer;\n\t\tObject.defineProperties( pointer, {\n\t\t\t\"_id\": {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: pointer.id || \"\",\n\t\t\t},\n\t\t\t\"_resolved\": {\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: pointer._resolved || false,\n\t\t\t},\n\t\t\t\"id\": {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tget( this:Pointer ):string {\n\t\t\t\t\treturn this._id;\n\t\t\t\t},\n\t\t\t\tset( this:Pointer, value:string ):void {\n\t\t\t\t\tthis._id = value;\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"isResolved\": {\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: isPointerResolved,\n\t\t\t},\n\t\t\t\"resolve\": {\n\t\t\t\twritable: false,\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: resolveStandalonePointer,\n\t\t\t},\n\t\t} );\n\n\t\treturn pointer;\n\t},\n\n\n\tareEqual( pointer1:Pointer, pointer2:Pointer ):boolean {\n\t\treturn pointer1.id === pointer2.id;\n\t},\n\n\tgetIDs( pointers:Pointer[] ):string[] {\n\t\treturn pointers\n\t\t\t.map( pointer => pointer.id )\n\t\t\t;\n\t},\n};\n\n"]}