{"version":3,"sources":["RDF/Literal.ts"],"names":[],"mappings":"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","file":"RDF/Literal.js","sourcesContent":["import * as Utils from \"./../Utils\";\nimport * as XSD from \"./../NS/XSD\" ;\nimport * as Errors from \"../Errors\";\n\nimport Serializer from \"./Literal/Serializer\";\nimport * as Serializers from \"./Literal/Serializers\";\n\nexport interface Class {\n\t\"@type\"?:string;\n\t\"@value\":string;\n}\n\nexport class Factory {\n\tstatic from( value:any ):Class {\n\t\tif ( Utils.isNull( value ) )\n\t\t\tthrow new Errors.IllegalArgumentError( \"Null cannot be converted into a Literal\" );\n\t\tif ( ! Utils.isDefined( value ) )\n\t\t\tthrow new Errors.IllegalArgumentError( \"The value is undefined\" );\n\n\t\tlet type:any;\n\n\t\tswitch ( true ) {\n\t\t\tcase Utils.isDate( value ):\n\t\t\t\ttype = XSD.DataType.dateTime;\n\t\t\t\tvalue = value.toISOString();\n\t\t\t\tbreak;\n\t\t\tcase Utils.isNumber( value ):\n\t\t\t\tif ( Utils.isInteger( value ) ) {\n\t\t\t\t\ttype = XSD.DataType.integer;\n\t\t\t\t} else {\n\t\t\t\t\ttype = XSD.DataType.double;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Utils.isString( value ):\n\t\t\t\ttype = XSD.DataType.string;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isBoolean( value ):\n\t\t\t\ttype = XSD.DataType.boolean;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Treat it as an unknown object\n\t\t\t\ttype = XSD.DataType.object;\n\t\t\t\tvalue = JSON.stringify( value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet literal:Class = { \"@value\": value.toString() };\n\t\tif ( type ) literal[ \"@type\" ] = type;\n\n\t\treturn literal;\n\t}\n\n\tstatic parse( literalValue:string, literalDataType?:string ):any;\n\tstatic parse( literal:Class ):any;\n\tstatic parse( literalValueOrLiteral:any, literalDataType:string = null ):any {\n\t\tlet literalValue:string;\n\t\tif( Utils.isString( literalValueOrLiteral ) ) {\n\t\t\tliteralValue = literalValueOrLiteral;\n\t\t} else {\n\t\t\tlet literal:Class = literalValueOrLiteral;\n\t\t\tif ( ! literal ) return null;\n\t\t\tif ( ! Utils.hasProperty( literal, \"@value\" ) ) return null;\n\n\t\t\tliteralDataType = \"@type\" in literal ? literal[ \"@type\" ] : null;\n\t\t\tliteralValue = literal[ \"@value\" ];\n\t\t}\n\n\t\tif ( literalDataType === null ) return literalValue;\n\t\t// The DataType isn't supported\n\t\tif ( ! Utils.hasProperty( XSD.DataType, literalDataType ) ) return literalValue;\n\n\t\tlet value:any;\n\t\tlet parts:string[];\n\t\tswitch ( literalDataType ) {\n\t\t\t// Dates\n\t\t\tcase XSD.DataType.date:\n\t\t\tcase XSD.DataType.dateTime:\n\t\t\t\tvalue = new Date( literalValue );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.time:\n\t\t\t\tparts = literalValue.match(/(\\d+):(\\d+):(\\d+)\\.(\\d+)Z/);\n\t\t\t\tvalue = new Date();\n\t\t\t\tvalue.setUTCHours( parseFloat( parts[1] ), parseFloat( parts[2] ), parseFloat( parts[3]), parseFloat( parts[4] ) );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.duration:\n\t\t\t\t// TODO: Support duration values (create a class or something...)\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.gDay:\n\t\t\tcase XSD.DataType.gMonth:\n\t\t\tcase XSD.DataType.gMonthDay:\n\t\t\tcase XSD.DataType.gYear:\n\t\t\tcase XSD.DataType.gYearMonth:\n\t\t\t\t// TODO: Decide. Should we return it as a Date?\n\t\t\t\tbreak;\n\n\t\t\t// Numbers\n\t\t\tcase XSD.DataType.byte :\n\t\t\tcase XSD.DataType.decimal :\n\t\t\tcase XSD.DataType.int :\n\t\t\tcase XSD.DataType.integer :\n\t\t\tcase XSD.DataType.long :\n\t\t\tcase XSD.DataType.negativeInteger :\n\t\t\tcase XSD.DataType.nonNegativeInteger :\n\t\t\tcase XSD.DataType.nonPositiveInteger :\n\t\t\tcase XSD.DataType.positiveInteger :\n\t\t\tcase XSD.DataType.short :\n\t\t\tcase XSD.DataType.unsignedLong :\n\t\t\tcase XSD.DataType.unsignedInt :\n\t\t\tcase XSD.DataType.unsignedShort :\n\t\t\tcase XSD.DataType.unsignedByte :\n\t\t\tcase XSD.DataType.double :\n\t\t\tcase XSD.DataType.float :\n\t\t\t\tvalue = parseFloat( literalValue );\n\t\t\t\tbreak;\n\n\t\t\t// Misc\n\t\t\tcase XSD.DataType.boolean :\n\t\t\t\tvalue = Utils.parseBoolean( literalValue );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.string:\n\t\t\t\tvalue = literalValue;\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.object:\n\t\t\t\tvalue = JSON.parse( literalValue );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tstatic is( value:any ):boolean {\n\t\treturn Utils.hasProperty( value, \"@value\" )\n\t\t\t&& Utils.isString( value[ \"@value\" ] );\n\t}\n\n\tstatic hasType( value:Class, type:string ):boolean {\n\t\tif( ! value[ \"@type\" ] && type === <any> XSD.DataType.string ) return true;\n\t\treturn value[ \"@type\" ] === type;\n\t}\n}\n\nexport class Util {\n\tstatic areEqual( literal1:Class, literal2:Class ):boolean {\n\t\t// TODO: Implement\n\t\treturn false;\n\t}\n}\n\nexport default Class;\n\nexport {\n\tSerializer,\n\tSerializers\n};\n"],"sourceRoot":"/source/"}