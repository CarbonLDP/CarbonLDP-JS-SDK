{"version":3,"sources":["RDF/Literal.ts"],"names":["Factory","Factory.constructor","Factory.from","Factory.parse","Factory.is","Factory.hasType","Util","Util.constructor","Util.areEqual"],"mappings":"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","file":"RDF/Literal.js","sourcesContent":["import * as Utils from \"./../Utils\";\nimport * as XSD from \"./../NS/XSD\" ;\nimport * as Errors from \"../Errors\";\n\nimport Serializer from \"./Literal/Serializer\";\nimport * as Serializers from \"./Literal/Serializers\";\n\nexport interface Class {\n\t\"@type\"?:string;\n\t\"@value\":string;\n}\n\nexport class Factory {\n\tstatic from( value:any ):Class {\n\t\tif ( Utils.isNull( value ) )\n\t\t\tthrow new Errors.IllegalArgumentError( \"Null cannot be converted into a Literal\" );\n\t\tif ( ! Utils.isDefined( value ) )\n\t\t\tthrow new Errors.IllegalArgumentError( \"The value is undefined\" );\n\n\t\tlet type:any;\n\n\t\tswitch ( true ) {\n\t\t\tcase Utils.isDate( value ):\n\t\t\t\ttype = XSD.DataType.dateTime;\n\t\t\t\tvalue = value.toISOString();\n\t\t\t\tbreak;\n\t\t\tcase Utils.isNumber( value ):\n\t\t\t\tif ( Utils.isInteger( value ) ) {\n\t\t\t\t\ttype = XSD.DataType.integer;\n\t\t\t\t} else {\n\t\t\t\t\ttype = XSD.DataType.double;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Utils.isString( value ):\n\t\t\t\ttype = XSD.DataType.string;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isBoolean( value ):\n\t\t\t\ttype = XSD.DataType.boolean;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Treat it as an unknown object\n\t\t\t\ttype = XSD.DataType.object;\n\t\t\t\tvalue = JSON.stringify( value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet literal:Class = { \"@value\": value.toString() };\n\t\tif ( type ) literal[ \"@type\" ] = type;\n\n\t\treturn literal;\n\t}\n\n\tstatic parse( literal:Class ):any {\n\t\tif ( ! literal ) return null;\n\t\tif ( ! Utils.hasProperty( literal, \"@value\" ) ) return null;\n\t\tif ( ! Utils.hasProperty( literal, \"@type\" ) ) return literal[ \"@value\" ];\n\n\t\tlet type:string = literal[ \"@type\" ];\n\t\t// The DataType isn't supported\n\t\tif ( ! Utils.hasProperty( XSD.DataType, type ) ) return literal[ \"@value\" ];\n\n\t\tlet valueString:string = literal[ \"@value\" ];\n\t\tlet value:any, parts:string[];\n\t\tswitch ( type ) {\n\t\t\t// Dates\n\t\t\tcase XSD.DataType.date:\n\t\t\tcase XSD.DataType.dateTime:\n\t\t\t\tvalue = new Date( valueString );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.time:\n\t\t\t\tparts = valueString.match(/(\\d+):(\\d+):(\\d+)\\.(\\d+)Z/);\n\t\t\t\tvalue = new Date();\n\t\t\t\tvalue.setUTCHours( parseFloat( parts[1] ), parseFloat( parts[2] ), parseFloat( parts[3]), parseFloat( parts[4] ) );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.duration:\n\t\t\t\t// TODO: Support duration values (create a class or something...)\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.gDay:\n\t\t\tcase XSD.DataType.gMonth:\n\t\t\tcase XSD.DataType.gMonthDay:\n\t\t\tcase XSD.DataType.gYear:\n\t\t\tcase XSD.DataType.gYearMonth:\n\t\t\t\t// TODO: Decide. Should we return it as a Date?\n\t\t\t\tbreak;\n\n\t\t\t// Numbers\n\t\t\tcase XSD.DataType.byte :\n\t\t\tcase XSD.DataType.decimal :\n\t\t\tcase XSD.DataType.int :\n\t\t\tcase XSD.DataType.integer :\n\t\t\tcase XSD.DataType.long :\n\t\t\tcase XSD.DataType.negativeInteger :\n\t\t\tcase XSD.DataType.nonNegativeInteger :\n\t\t\tcase XSD.DataType.nonPositiveInteger :\n\t\t\tcase XSD.DataType.positiveInteger :\n\t\t\tcase XSD.DataType.short :\n\t\t\tcase XSD.DataType.unsignedLong :\n\t\t\tcase XSD.DataType.unsignedInt :\n\t\t\tcase XSD.DataType.unsignedShort :\n\t\t\tcase XSD.DataType.unsignedByte :\n\t\t\tcase XSD.DataType.double :\n\t\t\tcase XSD.DataType.float :\n\t\t\t\tvalue = parseFloat( valueString );\n\t\t\t\tbreak;\n\n\t\t\t// Misc\n\t\t\tcase XSD.DataType.boolean :\n\t\t\t\tvalue = Utils.parseBoolean( valueString );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.string:\n\t\t\t\tvalue = valueString;\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.object:\n\t\t\t\tvalue = JSON.parse( valueString );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tstatic is( value:any ):boolean {\n\t\treturn Utils.hasProperty( value, \"@value\" )\n\t\t\t&& Utils.isString( value[ \"@value\" ] );\n\t}\n\n\tstatic hasType( value:Class, type:string ):boolean {\n\t\tif( ! value[ \"@type\" ] && type === <any> XSD.DataType.string ) return true;\n\t\treturn value[ \"@type\" ] === type;\n\t}\n}\n\nexport class Util {\n\tstatic areEqual( literal1:Class, literal2:Class ):boolean {\n\t\t// TODO: Implement\n\t\treturn false;\n\t}\n}\n\nexport default Class;\n\nexport {\n\tSerializer,\n\tSerializers\n};\n"],"sourceRoot":"/source/"}