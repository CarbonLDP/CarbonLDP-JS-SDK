{"version":3,"sources":["RDF/Literal.ts"],"names":["Factory","Factory.constructor","Factory.from","Factory.parse","Factory.is","Factory.hasType","Util","Util.constructor","Util.areEqual"],"mappings":"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","file":"RDF/Literal.js","sourcesContent":["import * as Utils from \"./../Utils\";\nimport * as XSD from \"./../NS/XSD\" ;\n\nimport Serializer from \"./Literal/Serializer\";\nimport * as Serializers from \"./Literal/Serializers\";\n\nexport interface Class {\n\t\"@type\"?:string;\n\t\"@value\":string;\n}\n\nexport class Factory {\n\tstatic from( value:any ):Class {\n\t\tif ( Utils.isNull( value ) ) throw new Error( \"IllegalArgument: null cannot be converted into a Literal\" );\n\n\t\tlet type:any;\n\n\t\tswitch ( true ) {\n\t\t\tcase Utils.isDate( value ):\n\t\t\t\ttype = XSD.DataType.dateTime;\n\t\t\t\tvalue = value.toISOString();\n\t\t\t\tbreak;\n\t\t\tcase Utils.isNumber( value ):\n\t\t\t\tif ( Utils.isInteger( value ) ) {\n\t\t\t\t\ttype = XSD.DataType.integer;\n\t\t\t\t} else type = XSD.DataType.double;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isString( value ):\n\t\t\t\ttype = XSD.DataType.string;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isBoolean( value ):\n\t\t\t\ttype = XSD.DataType.boolean;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Treat it as an unknown object\n\t\t\t\ttype = XSD.DataType.object;\n\t\t\t\tvalue = JSON.stringify( value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet literal:Class = {\"@value\": value};\n\t\tif ( type ) literal[ \"@type\" ] = type;\n\n\t\treturn literal;\n\t}\n\n\tstatic parse( literal:Class ):any {\n\t\tif ( ! literal ) return null;\n\t\tif ( ! Utils.hasProperty( literal, \"@value\" ) ) return null;\n\t\tif ( ! Utils.hasProperty( literal, \"@type\" ) ) return literal[ \"@value\" ];\n\n\t\tlet type:string = literal[ \"@type\" ];\n\t\t// The DataType isn't supported\n\t\tif ( ! Utils.hasProperty( XSD.DataType, type ) ) return literal[ \"@value\" ];\n\n\t\tlet valueString:string = literal[ \"@value\" ];\n\t\tlet value:any;\n\t\tswitch ( type ) {\n\t\t\t// Dates\n\t\t\tcase XSD.DataType.date:\n\t\t\tcase XSD.DataType.dateTime:\n\t\t\tcase XSD.DataType.time:\n\t\t\t\tvalue = new Date( valueString );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.duration:\n\t\t\t\t// TODO: Support duration values (create a class or something...)\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.gDay:\n\t\t\tcase XSD.DataType.gMonth:\n\t\t\tcase XSD.DataType.gMonthDay:\n\t\t\tcase XSD.DataType.gYear:\n\t\t\tcase XSD.DataType.gYearMonth:\n\t\t\t\t// TODO: Decide. Should we return it as a Date?\n\t\t\t\tbreak;\n\n\t\t\t// Numbers\n\t\t\tcase XSD.DataType.byte :\n\t\t\tcase XSD.DataType.decimal :\n\t\t\tcase XSD.DataType.int :\n\t\t\tcase XSD.DataType.integer :\n\t\t\tcase XSD.DataType.long :\n\t\t\tcase XSD.DataType.negativeInteger :\n\t\t\tcase XSD.DataType.nonNegativeInteger :\n\t\t\tcase XSD.DataType.nonPositiveInteger :\n\t\t\tcase XSD.DataType.positiveInteger :\n\t\t\tcase XSD.DataType.short :\n\t\t\tcase XSD.DataType.unsignedLong :\n\t\t\tcase XSD.DataType.unsignedInt :\n\t\t\tcase XSD.DataType.unsignedShort :\n\t\t\tcase XSD.DataType.unsignedByte :\n\t\t\tcase XSD.DataType.double :\n\t\t\tcase XSD.DataType.float :\n\t\t\t\tvalue = parseFloat( valueString );\n\t\t\t\tbreak;\n\n\t\t\t// Misc\n\t\t\tcase XSD.DataType.boolean :\n\t\t\t\tvalue = Utils.parseBoolean( valueString );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.string:\n\t\t\t\tvalue = valueString;\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.object:\n\t\t\t\tvalue = JSON.parse( valueString );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tstatic is( value:any ):boolean {\n\t\tif ( ! value ) return false;\n\t\tif ( ! Utils.isObject( value ) ) return false;\n\t\treturn Utils.hasProperty( value, \"@value\" );\n\t}\n\n\tstatic hasType( value:Class, type:string ):boolean {\n\t\tif( ! value[ \"@type\" ] && type === <any> XSD.DataType.string ) return true;\n\t\treturn value[ \"@type\" ] === type;\n\t}\n}\n\nexport class Util {\n\tstatic areEqual( literal1:Class, literal2:Class ):boolean {\n\t\t// TODO: Implement\n\t\treturn false;\n\t}\n}\n\nexport default Class;\n\nexport {\n\tSerializer,\n\tSerializers\n};\n"],"sourceRoot":"/source/"}