{"version":3,"sources":["RDF/Literal.ts"],"names":["Factory","Factory.constructor","Factory.from","Factory.parse","Factory.is","Factory.hasType","Util","Util.constructor","Util.areEqual"],"mappings":"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","file":"RDF/Literal.js","sourcesContent":["import * as Utils from \"./../Utils\";\nimport * as XSD from \"./../NS/XSD\" ;\n\nimport Serializer from \"./Literal/Serializer\";\nimport * as Serializers from \"./Literal/Serializers\";\n\nexport interface Class {\n\t\"@type\"?:string;\n\t\"@value\":string;\n}\n\nexport class Factory {\n\tstatic from( value:any ):Class {\n\t\tif ( Utils.isNull( value ) ) throw new Error( \"IllegalArgument: null cannot be converted into a Literal\" );\n\n\t\tlet type:any;\n\n\t\tswitch ( true ) {\n\t\t\tcase Utils.isDate( value ):\n\t\t\t\ttype = XSD.DataType.dateTime;\n\t\t\t\tvalue = value.toISOString();\n\t\t\t\tbreak;\n\t\t\tcase Utils.isNumber( value ):\n\t\t\t\tif ( Utils.isInteger( value ) ) {\n\t\t\t\t\ttype = XSD.DataType.integer;\n\t\t\t\t} else type = XSD.DataType.double;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isString( value ):\n\t\t\t\ttype = XSD.DataType.string;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isBoolean( value ):\n\t\t\t\ttype = XSD.DataType.boolean;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Treat it as an unknown object\n\t\t\t\ttype = XSD.DataType.object;\n\t\t\t\tvalue = JSON.stringify( value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet literal:Class = {\"@value\": value};\n\t\tif ( type ) literal[ \"@type\" ] = type;\n\n\t\treturn literal;\n\t}\n\n\tstatic parse( literal:Class ):any {\n\t\tif ( ! literal ) return null;\n\t\tif ( ! Utils.hasProperty( literal, \"@value\" ) ) return null;\n\t\tif ( ! Utils.hasProperty( literal, \"@type\" ) ) return literal[ \"@value\" ];\n\n\t\tlet type:string = literal[ \"@type\" ];\n\t\t// The DataType isn't supported\n\t\tif ( ! Utils.hasProperty( XSD.DataType, type ) ) return literal[ \"@value\" ];\n\n\t\tlet valueString:string = literal[ \"@value\" ];\n\t\tlet value:any;\n\t\tswitch ( type ) {\n\t\t\t// Dates\n\t\t\tcase XSD.DataType.date:\n\t\t\tcase XSD.DataType.dateTime:\n\t\t\tcase XSD.DataType.time:\n\t\t\t\tvalue = new Date( valueString );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.duration:\n\t\t\t\t// TODO: Support duration values (create a class or something...)\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.gDay:\n\t\t\tcase XSD.DataType.gMonth:\n\t\t\tcase XSD.DataType.gMonthDay:\n\t\t\tcase XSD.DataType.gYear:\n\t\t\tcase XSD.DataType.gYearMonth:\n\t\t\t\t// TODO: Decide. Should we return it as a Date?\n\t\t\t\tbreak;\n\n\t\t\t// Numbers\n\t\t\tcase XSD.DataType.byte :\n\t\t\tcase XSD.DataType.decimal :\n\t\t\tcase XSD.DataType.int :\n\t\t\tcase XSD.DataType.integer :\n\t\t\tcase XSD.DataType.long :\n\t\t\tcase XSD.DataType.negativeInteger :\n\t\t\tcase XSD.DataType.nonNegativeInteger :\n\t\t\tcase XSD.DataType.nonPositiveInteger :\n\t\t\tcase XSD.DataType.positiveInteger :\n\t\t\tcase XSD.DataType.short :\n\t\t\tcase XSD.DataType.unsignedLong :\n\t\t\tcase XSD.DataType.unsignedInt :\n\t\t\tcase XSD.DataType.unsignedShort :\n\t\t\tcase XSD.DataType.unsignedByte :\n\t\t\tcase XSD.DataType.double :\n\t\t\tcase XSD.DataType.float :\n\t\t\t\tvalue = parseFloat( valueString );\n\t\t\t\tbreak;\n\n\t\t\t// Misc\n\t\t\tcase XSD.DataType.boolean :\n\t\t\t\tvalue = Utils.parseBoolean( valueString );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.string:\n\t\t\t\tvalue = valueString;\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.object:\n\t\t\t\tvalue = JSON.parse( valueString );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tstatic is( value:any ):boolean {\n\t\tif ( ! value ) return false;\n\t\tif ( ! Utils.isObject( value ) ) return false;\n\t\treturn Utils.hasProperty( value, \"@value\" );\n\t}\n\n\tstatic hasType( value:Class, type:string ):boolean {\n\t\tif( ! value[ \"@type\" ] && type === <any> XSD.DataType.string ) return true;\n\t\treturn value[ \"@type\" ] === type;\n\t}\n}\n\nexport class Util {\n\tstatic areEqual( literal1:Class, literal2:Class ):boolean {\n\t\t// TODO: Implement\n\t\treturn false;\n\t}\n}\n\nexport default Class;\n\nexport {\n\tSerializer,\n\tSerializers\n};\n"],"sourceRoot":"/source/"}