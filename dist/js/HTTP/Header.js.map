{"version":3,"sources":["HTTP/Header.ts"],"names":["Class","Class.constructor","Class.toString","Class.setValues","Value","Value.constructor","Value.toString","Util","Util.constructor","Util.parseHeaders"],"mappings":"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","file":"HTTP/Header.js","sourcesContent":["/// <reference path=\"../../typings/typings.d.ts\" />\n\nimport * as Utils from \"./../Utils\";\n\nexport class Class {\n\tconstructor();\n\tconstructor( values:Value[] );\n\tconstructor( value:string );\n\tconstructor( valueOrValues?:(string | Value[]) ) {\n\t\tif ( ! valueOrValues ) {\n\t\t\treturn;\n\t\t} else if ( Array.isArray( valueOrValues ) ) {\n\t\t\tthis.values = <Value[]> valueOrValues;\n\t\t} else {\n\t\t\tthis.setValues( <string> valueOrValues );\n\t\t}\n\t}\n\n\tvalues:Value[] = [];\n\n\ttoString():string {\n\t\treturn this.values.join( \", \" );\n\t}\n\n\tprivate setValues( valuesString:string ):void {\n\t\tthis.values = [];\n\n\t\tlet valueStrings:string[] = valuesString.split( \",\" );\n\t\tfor ( let i:number = 0, length:number = valueStrings.length; i < length; i ++ ) {\n\t\t\tlet valueString:string = valueStrings[ i ];\n\t\t\tthis.values.push( new Value( valueString ) );\n\t\t}\n\t}\n}\n\nexport class Value {\n\tprivate value:string;\n\n\tconstructor( value:string ) {\n\t\tthis.value = value;\n\t}\n\n\ttoString():string {\n\t\treturn this.value;\n\t}\n}\n\nexport class Util {\n\tstatic parseHeaders( headersString:string ):Map<string, Class> {\n\t\tlet headers:Map<string, Class> = new Map<string, Class>();\n\n\t\tlet headerStrings:string[] = headersString.split( \"\\r\\n\" );\n\t\tfor ( let i:number = 0, length:number = headerStrings.length; i < length; i ++ ) {\n\t\t\tlet headerString:string = headerStrings[ i ];\n\t\t\tif ( ! headerString.trim() ) continue;\n\n\t\t\tlet parts:string[] = headerString.split( \":\" );\n\t\t\tif ( parts.length < 2 ) throw new Error( \"ParseError: The header couldn't be parsed.\" );\n\t\t\tif ( parts.length > 2 ) parts[ 1 ] = parts.slice( 1 ).join( \":\" );\n\n\t\t\tlet name:string = parts[ 0 ].trim();\n\t\t\tlet header:Class = new Class( parts[ 1 ].trim() );\n\t\t\tif ( headers.has( name ) ) {\n\t\t\t\tlet existingHeader:Class = headers.get( name );\n\t\t\t\texistingHeader.values.concat( header.values );\n\t\t\t} else headers.set( name, header );\n\t\t}\n\n\t\treturn headers;\n\t}\n}\n"],"sourceRoot":"/source/"}