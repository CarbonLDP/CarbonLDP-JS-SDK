{"version":3,"sources":["HTTP/Header.ts"],"names":["Class","Class.constructor","Class.toString","Class.setValues","Value","Value.constructor","Value.toString","Util","Util.constructor","Util.parseHeaders"],"mappings":"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","file":"HTTP/Header.js","sourcesContent":["/// <reference path=\"../../typings/es6/es6.d.ts\" />\n\nimport * as Utils from \"./../Utils\";\n\nexport class Class {\n\tconstructor();\n\tconstructor( values:Value[] );\n\tconstructor( value:string );\n\tconstructor( valueOrValues?:(string | Value[]) ) {\n\t\tif ( ! valueOrValues ) {\n\t\t\treturn;\n\t\t} else if ( Array.isArray( valueOrValues ) ) {\n\t\t\tthis.values = <Value[]> valueOrValues;\n\t\t} else {\n\t\t\tthis.setValues( <string> valueOrValues );\n\t\t}\n\t}\n\n\tvalues:Value[] = [];\n\n\ttoString():string {\n\t\treturn this.values.join( \", \" );\n\t}\n\n\tprivate setValues( valuesString:string ):void {\n\t\tthis.values = [];\n\n\t\tlet valueStrings:string[] = valuesString.split( \",\" );\n\t\tfor ( let i:number = 0, length:number = valueStrings.length; i < length; i ++ ) {\n\t\t\tlet valueString:string = valueStrings[ i ];\n\t\t\tthis.values.push( new Value( valueString ) );\n\t\t}\n\t}\n}\n\nexport class Value {\n\tprivate value:string;\n\n\tconstructor( value:string ) {\n\t\tthis.value = value;\n\t}\n\n\ttoString():string {\n\t\treturn this.value;\n\t}\n}\n\nexport class Util {\n\tstatic parseHeaders( headersString:string ):Map<string, Class> {\n\t\tlet headers:Map<string, Class> = new Map<string, Class>();\n\n\t\tlet headerStrings:string[] = headersString.split( \"\\r\\n\" );\n\t\tfor ( let i:number = 0, length:number = headerStrings.length; i < length; i ++ ) {\n\t\t\tlet headerString:string = headerStrings[ i ];\n\t\t\tif ( ! headerString.trim() ) continue;\n\n\t\t\tlet parts:string[] = headerString.split( \":\" );\n\t\t\tif ( parts.length < 2 ) throw new Error( \"ParseError: The header couldn't be parsed.\" );\n\t\t\tif ( parts.length > 2 ) parts[ 1 ] = parts.slice( 1 ).join( \":\" );\n\n\t\t\tlet name:string = parts[ 0 ].trim();\n\t\t\tlet header:Class = new Class( parts[ 1 ].trim() );\n\t\t\tif ( headers.has( name ) ) {\n\t\t\t\tlet existingHeader:Class = headers.get( name );\n\t\t\t\texistingHeader.values.concat( header.values );\n\t\t\t} else headers.set( name, header );\n\t\t}\n\n\t\treturn headers;\n\t}\n}\n"],"sourceRoot":"/source/"}