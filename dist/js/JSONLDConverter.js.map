{"version":3,"sources":["JSONLDConverter.ts"],"names":["Class","Class.expandPropertyPointers","Class.expandPropertyLiterals","Class.expandArray","Class.getPropertyPointer","Class.getPropertyLiteral","Class.getPropertyList","Class.getPropertyPointerList","Class.getPropertyLiteralList","Class.getProperties","Class.getPropertyPointers","Class.getPropertyLiterals","Class.getPropertyLanguageMap","Class.getList","Class.parseValue"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBA+BcA,2EAAyDA;;;;;;;;;;4BAQgDA,uEAAiCA;;;;;;;;;;;;;;;;;;;4BAqB1DA,yEAAqCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAwIvGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAcAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDA8DJC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAsJIC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAaAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAkBJC,aAAcA,OAAdA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAeAC,aAAcA,OAAdA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAkBAC,aAAcA,OAAdA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAgBIC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAaAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAeAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAeAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mDAcAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uDAwBHC","file":"JSONLDConverter.js","sourcesContent":["/// <reference path=\"./../typings/typings.d.ts\" />\n\nimport * as Errors from \"./Errors\";\nimport * as ObjectSchema from \"./ObjectSchema\";\nimport * as NS from \"./NS\";\nimport * as Pointer from \"./Pointer\";\nimport * as RDF from \"./RDF\";\nimport * as Utils from \"./Utils\";\n\nexport class Class {\n\tprivate _literalSerializers:Map<string, RDF.Literal.Serializer>;\n\n\tget literalSerializers():Map<string, RDF.Literal.Serializer> { return this._literalSerializers; };\n\n\tprivate static getDefaultSerializers():Map<string, RDF.Literal.Serializer> {\n\t\tlet literalSerializers:Map<string, RDF.Literal.Serializer> = new Map<string, RDF.Literal.Serializer>();\n\n\t\tliteralSerializers.set( NS.XSD.DataType.date, RDF.Literal.Serializers.XSD.dateSerializer );\n\t\tliteralSerializers.set( NS.XSD.DataType.dateTime, RDF.Literal.Serializers.XSD.dateTimeSerializer );\n\t\tliteralSerializers.set( NS.XSD.DataType.time, RDF.Literal.Serializers.XSD.timeSerializer );\n\t\tliteralSerializers.set( NS.XSD.DataType.integer, RDF.Literal.Serializers.XSD.integerSerializer );\n\t\tliteralSerializers.set( NS.XSD.DataType.int, RDF.Literal.Serializers.XSD.integerSerializer );\n\t\tliteralSerializers.set( NS.XSD.DataType.unsignedInt, RDF.Literal.Serializers.XSD.unsignedIntegerSerializer );\n\t\tliteralSerializers.set( NS.XSD.DataType.float, RDF.Literal.Serializers.XSD.floatSerializer );\n\t\tliteralSerializers.set( NS.XSD.DataType.double, RDF.Literal.Serializers.XSD.floatSerializer );\n\t\tliteralSerializers.set( NS.XSD.DataType.boolean, RDF.Literal.Serializers.XSD.booleanSerializer );\n\t\tliteralSerializers.set( NS.XSD.DataType.string, RDF.Literal.Serializers.XSD.stringSerializer );\n\n\t\treturn literalSerializers;\n\t}\n\n\tconstructor( literalSerializers:Map<string, RDF.Literal.Serializer> = null ) {\n\t\tthis._literalSerializers = !! literalSerializers ? literalSerializers : Class.getDefaultSerializers();\n\t}\n\n\tcompact( expandedObjects:Object[], targetObjects:Object[], digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:Pointer.Library ):Object[];\n\tcompact( expandedObject:Object, targetObject:Object, digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:Pointer.Library ):Object;\n\tcompact( expandedObjects:Object[], digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:Pointer.Library ):Object[];\n\tcompact( expandedObject:Object, digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:Pointer.Library ):Object;\n\tcompact( expandedObjectOrObjects:any, targetObjectOrObjectsOrDigestedContext:any, digestedSchemaOrPointerLibrary:any, pointerLibrary:Pointer.Library = null ):any {\n\t\tlet targetObjectOrObjects:any = ! pointerLibrary ? null : targetObjectOrObjectsOrDigestedContext;\n\t\tlet digestedSchema:any = ! pointerLibrary ? targetObjectOrObjectsOrDigestedContext : digestedSchemaOrPointerLibrary;\n\t\tpointerLibrary = ! pointerLibrary ? digestedSchemaOrPointerLibrary : pointerLibrary;\n\n\t\tif( ! Utils.isArray( expandedObjectOrObjects ) ) return this.compactSingle( expandedObjectOrObjects, targetObjectOrObjects, digestedSchema, pointerLibrary );\n\n\t\tlet expandedObjects:Object[] = expandedObjectOrObjects;\n\t\tlet targetObjects:Object[] = !! targetObjectOrObjects ? targetObjectOrObjects : [];\n\t\tfor( let i:number = 0, length:number = expandedObjects.length; i < length; i++ ) {\n\t\t\tlet expandedObject:Object = expandedObjects[ i ];\n\t\t\tlet targetObject:Object = targetObjects[ i ] = !! targetObjects[ i ] ? targetObjects[ i ] : {};\n\n\t\t\tthis.compactSingle( expandedObject, targetObject, digestedSchema, pointerLibrary );\n\t\t}\n\n\t\treturn targetObjects;\n\t}\n\n\texpand( compactedObjects:Object[], digestedSchema:ObjectSchema.DigestedObjectSchema, pointerValidator?:Pointer.Validator ):RDF.Node.Class[];\n\texpand( compactedObject:Object, digestedSchema:ObjectSchema.DigestedObjectSchema, pointerValidator?:Pointer.Validator ):RDF.Node.Class;\n\texpand( compactedObjectOrObjects:Object[], digestedSchema:ObjectSchema.DigestedObjectSchema, pointerValidator:Pointer.Validator = null ):any {\n\t\tif( ! Utils.isArray( compactedObjectOrObjects ) ) return this.expandSingle( compactedObjectOrObjects, digestedSchema, pointerValidator );\n\t}\n\n\tprivate expandSingle( compactedObject:Object, digestedSchema:ObjectSchema.DigestedObjectSchema, pointerValidator:Pointer.Validator ):RDF.Node.Class {\n\t\tlet expandedObject:any = {};\n\n\t\texpandedObject[ \"@id\" ] = !! compactedObject[ \"id\" ] ? compactedObject[ \"id\" ] : \"\";\n\t\tif( !! compactedObject[ \"types\" ] ) expandedObject[ \"@type\" ] = compactedObject[ \"types\" ];\n\n\t\tUtils.forEachOwnProperty( compactedObject, ( propertyName:string, value:any ):void => {\n\t\t\tif( propertyName === \"id\" ) return;\n\n\t\t\tif( digestedSchema.properties.has( propertyName ) ) {\n\t\t\t\tlet definition:ObjectSchema.DigestedPropertyDefinition = digestedSchema.properties.get( propertyName );\n\t\t\t\tlet expandedValue:any = this.expandProperty( value, definition, pointerValidator );\n\n\t\t\t\tif( ! expandedValue ) return;\n\n\t\t\t\texpandedObject[ definition.uri.toString() ] = expandedValue;\n\t\t\t} else {\n\t\t\t\t// TODO: Do your best. Use the default vocabulary\n\t\t\t}\n\t\t});\n\n\t\treturn expandedObject;\n\t}\n\n\tprivate expandProperty( propertyValue:any, propertyDefinition:ObjectSchema.DigestedPropertyDefinition, pointerValidator:Pointer.Validator ):any {\n\t\tswitch( propertyDefinition.containerType ) {\n\t\t\tcase null:\n\t\t\t\t// Property is not a list\n\t\t\t\tif( propertyDefinition.literal ) {\n\t\t\t\t\treturn this.expandPropertyLiteral( propertyValue, propertyDefinition.literalType.toString() );\n\t\t\t\t} else if( propertyDefinition.literal === false ) {\n\t\t\t\t\treturn this.expandPropertyPointer( propertyValue, pointerValidator );\n\t\t\t\t} else {\n\t\t\t\t\treturn this.expandPropertyValue( propertyValue, pointerValidator );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ObjectSchema.ContainerType.LIST:\n\t\t\t\tif( propertyDefinition.literal ) {\n\t\t\t\t\treturn this.expandPropertyLiteralList( propertyValue, propertyDefinition.literalType.toString() );\n\t\t\t\t} else if( propertyDefinition.literal === false ) {\n\t\t\t\t\treturn this.expandPropertyPointerList( propertyValue, pointerValidator );\n\t\t\t\t} else {\n\t\t\t\t\treturn this.expandPropertyList( propertyValue, pointerValidator );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ObjectSchema.ContainerType.SET:\n\t\t\t\tif( propertyDefinition.literal ) {\n\t\t\t\t\treturn this.expandPropertyLiterals( propertyValue, propertyDefinition.literalType.toString() );\n\t\t\t\t} else if( propertyDefinition.literal === false ) {\n\t\t\t\t\treturn this.expandPropertyPointers( propertyValue, pointerValidator );\n\t\t\t\t} else {\n\t\t\t\t\treturn this.expandPropertyValues( propertyValue, pointerValidator );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ObjectSchema.ContainerType.LANGUAGE:\n\t\t\t\treturn this.expandPropertyLanguageMap( propertyValue );\n\t\t\tdefault:\n\t\t\t\tthrow new Errors.IllegalArgumentError( \"The containerType specified is not supported.\" );\n\t\t}\n\t}\n\n\tprivate expandPropertyValue( propertyValue:any, pointerValidator:Pointer.Validator ):any {\n\t\tif( Utils.isArray( propertyValue ) ) {\n\t\t\treturn this.expandPropertyValues( propertyValue, pointerValidator );\n\t\t} else {\n\t\t\tlet expandedValue:RDF.Node.Class = this.expandValue( propertyValue, pointerValidator );\n\n\t\t\tif( ! expandedValue ) return null;\n\n\t\t\treturn [ expandedValue ];\n\t\t}\n\t}\n\n\tprivate expandPropertyPointer( propertyValue:any, pointerValidator:Pointer.Validator ):any {\n\t\tlet expandedPointer:RDF.Node.Class = this.expandPointer( propertyValue, pointerValidator );\n\n\t\tif( ! expandedPointer ) return null;\n\n\t\treturn [ expandedPointer ];\n\t}\n\n\tprivate expandPropertyLiteral( propertyValue:any, literalType:string ):any {\n\t\t// TODO: Language\n\t\tlet serializedValue:string = this.serializeLiteral( propertyValue, literalType );\n\n\t\tif( serializedValue === null ) return null;\n\n\t\treturn [\n\t\t\t{ \"@value\": serializedValue, \"@type\": literalType }\n\t\t];\n\t}\n\n\tprivate expandPropertyList( propertyValues:any, pointerValidator:Pointer.Validator ):any {\n\t\tpropertyValues = Utils.isArray( propertyValues ) ? propertyValues : [ propertyValues ];\n\n\t\tlet expandedArray:any = this.expandArray( propertyValues, pointerValidator );\n\n\t\tif( ! expandedArray ) return null;\n\n\t\treturn [\n\t\t\t{ \"@list\": expandedArray }\n\t\t];\n\t}\n\n\tprivate expandPropertyPointerList( propertyValues:any, pointerValidator:Pointer.Validator ):any {\n\t\tlet listValues:Array<any> = this.expandPropertyPointers( propertyValues, pointerValidator );\n\n\t\treturn [\n\t\t\t{ \"@list\": listValues }\n\t\t];\n\t}\n\n\tprivate expandPropertyLiteralList( propertyValues:any, literalType:string ):any {\n\t\tlet listValues:Array<any> = this.expandPropertyLiterals( propertyValues, literalType );\n\n\t\treturn [\n\t\t\t{ \"@list\": listValues }\n\t\t];\n\t}\n\n\tprivate expandPropertyValues( propertyValue:any, pointerValidator:Pointer.Validator ):any {\n\t\tlet expandedArray:any = this.expandArray( propertyValue, pointerValidator );\n\n\t\tif( ! expandedArray ) return null;\n\n\t\treturn expandedArray;\n\t}\n\n\tprivate expandPropertyPointers( propertyValues:any, pointerValidator:Pointer.Validator ):any {\n\t\tpropertyValues = Utils.isArray( propertyValues ) ? propertyValues : [ propertyValues ];\n\n\t\tlet expandedPointers:Array<any> = [];\n\t\tfor( let propertyValue of propertyValues ) {\n\t\t\tlet expandedPointer:RDF.Node.Class = this.expandPointer( propertyValue, pointerValidator );\n\t\t\tif( ! expandedPointer ) continue;\n\n\t\t\texpandedPointers.push( expandedPointer );\n\t\t}\n\n\t\treturn expandedPointers;\n\t}\n\n\tprivate expandPropertyLiterals( propertyValues:any, literalType:string ):any {\n\t\tpropertyValues = Utils.isArray( propertyValues ) ? propertyValues : [ propertyValues ];\n\n\t\tlet listValues:Array<any> = [];\n\t\tfor( let propertyValue of propertyValues ) {\n\t\t\tlet serializedValue:string = this.serializeLiteral( propertyValue, literalType );\n\t\t\tif( ! serializedValue ) continue;\n\n\t\t\tlistValues.push( { \"@value\": serializedValue, \"@type\": literalType } );\n\t\t}\n\n\t\treturn listValues;\n\t}\n\n\tprivate expandPropertyLanguageMap( propertyValue:any ):any {\n\t\tif( ! Utils.isObject( propertyValue ) ) {\n\t\t\t// TODO: Warn of data loss\n\t\t\treturn null;\n\t\t}\n\n\t\tlet mapValues:Array<any> = [];\n\t\tUtils.forEachOwnProperty( propertyValue, ( languageTag:string, value:any ):void => {\n\t\t\t// TODO: Validate language tags\n\n\t\t\tlet serializedValue:string = this.literalSerializers.get( NS.XSD.DataType.string ).serialize( value );\n\t\t\tmapValues.push( { \"@value\": serializedValue, \"@type\": NS.XSD.DataType.string, \"@language\": languageTag } );\n\t\t});\n\n\t\treturn mapValues;\n\t}\n\n\tprivate serializeLiteral( propertyValue:any, literalType:string ):string {\n\t\tif( Pointer.Factory.is( propertyValue ) ) {\n\t\t\t// TODO: Warn of data loss\n\t\t\treturn null;\n\t\t}\n\n\t\tif( ! this.literalSerializers.has( literalType ) ) {\n\t\t\t// TODO: Warn of data loss\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\treturn this.literalSerializers.get( literalType ).serialize( propertyValue );\n\t\t} catch( error ) {\n\t\t\t// TODO: Warn of data loss\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate expandPointer( propertyValue:any, pointerValidator:Pointer.Validator ):RDF.Node.Class {\n\t\tif( ! Pointer.Factory.is( propertyValue ) ) {\n\t\t\t// TODO: Warn of data loss\n\t\t\treturn null;\n\t\t}\n\n\t\tif( !! pointerValidator && ! pointerValidator.inScope( propertyValue ) ) {\n\t\t\t// TODO: Warn of data loss\n\t\t\treturn null;\n\t\t}\n\n\t\treturn { \"@id\": propertyValue.id };\n\t}\n\n\tprivate expandArray( propertyValue:any, pointerValidator:Pointer.Validator ):any {\n\t\tlet listValues:Array<any> = [];\n\t\tfor( let listValue of propertyValue ) {\n\t\t\tlet expandedValue:any = this.expandValue( listValue, pointerValidator );\n\t\t\tif( ! expandedValue ) continue;\n\n\t\t\tlistValues.push( expandedValue );\n\t\t}\n\n\t\tif( ! listValues.length ) return null;\n\n\t\treturn listValues;\n\t}\n\n\tprivate expandValue( propertyValue:any, pointerValidator:Pointer.Validator ):any {\n\t\tif( Utils.isArray( propertyValue ) ) {\n\t\t\t// TODO: Lists of lists are not currently supported by the spec\n\t\t\treturn null;\n\t\t} else if( Pointer.Factory.is( propertyValue ) ) {\n\t\t\treturn this.expandPointer( propertyValue, pointerValidator );\n\t\t} else {\n\t\t\treturn this.expandLiteral( propertyValue );\n\t\t}\n\t}\n\n\tprivate expandLiteral( literalValue:any ):any {\n\t\tlet serializedValue:string;\n\t\tlet literalType:string;\n\t\tswitch( true ) {\n\t\t\tcase Utils.isFunction( literalValue ):\n\t\t\t\treturn null;\n\t\t\tcase Utils.isDate( literalValue ):\n\t\t\t\tliteralType = NS.XSD.DataType.dateTime;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isNumber( literalValue ):\n\t\t\t\tliteralType = NS.XSD.DataType.float;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isBoolean( literalValue ):\n\t\t\t\tliteralType = NS.XSD.DataType.boolean;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isString( literalValue ):\n\t\t\t\tliteralType = NS.XSD.DataType.string;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// TODO: Warn of data loss\n\t\t\t\treturn null;\n\t\t}\n\n\t\tserializedValue = this.literalSerializers.get( literalType ).serialize( literalValue );\n\n\t\treturn { \"@value\": serializedValue, \"@type\": literalType };\n\t}\n\n\tprivate compactSingle( expandedObject:any, targetObject:any, digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:Pointer.Library ):void {\n\t\tlet propertyURINameMap:Map<string, string> = this.getPropertyURINameMap( digestedSchema );\n\n\t\tif( ! expandedObject[ \"@id\" ] ) throw new Errors.IllegalArgumentError( \"The expandedObject doesn't have an @id defined.\" );\n\t\ttargetObject[ \"id\" ] = expandedObject[ \"@id\" ];\n\n\t\ttargetObject[ \"types\" ] = !! expandedObject[ \"@type\" ] ? expandedObject[ \"@type\" ] : [];\n\n\t\tUtils.forEachOwnProperty( expandedObject, ( propertyURI:string, value:any ):void => {\n\t\t\tif( propertyURI === \"@id\" ) return;\n\t\t\tif( propertyURI === \"@type\" ) return;\n\n\t\t\tif( propertyURINameMap.has( propertyURI ) ) {\n\t\t\t\tlet propertyName:string = propertyURINameMap.get( propertyURI );\n\t\t\t\tthis.assignProperty( targetObject, expandedObject, propertyName, digestedSchema, pointerLibrary );\n\t\t\t} else {\n\t\t\t\tthis.assignURIProperty( targetObject, expandedObject, propertyURI, pointerLibrary );\n\t\t\t}\n\t\t});\n\n\t\treturn targetObject;\n\t}\n\n\tprivate assignProperty( compactedObject:any, expandedObject:any, propertyName:string, digestedSchema:ObjectSchema.DigestedObjectSchema, pointerLibrary:Pointer.Library ):void {\n\t\tlet propertyDefinition:ObjectSchema.DigestedPropertyDefinition = digestedSchema.properties.get( propertyName );\n\t\tcompactedObject[ propertyName ] = this.getPropertyValue( expandedObject, propertyDefinition, pointerLibrary );\n\t}\n\n\tprivate assignURIProperty( compactedObject:any, expandedObject:any, propertyURI:string, pointerLibrary:Pointer.Library ):void {\n\t\tlet guessedDefinition:ObjectSchema.DigestedPropertyDefinition = new ObjectSchema.DigestedPropertyDefinition();\n\t\tguessedDefinition.uri = new RDF.URI.Class( propertyURI );\n\t\tguessedDefinition.containerType = this.getPropertyContainerType( expandedObject[ propertyURI ] );\n\n\t\tcompactedObject[ propertyURI ] = this.getPropertyValue( expandedObject, guessedDefinition, pointerLibrary );\n\t}\n\n\tprivate getPropertyContainerType( propertyValues:any ):ObjectSchema.ContainerType {\n\t\tif( propertyValues.length === 1 ) {\n\t\t\tif( RDF.List.Factory.is( propertyValues[ 0 ] ) ) return ObjectSchema.ContainerType.LIST;\n\t\t} else {\n\t\t\treturn ObjectSchema.ContainerType.SET;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getPropertyValue( expandedObject:any, propertyDefinition:ObjectSchema.DigestedPropertyDefinition, pointerLibrary:Pointer.Library ):any {\n\t\tlet propertyURI:string = propertyDefinition.uri.toString();\n\n\t\tswitch( propertyDefinition.containerType ) {\n\t\t\tcase null:\n\t\t\t\t// Property is not a list\n\t\t\t\tif( propertyDefinition.literal ) {\n\t\t\t\t\treturn this.getPropertyLiteral( expandedObject, propertyURI, propertyDefinition.literalType.toString() );\n\t\t\t\t} else if( propertyDefinition.literal === false ) {\n\t\t\t\t\treturn this.getPropertyPointer( expandedObject, propertyURI, pointerLibrary );\n\t\t\t\t} else {\n\t\t\t\t\treturn this.getProperty( expandedObject, propertyURI, pointerLibrary );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ObjectSchema.ContainerType.LIST:\n\t\t\t\tif( propertyDefinition.literal ) {\n\t\t\t\t\treturn this.getPropertyLiteralList( expandedObject, propertyURI, propertyDefinition.literalType.toString() );\n\t\t\t\t} else if( propertyDefinition.literal === false ) {\n\t\t\t\t\treturn this.getPropertyPointerList( expandedObject, propertyURI, pointerLibrary );\n\t\t\t\t} else {\n\t\t\t\t\treturn this.getPropertyList( expandedObject, propertyURI, pointerLibrary );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ObjectSchema.ContainerType.SET:\n\t\t\t\tif( propertyDefinition.literal ) {\n\t\t\t\t\treturn this.getPropertyLiterals( expandedObject, propertyURI, propertyDefinition.literalType.toString() );\n\t\t\t\t} else if( propertyDefinition.literal === false ) {\n\t\t\t\t\treturn this.getPropertyPointers( expandedObject, propertyURI, pointerLibrary );\n\t\t\t\t} else {\n\t\t\t\t\treturn this.getProperties( expandedObject, propertyURI, pointerLibrary );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ObjectSchema.ContainerType.LANGUAGE:\n\t\t\t\treturn this.getPropertyLanguageMap( expandedObject, propertyURI );\n\t\t\tdefault:\n\t\t\t\tthrow new Errors.IllegalArgumentError( \"The containerType specified is not supported.\" );\n\t\t}\n\t}\n\n\tprivate getProperty( expandedObject:any, propertyURI:string, pointerLibrary:Pointer.Library ):any {\n\t\tlet propertyValues:Array<any> = expandedObject[ propertyURI ];\n\t\tif( ! propertyValues ) return null;\n\t\tif( ! propertyValues.length ) return null;\n\n\t\tlet propertyValue:any = propertyValues[ 0 ];\n\n\t\treturn this.parseValue( propertyValue, pointerLibrary );\n\t}\n\n\tprivate getPropertyPointer( expandedObject:any, propertyURI:string, pointerLibrary:Pointer.Library ):any {\n\t\tlet propertyValues:Array<any> = expandedObject[ propertyURI ];\n\t\tif( ! propertyValues ) return null;\n\n\t\tfor( let propertyValue of propertyValues ) {\n\t\t\tif( ! RDF.Node.Factory.is( propertyValue ) ) continue;\n\n\t\t\treturn pointerLibrary.getPointer( propertyValue[ \"@id\" ] );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getPropertyLiteral( expandedObject:any, propertyURI:string, literalType:string ):any {\n\t\tlet propertyValues:Array<any> = expandedObject[ propertyURI ];\n\t\tif( ! propertyValues ) return null;\n\n\t\tfor( let propertyValue of propertyValues ) {\n\t\t\tif( ! RDF.Literal.Factory.is( propertyValue ) ) continue;\n\t\t\tif( ! RDF.Literal.Factory.hasType( propertyValue, literalType ) ) continue;\n\n\t\t\treturn RDF.Literal.Factory.parse( propertyValue );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getPropertyList( expandedObject:any, propertyURI:string, pointerLibrary:Pointer.Library ):any {\n\t\tlet propertyValues:Array<any> = expandedObject[ propertyURI ];\n\t\tif( ! propertyValues ) return null;\n\n\t\tlet propertyList:RDF.List.Class = this.getList( propertyValues );\n\t\tif( ! propertyList ) return null;\n\n\t\tlet listValues:Array<any> = [];\n\t\tfor( let listValue of propertyList[ \"@list\" ] ) {\n\t\t\tlistValues.push( this.parseValue( listValue, pointerLibrary ) );\n\t\t}\n\n\t\treturn listValues;\n\t}\n\n\tprivate getPropertyPointerList( expandedObject:any, propertyURI:string, pointerLibrary:Pointer.Library ):any {\n\t\tlet propertyValues:Array<any> = expandedObject[ propertyURI ];\n\t\tif( ! propertyValues ) return null;\n\n\t\tlet propertyList:RDF.List.Class = this.getList( propertyValues );\n\t\tif( ! propertyList ) return null;\n\n\t\tlet listPointers:Array<any> = [];\n\t\tfor( let listValue of propertyList[ \"@list\" ] ) {\n\t\t\tif( ! RDF.Node.Factory.is( listValue ) ) continue;\n\n\t\t\tlet pointer:Pointer.Class = pointerLibrary.getPointer( listValue[ \"@id\" ] );\n\t\t\tlistPointers.push( pointer );\n\t\t}\n\n\t\treturn listPointers;\n\t}\n\n\tprivate getPropertyLiteralList( expandedObject:any, propertyURI:string, literalType:string ):any {\n\t\tlet propertyValues:Array<any> = expandedObject[ propertyURI ];\n\t\tif( ! propertyValues ) return null;\n\n\t\tlet propertyList:RDF.List.Class = this.getList( propertyValues );\n\t\tif( ! propertyList ) return null;\n\n\t\tlet listLiterals:Array<any> = [];\n\t\tfor( let listValue of propertyList[ \"@list\" ] ) {\n\t\t\tif( ! RDF.Literal.Factory.is( listValue ) ) continue;\n\t\t\tif( ! RDF.Literal.Factory.hasType( <any> listValue, literalType ) ) continue;\n\n\t\t\tlistLiterals.push( RDF.Literal.Factory.parse( <any> listValue ) );\n\t\t}\n\n\t\treturn listLiterals;\n\t}\n\n\tprivate getProperties( expandedObject:any, propertyURI:string, pointerLibrary:Pointer.Library ):any {\n\t\tlet propertyValues:Array<any> = expandedObject[ propertyURI ];\n\t\tif( ! propertyValues ) return null;\n\t\tif( ! propertyValues.length ) return null;\n\n\t\tlet properties:Array<any> = [];\n\t\tfor( let propertyValue of propertyValues ) {\n\t\t\tproperties.push( this.parseValue( propertyValue, pointerLibrary ) );\n\t\t}\n\n\t\treturn properties;\n\t}\n\n\tprivate getPropertyPointers( expandedObject:any, propertyURI:string, pointerLibrary:Pointer.Library ):any {\n\t\tlet propertyValues:Array<any> = expandedObject[ propertyURI ];\n\t\tif( ! propertyValues ) return null;\n\t\tif( ! propertyValues.length ) return null;\n\n\t\tlet propertyPointers:Array<any> = [];\n\t\tfor( let propertyValue of propertyValues ) {\n\t\t\tif( ! RDF.Node.Factory.is( propertyValue ) ) continue;\n\n\t\t\tlet pointer:Pointer.Class = pointerLibrary.getPointer( propertyValue[ \"@id\" ] );\n\t\t\tpropertyPointers.push( pointer );\n\t\t}\n\n\t\treturn propertyPointers;\n\t}\n\n\tprivate getPropertyLiterals( expandedObject:any, propertyURI:string, literalType:string ):any {\n\t\tlet propertyValues:Array<any> = expandedObject[ propertyURI ];\n\t\tif( ! propertyValues ) return null;\n\n\t\tlet propertyLiterals:Array<any> = [];\n\t\tfor( let propertyValue of propertyValues ) {\n\t\t\tif( ! RDF.Literal.Factory.is( propertyValue ) ) continue;\n\t\t\tif( ! RDF.Literal.Factory.hasType( propertyValue, literalType ) ) continue;\n\n\t\t\tpropertyLiterals.push( RDF.Literal.Factory.parse( propertyValue ) );\n\t\t}\n\n\t\treturn propertyLiterals;\n\t}\n\n\tprivate getPropertyLanguageMap( expandedObject:any, propertyURI:string ):any {\n\t\tlet propertyValues:Array<any> = expandedObject[ propertyURI ];\n\t\tif( ! propertyValues ) return null;\n\n\t\tlet propertyLanguageMap:any = {};\n\t\tfor( let propertyValue of propertyValues ) {\n\t\t\tif( ! RDF.Literal.Factory.is( propertyValue ) ) continue;\n\t\t\tif( ! RDF.Literal.Factory.hasType( propertyValue, NS.XSD.DataType.string ) ) continue;\n\n\t\t\tlet languageTag:string = propertyValue[ \"@language\" ];\n\t\t\tif( ! languageTag ) continue;\n\n\t\t\tpropertyLanguageMap[ languageTag ] = RDF.Literal.Factory.parse( propertyValue );\n\t\t}\n\n\t\treturn propertyLanguageMap;\n\t}\n\n\tprivate getList( propertyValues:Array<any> ):RDF.List.Class {\n\t\tfor( let propertyValue of propertyValues ) {\n\t\t\tif( ! RDF.List.Factory.is( propertyValue ) ) continue;\n\n\t\t\treturn propertyValue;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate getPropertyURINameMap( digestedSchema:ObjectSchema.DigestedObjectSchema ):Map<string, string> {\n\t\tlet map:Map<string, string> = new Map<string, string>();\n\t\tdigestedSchema.properties.forEach( ( definition:ObjectSchema.DigestedPropertyDefinition, propertyName:string ):void => {\n\t\t\tmap.set( definition.uri.toString(), propertyName );\n\t\t});\n\t\treturn map;\n\t}\n\n\tprivate parseValue( propertyValue:RDF.Value.Class, pointerLibrary:Pointer.Library ):any {\n\t\tif( RDF.Literal.Factory.is( propertyValue ) ) {\n\t\t\treturn RDF.Literal.Factory.parse( <any> propertyValue );\n\t\t} else if( RDF.Node.Factory.is( propertyValue ) ) {\n\t\t\treturn pointerLibrary.getPointer( propertyValue[ \"@id\" ] );\n\t\t} else if( RDF.List.Factory.is( propertyValue ) ) {\n\t\t\tlet parsedValue:Array<any> = [];\n\t\t\tlet listValues:Array<any> = propertyValue[ \"@list\" ];\n\t\t\tfor( let listValue of listValues ) {\n\t\t\t\tparsedValue.push( this.parseValue( listValue, pointerLibrary ) );\n\t\t\t}\n\t\t\treturn parsedValue;\n\t\t} else {\n\t\t\t// TODO: What else could it be?\n\t\t}\n\t}\n}\n\nexport default Class;\n"],"sourceRoot":"/source/"}