{"version":3,"sources":["PersistedFragment.ts"],"names":["Factory","Factory.constructor","Factory.hasClassProperties","Factory.from","Factory.singleFrom","Factory.injectBehavior"],"mappings":"AAEA,IAAY,iBAAiB,WAAM,qBAAqB,CAAC,CAAA;AAEzD,IAAY,KAAK,WAAM,SAAS,CAAC,CAAA;AAMjC;IAAAA;IAiCAC,CAACA;IAhCOD,0BAAkBA,GAAzBA,UAA2BA,QAAuBA;QACjDE,MAAMA,CAACA,CACNA,IAAIA,CACJA,CAACA;IACHA,CAACA;IAIMF,YAAIA,GAAXA,UAAaA,SAAaA;QACzBG,EAAEA,CAAAA,CAAEA,CAAEA,KAAKA,CAACA,OAAOA,CAAEA,SAASA,CAAGA,CAACA;YAACA,MAAMA,CAACA,OAAOA,CAACA,UAAUA,CAAmBA,SAASA,CAAEA,CAACA;QAE3FA,IAAIA,kBAAkBA,GAAWA,EAAEA,CAACA;QACpCA,GAAGA,CAACA,CAAEA,GAAGA,CAACA,CAACA,GAAUA,CAACA,EAAEA,QAAMA,GAAUA,SAASA,CAACA,MAAMA,EAAEA,CAACA,GAAGA,QAAMA,EAAEA,CAACA,EAAGA,EAAGA,CAACA;YAC7EA,IAAIA,QAAQA,GAAkBA,SAASA,CAAEA,CAACA,CAAEA,CAACA;YAE7CA,kBAAkBA,CAACA,IAAIA,CAAEA,OAAOA,CAACA,UAAUA,CAAEA,QAAQA,CAAEA,CAAEA,CAACA;QAC3DA,CAACA;QAEDA,MAAMA,CAACA,kBAAkBA,CAACA;IAC3BA,CAACA;IAEgBH,kBAAUA,GAA3BA,UAA6BA,QAAuBA;QACnDI,IAAIA,SAASA,GAAgDA,iBAAiBA,CAACA,OAAOA,CAACA,IAAIA,CAAkBA,QAAQA,CAAEA,CAACA;QAExHA,MAAMA,CAACA,OAAOA,CAACA,kBAAkBA,CAAEA,QAAQA,CAAEA,GAASA,SAASA,GAAGA,OAAOA,CAACA,cAAcA,CAAEA,SAASA,CAAEA,CAACA;IACvGA,CAACA;IAEgBJ,sBAAcA,GAA/BA,UAAiCA,SAAsDA;QACtFK,EAAEA,CAAAA,CAAEA,OAAOA,CAACA,kBAAkBA,CAAEA,SAASA,CAAGA,CAACA;YAACA,MAAMA,CAAOA,SAASA,CAACA;QAErEA,MAAMA,CAAOA,SAASA,CAACA;IACxBA,CAACA;IACFL,cAACA;AAADA,CAjCA,AAiCCA,IAAA;AAjCY,eAAO,UAiCnB,CAAA","file":"PersistedFragment.js","sourcesContent":["import * as Fragment from \"./Fragment\";\nimport * as Errors from \"./Errors\";\nimport * as PersistedResource from \"./PersistedResource\";\nimport * as RDF from \"./RDF\";\nimport * as Utils from \"./Utils\";\n\nexport interface Class extends PersistedResource.Class, Fragment.Class {\n\n}\n\nexport class Factory {\n\tstatic hasClassProperties( fragment:Fragment.Class ):boolean {\n\t\treturn (\n\t\t\ttrue\n\t\t);\n\t}\n\n\tstatic from( fragments:Fragment.Class[] ):Class[];\n\tstatic from( fragment:Fragment.Class ):Class;\n\tstatic from( fragments:any ):any {\n\t\tif( ! Utils.isArray( fragments ) ) return Factory.singleFrom( <Fragment.Class> fragments );\n\n\t\tlet persistedFragments:Class[] = [];\n\t\tfor ( let i:number = 0, length:number = fragments.length; i < length; i ++ ) {\n\t\t\tlet fragment:Fragment.Class = fragments[ i ];\n\n\t\t\tpersistedFragments.push( Factory.singleFrom( fragment ) );\n\t\t}\n\n\t\treturn persistedFragments;\n\t}\n\n\tprotected static singleFrom( fragment:Fragment.Class ):Class {\n\t\tlet persisted:( Fragment.Class & PersistedResource.Class ) = PersistedResource.Factory.from<Fragment.Class>( fragment );\n\n\t\treturn Factory.hasClassProperties( fragment ) ? <any> persisted : Factory.injectBehavior( persisted );\n\t}\n\n\tprotected static injectBehavior( persisted:( Fragment.Class & PersistedResource.Class ) ):Class {\n\t\tif( Factory.hasClassProperties( persisted ) ) return <any> persisted;\n\n\t\treturn <any> persisted;\n\t}\n}\n\nexport default Class;\n"],"sourceRoot":"/source/"}