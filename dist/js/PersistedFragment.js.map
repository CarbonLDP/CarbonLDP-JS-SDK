{"version":3,"sources":["PersistedFragment.ts"],"names":["Factory","Factory.constructor","Factory.hasClassProperties"],"mappings":";;;;;YAUA;gBAAAA;gBAqCAC,CAACA;gBApCOD,0BAAkBA,GAAzBA,UAA2BA,QAAuBA;oBACjDE,MAAMA,CAACA,CACNA,IAAIA,CACJA,CAACA;gBACHA,CAACA;gBAgCFF,cAACA;YAADA,CArCA,AAqCCA,IAAA;YArCD,6BAqCC,CAAA","file":"PersistedFragment.js","sourcesContent":["import * as Fragment from \"./Fragment\";\nimport * as Errors from \"./Errors\";\nimport * as PersistedResource from \"./PersistedResource\";\nimport * as RDF from \"./RDF\";\nimport * as Utils from \"./Utils\";\n\nexport interface Class extends PersistedResource.Class, Fragment.Class {\n\n}\n\nexport class Factory {\n\tstatic hasClassProperties( fragment:Fragment.Class ):boolean {\n\t\treturn (\n\t\t\ttrue\n\t\t);\n\t}\n\n\t/*\n\n\tstatic from( fragments:Fragment.Class[] ):Class[];\n\tstatic from( fragment:Fragment.Class ):Class;\n\tstatic from( fragments:any ):any {\n\t\tif( ! Utils.isArray( fragments ) ) return Factory.singleFrom( <Fragment.Class> fragments );\n\n\t\tlet persistedFragments:Class[] = [];\n\t\tfor ( let i:number = 0, length:number = fragments.length; i < length; i ++ ) {\n\t\t\tlet fragment:Fragment.Class = fragments[ i ];\n\n\t\t\tpersistedFragments.push( Factory.singleFrom( fragment ) );\n\t\t}\n\n\t\treturn persistedFragments;\n\t}\n\n\tprotected static singleFrom( fragment:Fragment.Class ):Class {\n\t\tlet persisted:( Fragment.Class & PersistedResource.Class ) = PersistedResource.Factory.from<Fragment.Class>( fragment );\n\n\t\treturn Factory.hasClassProperties( fragment ) ? <any> persisted : Factory.injectBehavior( persisted );\n\t}\n\n\tprotected static injectBehavior( persisted:( Fragment.Class & PersistedResource.Class ) ):Class {\n\t\tif( Factory.hasClassProperties( persisted ) ) return <any> persisted;\n\n\t\treturn <any> persisted;\n\t}\n\n\t*/\n}\n\nexport default Class;\n"],"sourceRoot":"/source/"}