{"version":3,"sources":["Resources.ts"],"names":[],"mappings":"AAAA,gEAAgE;AAChE,4DAA4D;AAC5D,kDAAkD;AAElD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsHE","file":"Resources.js","sourcesContent":["/// <reference path=\"../typings/es6-promise/es6-promise.d.ts\" />\n/// <reference path=\"../typings/jsonld.js/jsonld.js.d.ts\" />\n/// <amd-dependency path=\"jsonld\" name=\"jsonld\" />\n\n/*\n\n\tdeclare var jsonld;\n\n\t//@formatter:off\n\timport * as HTTP from './HTTP';\n\timport Documents from './Documents';\n\timport Committer from './Committer';\n\timport Parent from './Parent';\n\timport * as RDF from './RDF';\n\timport * as Utils from './Utils';\n\timport * as RDFSource from './LDP/RDFSource';\n\timport * as LDP from './NS/LDP';\n\t//@formatter:on\n\n\tenum InteractionModel {\n\t\tRDFSource,\n\t\tContainer\n\t}\n\n\tfunction setPreferredInteractionModel( interactionModel:InteractionModel, requestOptions:HTTP.Request.Options ) {\n\t\tvar headers = requestOptions.headers ? requestOptions.headers : requestOptions.headers = new Map<string, HTTP.Header.Class>();\n\t\tif ( ! headers.has( \"Prefer\" ) ) headers.set( \"Prefer\", new HTTP.Header.Class() );\n\t\tvar prefer:HTTP.Header.Class = headers.get( \"Prefer\" );\n\t\tprefer.values.push( new HTTP.Header.Value( LDP.Class.RDFSource + \"; rel=interaction-model\" ) );\n\t}\n\n\tclass Resources implements Committer {\n\t\tprivate parent:Parent;\n\n\t\tconstructor( parent:Parent ) {\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tget( uri:string ):Promise<HTTP.ProcessedResponse<RDF.PersistedDocumentResource.Class>> {\n\t\t\treturn null;\n\n\t\t\t\tvar requestOptions:HTTP.Request.Options = {};\n\t\t\t\tif ( this.parent && this.parent.Auth.isAuthenticated() ) this.parent.Auth.addAuthentication( requestOptions );\n\n\t\t\t\tsetPreferredInteractionModel( InteractionModel.RDFSource, requestOptions );\n\n\t\t\t\treturn this.parent.Documents.get( uri, requestOptions ).then(\n\t\t\t\t\t( processedResponse:HTTP.ProcessedResponse<RDF.Document.Class[]> ) => {\n\n\t\t\t\t\t\tvar document:RDF.Document.Class = Resources.getDocument( processedResponse );\n\n\t\t\t\t\t\tvar nodes:RDF.Node.Class[] = RDF.Document.Util.getResources( document );\n\t\t\t\t\t\tvar resources:RDF.Resource.Class[] = <RDF.Resource.Class[]> RDF.Resource.factory.from( nodes );\n\n\t\t\t\t\t\tthis.injectDefinitions( resources );\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tresult: document,\n\t\t\t\t\t\t\tresponse: processedResponse.response\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t).then(\n\t\t\t\t\t( processedResponse:HTTP.ProcessedResponse<RDF.Document.Class> ) => {\n\t\t\t\t\t\tlet document:RDF.Document.Class = processedResponse.result;\n\t\t\t\t\t\tlet documentResourceNode:RDF.Node.Class = Resources.getDocumentResourceNode( document );\n\t\t\t\t\t\tlet fragmentNodes:RDF.Node.Class[] = RDF.Document.Util.getFragmentResources( document, documentResourceNode );\n\t\t\t\t\t\tlet documentResource:RDF.DocumentResource.Class = RDF.DocumentResource.factory.from( documentResourceNode, fragmentNodes );\n\n\t\t\t\t\t\tlet persistedDocumentResource:RDF.PersistedDocumentResource.Class = RDF.PersistedDocumentResource.Factory.from( documentResource, this );\n\n\t\t\t\t\t\t// TODO: Inject registered definitions\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tresult: persistedDocumentResource,\n\t\t\t\t\t\t\tresponse: processedResponse.response\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t}\n\n\t\tcommit( object:any = null ):Promise<HTTP.Response> {\n\t\t\t// TODO: Implement\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate static getDocument( processedResponse:HTTP.ProcessedResponse<RDF.Document.Class[]> ):RDF.Document.Class {\n\t\t\tvar documents:RDF.Document.Class[] = processedResponse.result;\n\t\t\tif ( documents.length === 0 ) throw new Error( 'BadResponse: No document was returned.' );\n\t\t\tif ( documents.length > 1 ) throw new Error( 'Unsupported: Multiple graphs are currently not supported.' );\n\t\t\treturn documents[ 0 ];\n\t\t}\n\n\t\tprivate static getDocumentResourceNode( document:RDF.Document.Class ):RDF.Node.Class {\n\t\t\tlet documentResourceNodes:RDF.Node.Class[] = RDF.Document.Util.getDocumentResources( document );\n\n\t\t\t// TODO: Use specific Error classes\n\t\t\tif ( documentResourceNodes.length === 0 ) throw new Error( 'BadResponse: No document resource was returned.' );\n\t\t\tif ( documentResourceNodes.length > 1 ) throw new Error( 'NotSupported: Multiple document resources were returned.' );\n\n\t\t\treturn documentResourceNodes[ 0 ];\n\t\t}\n\n\t\tprivate injectDefinitions( resources:RDF.Resource.Class[] ):RDF.Resource.Class[] {\n\t\t\tlet definitionURIs:string[] = this.parent.getDefinitionURIs();\n\n\t\t\tfor ( let i:number = 0, length:number = definitionURIs.length; i < length; i ++ ) {\n\t\t\t\tlet definitionURI:string = definitionURIs[ i ];\n\t\t\t\tlet toInject:RDF.Resource.Class[] = [];\n\t\t\t\tfor ( let j:number = 0, resourcesLength:number = resources.length; j < resourcesLength; j ++ ) {\n\t\t\t\t\tlet resource:RDF.Resource.Class = resources[ j ];\n\t\t\t\t\tif ( resource.types.indexOf( definitionURI ) !== - 1 ) toInject.push( resource );\n\t\t\t\t}\n\t\t\t\tif ( toInject.length > 0 ) RDF.Resource.Factory.injectDescriptions( toInject, this.parent.getDefinition( definitionURI ) );\n\t\t\t}\n\n\t\t\treturn resources;\n\t\t}\n\n\t}\n\n\texport default Resources;\n\n*/"],"sourceRoot":"/source/"}