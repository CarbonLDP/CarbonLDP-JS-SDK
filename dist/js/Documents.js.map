{"version":3,"sources":["Documents.ts"],"names":["Documents","Documents.get","Documents.getDigestedObjectSchema"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBAsDcA,gEAAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BA2DdA,uEAAsCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;qDA+CvBC;;;;;;;;;;;;;;;;;;;;;;;;;sDAKKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BAemBD,sFAAoCA;4BAAIA,uEAAsCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BAsCrFA,uEAAsCA;;;;;;;;;;;;;;4BAsBpCA,uEAAsCA;;;;;;;;;;;;;;;;;;;4BAkB7BA,uEAAsCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDA8F/EE","file":"Documents.js","sourcesContent":["/// <reference path=\"../typings/typings.d.ts\" />\n\nimport * as jsonld from \"jsonld\";\n\nimport Committer from \"./Committer\";\nimport * as Errors from \"./Errors\";\nimport * as HTTP from \"./HTTP\";\nimport Context from \"./Context\";\nimport * as RDF from \"./RDF\";\nimport * as Utils from \"./Utils\";\n\nimport * as Document from \"./Document\";\nimport * as Fragment from \"./Fragment\";\nimport * as JSONLDConverter from \"./JSONLDConverter\";\nimport * as PersistedDocument from \"./PersistedDocument\";\nimport * as Pointer from \"./Pointer\";\nimport * as NamedFragment from \"./NamedFragment\";\nimport * as NS from \"./NS\";\nimport * as ObjectSchema from \"./ObjectSchema\";\nimport * as LDP from \"./NS/LDP\";\nimport * as Resource from \"./Resource\";\nimport * as SPARQL from \"./SPARQL\";\n\nfunction parse( input:string ):any {\n\ttry {\n\t\treturn JSON.parse( input );\n\t} catch ( error ) {\n\t\t// TODO: Handle SyntaxError\n\t\tthrow error;\n\t}\n}\n\nfunction expand( [ result, response ]:[ Object, HTTP.Response.Class ], options?:jsonld.ExpandOptions ):Promise<[ Object, HTTP.Response.Class ]> {\n\treturn new Promise( ( resolve:( result:Object ) => void, reject:( error:any ) => void ) => {\n\t\tjsonld.expand( result, options, function ( error:any, expanded:Object ):void {\n\t\t\tif ( error ) {\n\t\t\t\t// TODO: Handle jsonld.expand error\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tresult = expanded;\n\t\t\tresolve( [ result, response ] );\n\t\t} );\n\t} );\n}\n\nclass Documents implements Pointer.Library, Pointer.Validator, ObjectSchema.Resolver {\n\t_jsonldConverter:JSONLDConverter.Class;\n\n\tget jsonldConverter():JSONLDConverter.Class { return this._jsonldConverter; }\n\n\tprivate context:Context;\n\tprivate pointers:Map<string, Pointer.Class>;\n\n\tconstructor( context:Context = null ) {\n\t\tthis.context = context;\n\n\t\tthis.pointers = new Map<string, Pointer.Class>();\n\n\t\tif( !! this.context && !! this.context.parentContext ) {\n\t\t\tlet contextJSONLDConverter:JSONLDConverter.Class = this.context.parentContext.Documents.jsonldConverter;\n\t\t\tthis._jsonldConverter = new JSONLDConverter.Class( contextJSONLDConverter.literalSerializers );\n\t\t} else {\n\t\t\tthis._jsonldConverter = new JSONLDConverter.Class();\n\t\t}\n\t}\n\n\tinScope( pointer:Pointer.Class ):boolean;\n\tinScope( id:string ):boolean;\n\tinScope( idOrPointer:any ):boolean {\n\t\tlet id:string = Pointer.Factory.is( idOrPointer ) ? idOrPointer.id : idOrPointer;\n\n\t\tif( RDF.URI.Util.isBNodeID( id ) ) return false;\n\n\t\tif( !! this.context ) {\n\t\t\tlet baseURI:string = this.context.getBaseURI();\n\t\t\tif( RDF.URI.Util.isAbsolute( id ) && RDF.URI.Util.isBaseOf( baseURI, id ) ) return true;\n\t\t} else {\n\t\t\tif( RDF.URI.Util.isAbsolute( id ) ) return true;\n\t\t}\n\n\t\tif( !! this.context && !! this.context.parentContext ) return this.context.parentContext.Documents.inScope( id );\n\n\t\treturn false;\n\t}\n\n\thasPointer( id:string ):boolean {\n\t\tid = this.getPointerID( id );\n\n\t\tif( this.pointers.has( id ) ) return true;\n\n\t\tif( !! this.context && !! this.context.parentContext ) return this.context.parentContext.Documents.hasPointer( id );\n\n\t\treturn false;\n\t}\n\n\tgetPointer( id:string ):Pointer.Class {\n\t\tlet localID:string = this.getPointerID( id );\n\n\t\tif( ! localID ) {\n\t\t\tif( !! this.context && !! this.context.parentContext ) return this.context.parentContext.Documents.getPointer( id );\n\t\t\tthrow new Errors.IllegalArgumentError( \"The pointer id is not supported by this module.\" );\n\t\t}\n\n\t\tlet pointer:Pointer.Class;\n\t\tif( ! this.pointers.has( localID ) ) {\n\t\t\tpointer = this.createPointer( localID );\n\t\t\tthis.pointers.set( localID, pointer );\n\t\t}\n\n\t\treturn this.pointers.get( localID );\n\t}\n\n\tget( uri:string, requestOptions:HTTP.Request.Options = {} ):Promise<[ PersistedDocument.Class, HTTP.Response.Class ]> {\n\t\tlet pointerID:string = this.getPointerID( uri );\n\t\tif( !! this.context ) uri = this.context.resolve( uri );\n\n\t\tif( this.pointers.has( pointerID ) ) {\n\t\t\tlet pointer:Pointer.Class = this.getPointer( uri );\n\t\t\tif( pointer.isResolved() ) {\n\t\t\t\treturn new Promise( ( resolve:( result:[ PersistedDocument.Class, HTTP.Response.Class ]) => void, reject:( error:Error ) => void ) => {\n\t\t\t\t\tresolve( [ <any> pointer, null ] );\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tif ( this.context && this.context.Auth.isAuthenticated() ) this.context.Auth.addAuthentication( requestOptions );\n\n\t\tHTTP.Request.Util.setAcceptHeader( \"application/ld+json\", requestOptions );\n\t\tHTTP.Request.Util.setPreferredInteractionModel( LDP.Class.RDFSource, requestOptions );\n\n\t\treturn HTTP.Request.Service.get( uri, requestOptions ).then(\n\t\t\t( response:HTTP.Response.Class ) => {\n\t\t\t\tlet parsedObject:Object = parse( response.data );\n\n\t\t\t\treturn expand( [ parsedObject, response ] );\n\t\t\t}\n\t\t).then(\n\t\t\t( [ expandedResult, response ]:[ Object, HTTP.Response.Class ] ) => {\n\t\t\t\tlet etag:string = HTTP.Response.Util.getETag( response );\n\t\t\t\tif( etag === null ) throw new HTTP.Errors.BadResponseError( \"The response doesn't contain an ETag\", response );\n\n\t\t\t\tlet rdfDocuments:RDF.Document.Class[] = RDF.Document.Util.getDocuments( expandedResult );\n\t\t\t\tlet rdfDocument:RDF.Document.Class = this.getRDFDocument( rdfDocuments, response );\n\n\t\t\t\tlet documentResources:RDF.Node.Class[] = RDF.Document.Util.getDocumentResources( rdfDocument );\n\t\t\t\tif( documentResources.length > 1 ) throw new HTTP.Errors.BadResponseError( \"The RDFDocument contains more than one document resource.\", response );\n\t\t\t\tif( documentResources.length === 0 ) throw new HTTP.Errors.BadResponseError( \"The RDFDocument doesn\\'t contain a document resource.\", response );\n\n\t\t\t\tlet documentResource:RDF.Node.Class = documentResources[ 0 ];\n\t\t\t\tlet fragmentResources:RDF.Node.Class[] = RDF.Document.Util.getBNodeResources( rdfDocument );\n\t\t\t\tlet namedFragmentResources:RDF.Node.Class[] = RDF.Document.Util.getFragmentResources( rdfDocument );\n\n\t\t\t\tlet documentPointer:Pointer.Class = this.getPointer( uri );\n\t\t\t\tdocumentPointer._resolved = true;\n\n\t\t\t\tlet document:PersistedDocument.Class = PersistedDocument.Factory.createFrom( documentPointer, uri, this );\n\t\t\t\tdocument._etag = etag;\n\n\t\t\t\tlet fragments:Fragment.Class[] = [];\n\t\t\t\tfor( let fragmentResource of fragmentResources ) {\n\t\t\t\t\tfragments.push( document.createFragment( fragmentResource[ \"@id\" ] ) );\n\t\t\t\t}\n\n\t\t\t\tlet namedFragments:NamedFragment.Class[] = [];\n\t\t\t\tfor( let namedFragmentResource of namedFragmentResources ) {\n\t\t\t\t\tnamedFragments.push( document.createNamedFragment( namedFragmentResource[ \"@id\" ] ) );\n\t\t\t\t}\n\n\t\t\t\tthis.compact( documentResource, document, document );\n\t\t\t\tthis.compact( fragmentResources, fragments, document );\n\t\t\t\tthis.compact( namedFragmentResources, namedFragments, document );\n\n\t\t\t\t// TODO: Decorate additional behavior (container, app, etc.)\n\t\t\t\treturn [ document, response ];\n\t\t\t}\n\t\t);\n\t}\n\tcreateChild( parentURI:string, slug:string, childDocument:Document.Class, requestOptions?:HTTP.Request.Options ):Promise<[ Pointer.Class, HTTP.Response.Class ]>;\n\tcreateChild( parentURI:string, childDocument:Document.Class, requestOptions?:HTTP.Request.Options ):Promise<[ Pointer.Class, HTTP.Response.Class ]>;\n\tcreateChild( parentURI:string, slugOrChildDocument:any, childDocumentOrRequestOptions:any = {}, requestOptions:HTTP.Request.Options = {} ):Promise<[ Pointer.Class, HTTP.Response.Class ]> {\n\t\tlet slug:string = Utils.isString( slugOrChildDocument ) ? slugOrChildDocument : null;\n\t\tlet childDocument:Document.Class = ! Utils.isString( slugOrChildDocument ) ? slugOrChildDocument : childDocumentOrRequestOptions;\n\t\trequestOptions = ! Utils.isString( slugOrChildDocument ) ? childDocumentOrRequestOptions : requestOptions;\n\n\t\tif( PersistedDocument.Factory.is( childDocument ) ) return Utils.P.createRejectedPromise( new Errors.IllegalArgumentError( \"The childDocument provided has been already persisted.\" ) );\n\n\t\tif( childDocument.id ) {\n\t\t\tif( ! RDF.URI.Util.isBaseOf( parentURI, childDocument.id ) ) return Utils.P.createRejectedPromise( new Errors.IllegalArgumentError( \"The childDocument's URI is not relative to the parentURI specified\" ) );\n\t\t}\n\n\t\tif ( this.context && this.context.Auth.isAuthenticated() ) this.context.Auth.addAuthentication( requestOptions );\n\n\t\tHTTP.Request.Util.setAcceptHeader( \"application/ld+json\", requestOptions );\n\t\tHTTP.Request.Util.setContentTypeHeader( \"application/ld+json\", requestOptions );\n\t\tHTTP.Request.Util.setPreferredInteractionModel( LDP.Class.Container, requestOptions );\n\n\t\tif( slug !== null ) HTTP.Request.Util.setSlug( slug, requestOptions );\n\n\t\tlet body:string = childDocument.toJSON( this, this.jsonldConverter );\n\n\t\treturn HTTP.Request.Service.post( parentURI, body, requestOptions ).then(\n\t\t\t( response:HTTP.Response.Class ) => {\n\t\t\t\tlet locationHeader:HTTP.Header.Class = response.headers.get( \"Location\" );\n\t\t\t\tif( locationHeader === null || locationHeader.values.length < 1 ) throw new HTTP.Errors.BadResponseError( \"The response is missing a Location header.\", response );\n\t\t\t\tif( locationHeader.values.length !== 1 ) throw new HTTP.Errors.BadResponseError( \"The response contains more than one Location header.\", response );\n\n\t\t\t\tlet locationURI:string = locationHeader.values[0].toString();\n\t\t\t\tlet pointer:Pointer.Class = this.getPointer( locationURI);\n\n\t\t\t\treturn [\n\t\t\t\t\tpointer,\n\t\t\t\t\tresponse,\n\t\t\t\t];\n\t\t\t}\n\t\t);\n\t}\n\n\tsave( persistedDocument:PersistedDocument.Class, requestOptions:HTTP.Request.Options = {} ):Promise<[ PersistedDocument.Class, HTTP.Response.Class ]> {\n\t\t// TODO: Check if the document isDirty\n\t\t/*\n\t\tif( ! persistedDocument.isDirty() ) return new Promise<HTTP.Response.Class>( ( resolve:( result:HTTP.Response.Class ) => void ) => {\n\t\t\tresolve( null );\n\t\t});\n\t\t*/\n\n\t\tif ( this.context && this.context.Auth.isAuthenticated() ) this.context.Auth.addAuthentication( requestOptions );\n\n\t\tHTTP.Request.Util.setAcceptHeader( \"application/ld+json\", requestOptions );\n\t\tHTTP.Request.Util.setContentTypeHeader( \"application/ld+json\", requestOptions );\n\t\tHTTP.Request.Util.setPreferredInteractionModel( LDP.Class.RDFSource, requestOptions );\n\t\tHTTP.Request.Util.setIfMatchHeader( persistedDocument._etag, requestOptions );\n\n\t\tlet body:string = persistedDocument.toJSON( this, this.jsonldConverter );\n\n\t\treturn HTTP.Request.Service.put( persistedDocument.id, body, requestOptions ).then( ( response:HTTP.Response.Class ) => {\n\t\t\treturn [ persistedDocument, response ];\n\t\t});\n\t}\n\n\tdelete( persistedDocument:PersistedDocument.Class, requestOptions:HTTP.Request.Options = {} ):Promise<HTTP.Response.Class> {\n\t\tif ( this.context && this.context.Auth.isAuthenticated() ) this.context.Auth.addAuthentication( requestOptions );\n\n\t\tHTTP.Request.Util.setAcceptHeader( \"application/ld+json\", requestOptions );\n\t\tHTTP.Request.Util.setPreferredInteractionModel( LDP.Class.RDFSource, requestOptions );\n\t\tHTTP.Request.Util.setIfMatchHeader( persistedDocument._etag, requestOptions );\n\n\t\treturn HTTP.Request.Service.delete( persistedDocument.id, persistedDocument.toJSON(), requestOptions );\n\t}\n\n\tgetSchemaFor( object:Object ):ObjectSchema.DigestedObjectSchema {\n\t\tif( \"@id\" in object ) {\n\t\t\treturn this.getDigestedObjectSchemaForExpandedObject( object );\n\t\t} else {\n\t\t\treturn this.getDigestedObjectSchemaForDocument( <any> object );\n\t\t}\n\t}\n\n\texecuteSELECTQuery( documentURI:string, selectQuery:string, requestOptions:HTTP.Request.Options = {} ):Promise<[ SPARQL.Results.Class, HTTP.Response.Class ]> {\n\t\tif( ! RDF.URI.Util.isAbsolute( documentURI ) ) {\n\t\t\tif( ! this.context ) throw new Errors.IllegalArgumentError( \"This Documents instance doesn't support relative URIs.\" );\n\t\t\tdocumentURI = this.context.resolve( documentURI );\n\t\t}\n\n\t\tif ( this.context && this.context.Auth.isAuthenticated() ) this.context.Auth.addAuthentication( requestOptions );\n\n\t\treturn SPARQL.Service.executeSELECTQuery( documentURI, selectQuery, requestOptions );\n\t}\n\n\tprivate getRDFDocument( rdfDocuments:RDF.Document.Class[], response:HTTP.Response.Class ):RDF.Document.Class {\n\t\tif ( rdfDocuments.length === 0 ) throw new HTTP.Errors.BadResponseError( \"No document was returned.\", response );\n\t\tif ( rdfDocuments.length > 1 ) throw new Error( \"Unsupported: Multiple graphs are currently not supported.\" );\n\t\treturn rdfDocuments[ 0 ];\n\t}\n\n\tprivate getPointerID( uri:string ):string {\n\t\tif( RDF.URI.Util.isBNodeID( uri ) ) throw new Errors.IllegalArgumentError( \"BNodes cannot be fetched directly.\" );\n\t\t// TODO: Make named fragments independently resolvable\n\t\t/*\n\t\t\tif( RDF.URI.Util.hasFragment( uri ) ) throw new Errors.IllegalArgumentError( \"Fragment URI's cannot be fetched directly.\" );\n\t\t*/\n\n\t\tif( !! this.context ) {\n\t\t\t// TODO: Check this, it may be incorrect\n\t\t\tif( RDF.URI.Util.isRelative( uri ) ) {\n\t\t\t\tlet baseURI:string = this.context.getBaseURI();\n\t\t\t\tif( ! RDF.URI.Util.isBaseOf( baseURI, uri ) ) return null;\n\n\t\t\t\treturn uri.substring( baseURI.length );\n\t\t\t} else {\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t} else {\n\t\t\tif( RDF.URI.Util.isRelative( uri ) ) throw new Errors.IllegalArgumentError( \"This Documents instance doesn't support relative URIs.\" );\n\t\t\treturn uri;\n\t\t}\n\t}\n\n\tprivate createPointer( localID:string ):Pointer.Class {\n\t\tlet id:string = !! this.context ? this.context.resolve( localID ) : localID;\n\t\tlet pointer:Pointer.Class = Pointer.Factory.create( id );\n\t\tObject.defineProperty( pointer, \"resolve\", {\n\t\t\twritable: false,\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true,\n\t\t\tvalue: ():Promise<[ PersistedDocument.Class, HTTP.Response.Class ]> => {\n\t\t\t\treturn this.get( id );\n\t\t\t},\n\t\t});\n\n\t\treturn pointer;\n\t}\n\n\tprivate compact( expandedObjects:Object[], targetObjects:Object[], pointerLibrary:Pointer.Library ):Object[];\n\tprivate compact( expandedObject:Object, targetObject:Object, pointerLibrary:Pointer.Library ):Object;\n\tprivate compact( expandedObjectOrObjects:any, targetObjectOrObjects:any, pointerLibrary:Pointer.Library ):any {\n\t\tif( ! Utils.isArray( expandedObjectOrObjects ) ) return this.compactSingle( expandedObjectOrObjects, targetObjectOrObjects, pointerLibrary );\n\n\t\tlet expandedObjects:Object[] = expandedObjectOrObjects;\n\t\tlet targetObjects:Object[] = !! targetObjectOrObjects ? targetObjectOrObjects : [];\n\t\tfor( let i:number = 0, length:number = expandedObjects.length; i < length; i++ ) {\n\t\t\tlet expandedObject:Object = expandedObjects[ i ];\n\t\t\tlet targetObject:Object = targetObjects[ i ] = !! targetObjects[ i ] ? targetObjects[ i ] : {};\n\n\t\t\tthis.compactSingle( expandedObject, targetObject, pointerLibrary );\n\t\t}\n\n\t\treturn targetObjects;\n\t}\n\n\tprivate compactSingle( expandedObject:Object, targetObject:Object, pointerLibrary:Pointer.Library ):Object {\n\t\tlet digestedSchema:ObjectSchema.DigestedObjectSchema = this.getDigestedObjectSchemaForExpandedObject( expandedObject );\n\n\t\treturn this.jsonldConverter.compact( expandedObject, targetObject, digestedSchema, pointerLibrary );\n\t}\n\n\tprivate getDigestedObjectSchemaForExpandedObject( expandedObject:Object ):ObjectSchema.DigestedObjectSchema {\n\t\tlet types:string[] = this.getExpandedObjectTypes( expandedObject );\n\n\t\treturn this.getDigestedObjectSchema( types );\n\t}\n\n\tprivate getDigestedObjectSchemaForDocument( document:Document.Class ):ObjectSchema.DigestedObjectSchema {\n\t\tlet types:string[] = this.getDocumentTypes( document );\n\n\t\treturn this.getDigestedObjectSchema( types );\n\t}\n\n\tprivate getDigestedObjectSchema( objectTypes:string[] ):ObjectSchema.DigestedObjectSchema {\n\t\tlet digestedSchema:ObjectSchema.DigestedObjectSchema;\n\t\tif( !! this.context ) {\n\t\t\tlet typesDigestedObjectSchemas:ObjectSchema.DigestedObjectSchema[] = [ this.context.getObjectSchema() ];\n\t\t\tfor( let type of objectTypes ) {\n\t\t\t\tif( this.context.getObjectSchema( type ) ) typesDigestedObjectSchemas.push( this.context.getObjectSchema( type ) );\n\t\t\t}\n\n\t\t\tif( typesDigestedObjectSchemas.length > 1 ) {\n\t\t\t\tdigestedSchema = ObjectSchema.Digester.combineDigestedObjectSchemas( typesDigestedObjectSchemas );\n\t\t\t} else {\n\t\t\t\tdigestedSchema = typesDigestedObjectSchemas[ 0 ];\n\t\t\t}\n\t\t} else {\n\t\t\tdigestedSchema = new ObjectSchema.DigestedObjectSchema();\n\t\t}\n\n\t\treturn digestedSchema;\n\t}\n\n\tprivate getExpandedObjectTypes( expandedObject:Object ):string[] {\n\t\tif( ! expandedObject[ \"@type\" ] ) return [];\n\n\t\treturn expandedObject[ \"@type\" ];\n\t}\n\n\tprivate getDocumentTypes( document:Document.Class ):string[] {\n\t\tif( ! document.types ) return [];\n\t\treturn document.types;\n\t}\n}\n\nexport default Documents;\n"],"sourceRoot":"/source/"}