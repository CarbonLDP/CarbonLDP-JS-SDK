{"version":3,"sources":["Pointer.ts"],"names":["Util.getIDs"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDAmGsBA","file":"Pointer.js","sourcesContent":["import * as HTTP from \"./HTTP\";\nimport * as Utils from \"./Utils\";\n\nexport interface Class {\n\t_id:string;\n\t_resolved:boolean;\n\n\tid:string;\n\tisResolved():boolean;\n\tresolve():Promise<[ Class, HTTP.Response.Class ]>;\n}\n\nexport interface Library {\n\thasPointer( id:string ):boolean;\n\tgetPointer( id:string ):Class;\n}\n\nexport class Factory {\n\tstatic hasClassProperties( object:Object ):boolean {\n\t\treturn !! (\n\t\t\tUtils.hasPropertyDefined( object, \"_id\" ) &&\n\t\t\tUtils.hasPropertyDefined( object, \"_resolved\" ) &&\n\n\t\t\tUtils.hasPropertyDefined( object, \"id\" ) &&\n\t\t\tUtils.hasFunction( object, \"isResolved\" ) &&\n\t\t\tUtils.hasPropertyDefined( object, \"resolve\" )\n\t\t);\n\t}\n\n\tstatic is( value:any ):boolean {\n\t\treturn !! (\n\t\t\tUtils.isObject( value ) &&\n\t\t\tFactory.hasClassProperties( value )\n\t\t);\n\t}\n\n\tstatic create( id:string ):Class {\n\t\tid = !! id ? id : \"\";\n\n\t\tlet pointer:Class = Factory.decorate( {} );\n\t\tpointer.id = id;\n\n\t\treturn pointer;\n\t}\n\n\tstatic decorate<T extends Object>( object:T ):Class {\n\t\tif( Factory.hasClassProperties( object ) ) return <any> object;\n\n\t\tObject.defineProperties( object, {\n\t\t\t\"_id\": {\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: \"\",\n\t\t\t},\n\t\t\t\"_resolved\": {\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: false,\n\t\t\t},\n\t\t\t\"id\": {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function():string {\n\t\t\t\t\tif( ! this._id ) return \"\";\n\t\t\t\t\treturn this._id;\n\t\t\t\t},\n\t\t\t\tset: function( value:string ):void {\n\t\t\t\t\tthis._id = value;\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"isResolved\": {\n\t\t\t\twritable: false,\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function():boolean {\n\t\t\t\t\treturn this._resolved;\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"resolve\": {\n\t\t\t\twritable: false,\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function():Promise<void> {\n\t\t\t\t\treturn new Promise( ( resolve:( result:any ) => void, reject:( error:any ) => void ):any => {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t},\n\t\t} );\n\n\t\treturn <any> object;\n\t}\n}\n\nexport class Util {\n\tstatic getIDs( pointers:Class[] ):string[] {\n\t\tlet ids:string[] = [];\n\t\tfor( let pointer of pointers ) {\n\t\t\tids.push( pointer.id );\n\t\t}\n\t\treturn ids;\n\t}\n}\n\nexport interface Validator {\n\tinScope( id:string ):boolean;\n\tinScope( pointer:Class ):boolean;\n}\n\nexport default Class;\n"],"sourceRoot":"/source/"}