{"version":3,"sources":["test/JasmineExtender.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAqFqC,oEAAqB;;;;;;;;;;;;oBAUH,oEAAqB;;;;;;;;;;;;;oBAWpB,+DAAgB;oBAAM,mEAA2B;;;;;;;;;;;;;;oBAY7C,+DAAgB;;;;;;;;;;;;;;;;;;;;;;;;oBAsBlB,oEAAqB;;;;;;;;;;;;;;;;;;;oBAkB/C,+EAA6B;oBAAM,6EAAwC;;;;;;;;;;;;;;;;;;;;;oBA+BpD,wFAAsC;oBAAM,2EAAyB;oBAAM,gEAAuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA+BrG,oEAAqB;;;;;;;;;;;;;oBAkB3C,wFAAsC;oBAAM,2EAAyB;oBAAM,gEAAuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA4B1D,oEAAqB","file":"test/JasmineExtender.js","sourcesContent":["export interface SuiteDescriptor {\n\taccess?:string;\n\tsuiteType:string;\n\tname:string;\n\tdescription?:string;\n}\n\nexport interface SpecDescriptor {\n\taccess?:string;\n\tspecType:string;\n\tname?:string;\n\tdescription?:string;\n}\n\nexport interface InterfaceDescriptor {\n\tparent?:string;\n}\n\nexport interface InterfaceSuiteDescriptor extends SuiteDescriptor, InterfaceDescriptor {\n\n}\n\nexport interface InterfaceSpecDescriptor extends SpecDescriptor, InterfaceDescriptor {\n\n}\n\nexport interface ClassDescriptor extends InterfaceDescriptor {\n\tinterfaces?:string[];\n}\n\nexport interface ClassSuiteDescriptor extends SuiteDescriptor, ClassDescriptor {\n}\n\nexport interface ClassSpecDescriptor extends SpecDescriptor, ClassDescriptor {\n}\n\nexport interface PropertyDescriptor extends SpecDescriptor {\n\ttype:string;\n}\n\nexport interface MethodDescriptor extends SpecDescriptor {\n\targuments?:MethodArgument[];\n\treturns?:MethodReturn;\n}\n\nexport interface MethodArgument {\n\tname:string;\n\ttype:string;\n\tdescription?:string;\n\toptional?:boolean;\n\tdefault?:string;\n}\n\nexport interface MethodReturn {\n\ttype:string;\n\tdescription?:string;\n}\n\nexport function serialize( descriptor:SuiteDescriptor ):string\nexport function serialize( descriptor:PropertyDescriptor ):string;\nexport function serialize( descriptor:MethodDescriptor ):string;\nexport function serialize( descriptor:any ):string {\n\treturn \"JSON\" + JSON.stringify( descriptor );\n}\n\n\nfunction toJSON( descriptor:any ):string {\n\treturn \"JSON\" + JSON.stringify( descriptor );\n}\n\nexport const MODULE:string = \"module\";\nexport const SUBMODULE:string = \"submodule\";\nexport const CLASS:string = \"class\";\nexport const INTERFACE:string = \"interface\";\n\n\nexport const STATIC:string = \"static\";\nexport const INSTANCE:string = \"instance\";\n\nexport const CONSTRUCTOR:string = \"constructor\";\nexport const METHOD:string = \"method\";\nexport const SIGNATURE:string = \"signature\";\nexport const PROPERTY:string = \"property\";\nexport const SUPER_CLASS:string = \"super-class\";\n\nexport function module( name:string, description:string = null ):string {\n\tlet descriptor:SuiteDescriptor = {\n\t\tsuiteType: MODULE,\n\t\tname: name,\n\t\tdescription: description,\n\t};\n\n\treturn toJSON( descriptor );\n}\n\nexport function submodule( access:string, name:string, description:string = null ):string {\n\tlet descriptor:SuiteDescriptor = {\n\t\tsuiteType: SUBMODULE,\n\t\taccess: access,\n\t\tname: name,\n\t\tdescription: description,\n\t};\n\n\treturn toJSON( descriptor );\n}\n\nexport function clazz( name:string, description:string, parent:string = null, interfaces:Array<string> = null ):string {\n\tlet descriptor:ClassSuiteDescriptor = {\n\t\tsuiteType: CLASS,\n\t\tname: name,\n\t\tdescription: description,\n\t\tparent: parent,\n\t\tinterfaces: interfaces,\n\t};\n\n\treturn toJSON( descriptor );\n}\n\nexport function interfaze( name:string, description:string, parent:string = null ):string {\n\tlet descriptor:InterfaceSuiteDescriptor = {\n\t\tsuiteType: INTERFACE,\n\t\tname: name,\n\t\tdescription: description,\n\t\tparent: parent,\n\t};\n\n\treturn toJSON( descriptor );\n}\n\nexport function constructor( name:string, description:string ):string {\n\tlet descriptor:SuiteDescriptor = {\n\t\tsuiteType: CONSTRUCTOR,\n\t\tname: name,\n\t\tdescription: description,\n\t};\n\n\treturn toJSON( descriptor );\n}\n\nexport function hasInterface( access:string, name:string ):string;\nexport function hasInterface( access:string, name:string, description:string = null ):string {\n\tlet descriptor:InterfaceSpecDescriptor = {\n\t\taccess: access,\n\t\tspecType: INTERFACE,\n\t\tname: name,\n\t\tdescription: description,\n\t};\n\n\treturn toJSON( descriptor );\n}\n\nexport function isDefined():string {\n\treturn \"is defined\";\n}\n\nexport function hasConstructor():string;\nexport function hasConstructor( constructorArguments:MethodArgument[] ):string;\nexport function hasConstructor( description:string, constructorArguments:MethodArgument[] ):string\nexport function hasConstructor( argumentsOrDescription:any = null, constructorArguments:MethodArgument[] = null ):string {\n\tlet description:string = null;\n\n\tif ( typeof argumentsOrDescription === \"string\" ) {\n\t\tdescription = argumentsOrDescription;\n\t} else if ( Object.prototype.toString.call( argumentsOrDescription ) === \"[object Array]\" ) {\n\t\tconstructorArguments = argumentsOrDescription;\n\t}\n\n\tlet descriptor:MethodDescriptor = {\n\t\taccess: STATIC,\n\t\tspecType: CONSTRUCTOR,\n\t\tdescription: description,\n\t\targuments: constructorArguments,\n\t};\n\n\treturn toJSON( descriptor );\n}\n\nexport function hasMethod( access:string, name:string ):string;\n\nexport function hasMethod( access:string, name:string, description:string ):string;\nexport function hasMethod( access:string, name:string, methodArguments:MethodArgument[] ):string;\nexport function hasMethod( access:string, name:string, returns:MethodReturn ):string;\n\nexport function hasMethod( access:string, name:string, description:string, methodArguments:MethodArgument[] ):string;\nexport function hasMethod( access:string, name:string, description:string, returns:MethodReturn ):string;\nexport function hasMethod( access:string, name:string, methodArguments:MethodArgument[], returns:MethodReturn ):string;\n\nexport function hasMethod( access:string, name:string, description:string, methodArguments:MethodArgument[], returns:MethodReturn ):string;\n\nexport function hasMethod( access:string, name:string, descriptionOrArgumentsOrReturns:any = null, argumentsOrReturns:any = null, returns:MethodReturn = null ):string {\n\tlet description:string = null, methodArguments:MethodArgument[] = [];\n\n\tif ( typeof descriptionOrArgumentsOrReturns === \"string\" ) {\n\t\tdescription = descriptionOrArgumentsOrReturns;\n\t} else if ( Object.prototype.toString.call( descriptionOrArgumentsOrReturns ) === \"[object Array]\" ) {\n\t\tmethodArguments = descriptionOrArgumentsOrReturns;\n\t} else if ( descriptionOrArgumentsOrReturns ) {\n\t\treturns = descriptionOrArgumentsOrReturns;\n\t}\n\n\tif ( Object.prototype.toString.call( argumentsOrReturns ) === \"[object Array]\" ) {\n\t\tmethodArguments = argumentsOrReturns;\n\t} else if ( argumentsOrReturns ) {\n\t\treturns = argumentsOrReturns;\n\t}\n\n\tlet descriptor:MethodDescriptor = {\n\t\taccess: access,\n\t\tspecType: METHOD,\n\t\tname: name,\n\t\tdescription: description,\n\t\targuments: methodArguments,\n\t\treturns: returns,\n\t};\n\n\treturn toJSON( descriptor );\n}\n\nexport function method( access:string, name:string ):string;\nexport function method( access:string, name:string, description:string ):string;\nexport function method( access:string, name:string, description:string = null ):string {\n\tlet descriptor:SuiteDescriptor = {\n\t\taccess: access,\n\t\tsuiteType: METHOD,\n\t\tname: name,\n\t\tdescription: description,\n\t};\n\n\treturn toJSON( descriptor );\n}\n\nexport function hasSignature():string;\nexport function hasSignature( description:string ):string;\nexport function hasSignature( description:string, methodArguments:MethodArgument[] ):string;\nexport function hasSignature( description:string, methodArguments:MethodArgument[], returns:MethodReturn ):string;\nexport function hasSignature( methodArguments:MethodArgument[] ):string;\nexport function hasSignature( methodArguments:MethodArgument[], returns:MethodReturn ):string;\nexport function hasSignature( returns:MethodReturn ):string;\nexport function hasSignature( descriptionOrArgumentsOrReturns:any = null, argumentsOrReturns:any = null, returns:MethodReturn = null ):string {\n\tlet description:string = null;\n\tlet methodArguments:MethodArgument[] = null;\n\n\tif ( typeof descriptionOrArgumentsOrReturns === \"string\" ) {\n\t\tdescription = descriptionOrArgumentsOrReturns;\n\t} else if ( Object.prototype.toString.call( descriptionOrArgumentsOrReturns ) === \"[object Array]\" ) {\n\t\tmethodArguments = descriptionOrArgumentsOrReturns;\n\t} else if ( descriptionOrArgumentsOrReturns ) {\n\t\treturns = descriptionOrArgumentsOrReturns;\n\t}\n\n\tif ( Object.prototype.toString.call( argumentsOrReturns ) === \"[object Array]\" ) {\n\t\tmethodArguments = argumentsOrReturns;\n\t} else if ( argumentsOrReturns ) {\n\t\treturns = argumentsOrReturns;\n\t}\n\n\tlet descriptor:MethodDescriptor = {\n\t\tspecType: SIGNATURE,\n\t\tdescription: description,\n\t\targuments: methodArguments,\n\t\treturns: returns,\n\t};\n\n\treturn toJSON( descriptor );\n}\n\nexport function hasProperty( access:string, name:string, type:string, description:string = null ):string {\n\tlet descriptor:PropertyDescriptor = {\n\t\taccess: access,\n\t\tspecType: PROPERTY,\n\t\tname: name,\n\t\ttype: type,\n\t\tdescription: description,\n\t};\n\n\treturn toJSON( descriptor );\n}\n\n/* tslint:disable: typedef */\nexport let property = hasProperty;\n/* tslint:enable: typedef */\n\nexport function extendsClass( name:string ):string {\n\tlet descriptor:SpecDescriptor = {\n\t\tspecType: SUPER_CLASS,\n\t\tname: name,\n\t};\n\n\treturn toJSON( descriptor );\n}\n"],"sourceRoot":"/source/"}