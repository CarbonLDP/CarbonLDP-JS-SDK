{"version":3,"sources":["ObjectSchema.ts"],"names":["Digester.digestSchema","Digester.combineDigestedObjectSchemas","Digester.resolvePrefixedURIs"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iDA+D+BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kDAYFC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sDA+FFC","file":"ObjectSchema.js","sourcesContent":["/// <reference path=\"./../typings/typings.d.ts\" />\n\nimport * as Errors from \"./Errors\";\nimport * as NS from \"./NS\";\nimport * as Pointer from \"./Pointer\";\nimport * as RDF from \"./RDF\";\nimport * as Utils from \"./Utils\";\n\nexport interface PropertyDefinition {\n\t\"@id\"?:string;\n\t\"@type\"?:string;\n\t\"@language\"?:string;\n\t\"@container\"?:string;\n}\n\nexport interface Class {\n\t\"@base\"?:string;\n\t\"@index\"?:Object;\n\t\"@language\"?:string;\n\t\"@reverse\"?:Object;\n\t\"@vocab\"?:string;\n\t[ name:string ]:(string | PropertyDefinition);\n}\n\nexport enum ContainerType {\n\tSET,\n\tLIST,\n\tLANGUAGE\n}\n\nexport class DigestedObjectSchema {\n\tbase:string;\n\tprefixes:Map<string, RDF.URI.Class>;\n\tproperties:Map<string, DigestedPropertyDefinition>;\n\tprefixedURIs:Map<string, RDF.URI.Class[]>;\n\n\tconstructor() {\n\t\tthis.base = \"\";\n\t\tthis.prefixes = new Map<string, RDF.URI.Class>();\n\t\tthis.properties = new Map<string, DigestedPropertyDefinition>();\n\t\tthis.prefixedURIs = new Map<string, RDF.URI.Class[]>();\n\t}\n}\n\nexport class DigestedPropertyDefinition {\n\turi:RDF.URI.Class = null;\n\tliteral:boolean = null;\n\tliteralType:RDF.URI.Class = null;\n\tlanguage:string = null;\n\tcontainerType:ContainerType = null;\n}\n\nexport interface Resolver {\n\tgetSchemaFor( object:Object ):DigestedObjectSchema;\n}\n\nexport class Digester {\n\tstatic digestSchema( schemas:Class[] ):DigestedObjectSchema;\n\tstatic digestSchema( schema:Class ):DigestedObjectSchema;\n\tstatic digestSchema( schemaOrSchemas:any ):DigestedObjectSchema {\n\t\tif( ! Utils.isArray( schemaOrSchemas ) ) return Digester.digestSingleSchema( schemaOrSchemas );\n\n\t\tlet digestedSchemas:DigestedObjectSchema[] = [];\n\t\tfor( let schema of <Class[]> schemaOrSchemas ) {\n\t\t\tdigestedSchemas.push( Digester.digestSingleSchema( schema ) );\n\t\t}\n\n\t\treturn Digester.combineDigestedObjectSchemas( digestedSchemas );\n\t}\n\n\tstatic combineDigestedObjectSchemas( digestedSchemas:DigestedObjectSchema[] ):DigestedObjectSchema {\n\t\tif( digestedSchemas.length === 0 ) throw new Errors.IllegalArgumentError( \"At least one DigestedObjectSchema needs to be specified.\" );\n\n\t\tlet combinedSchema:DigestedObjectSchema = digestedSchemas.shift();\n\n\t\tfor( let digestedSchema of digestedSchemas ) {\n\t\t\tUtils.M.extend( combinedSchema.prefixes, digestedSchema.prefixes );\n\t\t\tUtils.M.extend( combinedSchema.prefixedURIs, digestedSchema.prefixedURIs );\n\t\t\tUtils.M.extend( combinedSchema.properties, digestedSchema.properties );\n\t\t}\n\n\t\tDigester.resolvePrefixedURIs( combinedSchema );\n\n\t\treturn combinedSchema;\n\t}\n\n\tprivate static digestSingleSchema( schema:Class ):DigestedObjectSchema {\n\t\tlet digestedSchema:DigestedObjectSchema = new DigestedObjectSchema();\n\n\t\tfor( let propertyName in schema ) {\n\t\t\tif( ! schema.hasOwnProperty( propertyName ) ) continue;\n\n\t\t\tif( propertyName === \"@reverse\" ) continue;\n\t\t\tif( propertyName === \"@index\" ) continue;\n\t\t\tif( propertyName === \"@base\" ) continue;\n\t\t\tif( propertyName === \"@vocab\" ) continue;\n\n\t\t\tlet propertyValue:( string | PropertyDefinition ) = schema[ propertyName ];\n\n\t\t\tif( Utils.isString( propertyValue ) ) {\n\t\t\t\tif( RDF.URI.Util.isPrefixed( propertyName ) ) throw new Errors.IllegalArgumentError( \"A prefixed property cannot be equal to another URI.\" );\n\n\t\t\t\tlet uri:RDF.URI.Class = new RDF.URI.Class( <string> propertyValue );\n\t\t\t\tif( RDF.URI.Util.isPrefixed( uri.stringValue ) ) uri = Digester.resolvePrefixedURI( uri, digestedSchema );\n\t\t\t\tdigestedSchema.prefixes.set( propertyName, uri );\n\t\t\t} else if( !! propertyValue && Utils.isObject( propertyValue ) ) {\n\t\t\t\tlet schemaDefinition:PropertyDefinition = <PropertyDefinition> propertyValue;\n\t\t\t\tlet digestedDefinition:DigestedPropertyDefinition = new DigestedPropertyDefinition();\n\n\t\t\t\tif( \"@id\" in schemaDefinition ) {\n\t\t\t\t\tif( RDF.URI.Util.isPrefixed( propertyName ) ) throw new Errors.IllegalArgumentError( \"A prefixed property cannot have assigned another URI.\" );\n\n\t\t\t\t\tif( ! Utils.isString( schemaDefinition[ \"@id\" ] ) ) throw new Errors.IllegalArgumentError( \"@id needs to point to a string\" );\n\t\t\t\t\tdigestedDefinition.uri = Digester.resolvePrefixedURI( new RDF.URI.Class( schemaDefinition[ \"@id\" ] ), digestedSchema );\n\t\t\t\t} else if( RDF.URI.Util.isPrefixed( propertyName ) ) {\n\t\t\t\t\tdigestedDefinition.uri = Digester.resolvePrefixedURI( new RDF.URI.Class( propertyName ), digestedSchema );\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Handle @vocab or @base case\n\t\t\t\t\tthrow new Errors.IllegalArgumentError( \"Every property definition needs to have a uri defined.\" );\n\t\t\t\t}\n\n\t\t\t\tif( \"@type\" in schemaDefinition ) {\n\t\t\t\t\tif( ! Utils.isString( schemaDefinition[ \"@type\" ] ) ) throw new Errors.IllegalArgumentError( \"@type needs to point to a string\" );\n\n\t\t\t\t\tif( schemaDefinition[ \"@type\" ] === \"@id\" ) {\n\t\t\t\t\t\tdigestedDefinition.literal = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdigestedDefinition.literal = true;\n\t\t\t\t\t\tdigestedDefinition.literalType = Digester.resolvePrefixedURI( new RDF.URI.Class( schemaDefinition[ \"@type\" ] ), digestedSchema );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( \"@language\" in schemaDefinition ) {\n\t\t\t\t\tif( ! Utils.isString( schemaDefinition[ \"@language\" ] ) ) throw new Errors.IllegalArgumentError( \"@language needs to point to a string\" );\n\t\t\t\t\tdigestedDefinition.language = schemaDefinition[ \"@language\" ];\n\t\t\t\t}\n\n\t\t\t\tif( \"@container\" in schemaDefinition ) {\n\t\t\t\t\tswitch( schemaDefinition[ \"@container\" ] ) {\n\t\t\t\t\t\tcase \"@set\":\n\t\t\t\t\t\t\tdigestedDefinition.containerType = ContainerType.SET;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"@list\":\n\t\t\t\t\t\t\tdigestedDefinition.containerType = ContainerType.LIST;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"@language\":\n\t\t\t\t\t\t\tif( digestedDefinition.language !== null ) throw new Errors.IllegalArgumentError( \"@container cannot be set to @language when the property definition already contains an @language tag.\" );\n\t\t\t\t\t\t\tdigestedDefinition.containerType = ContainerType.LANGUAGE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Errors.IllegalArgumentError( \"@container needs to be equal to '@list', '@set', or '@language'\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdigestedSchema.properties.set( propertyName, digestedDefinition );\n\t\t\t} else {\n\t\t\t\tthrow new Errors.IllegalArgumentError( \"ObjectSchema Properties can only have string values or object values.\" );\n\t\t\t}\n\t\t}\n\n\t\tDigester.resolvePrefixedURIs( digestedSchema );\n\n\t\treturn digestedSchema;\n\t}\n\n\tprivate static resolvePrefixedURIs( digestedSchema:DigestedObjectSchema ):DigestedObjectSchema {\n\t\tdigestedSchema.prefixes.forEach( ( prefixValue:RDF.URI.Class, prefixName:string ) => {\n\t\t\tif( ! digestedSchema.prefixedURIs.has( prefixName ) ) return;\n\n\t\t\tlet prefixedURIs:RDF.URI.Class[] = digestedSchema.prefixedURIs.get( prefixName );\n\t\t\tfor( let prefixedURI of prefixedURIs ) {\n\t\t\t\tDigester.resolvePrefixedURI( prefixedURI, digestedSchema );\n\t\t\t}\n\n\t\t\tdigestedSchema.prefixedURIs.delete( prefixName );\n\t\t} );\n\n\t\treturn digestedSchema;\n\t}\n\n\tprivate static resolvePrefixedURI( uri:RDF.URI.Class, digestedSchema:DigestedObjectSchema ):RDF.URI.Class {\n\t\tif( ! RDF.URI.Util.isPrefixed( uri.stringValue ) ) return uri;\n\n\t\tlet uriParts:string[] = uri.stringValue.split( \":\" );\n\t\tlet prefix:string = uriParts[ 0 ];\n\t\tlet slug:string = uriParts[ 1 ];\n\n\t\tif( digestedSchema.prefixes.has( prefix ) ) {\n\t\t\turi.stringValue = digestedSchema.prefixes.get( prefix ) + slug;\n\t\t} else {\n\t\t\tif( ! digestedSchema.prefixedURIs.has( prefix ) ) digestedSchema.prefixedURIs.set( prefix, [] );\n\t\t\tdigestedSchema.prefixedURIs.get( prefix ).push( uri );\n\t\t}\n\n\t\treturn uri;\n\t}\n}\n\n\nexport default Class;\n"],"sourceRoot":"/source/"}