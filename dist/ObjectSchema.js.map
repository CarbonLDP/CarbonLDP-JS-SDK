{"version":3,"sources":["ObjectSchema.ts"],"names":[],"mappings":";AAAA,IAAY,MAAM,WAAM,UAAU,CAAC,CAAA;AAGnC,IAAY,GAAG,WAAM,OAAO,CAAC,CAAA;AAC7B,IAAY,KAAK,WAAM,SAAS,CAAC,CAAA;AAkBjC,WAAY,aAAa;IACxB,+CAAG,CAAA;IACH,iDAAI,CAAA;IACJ,yDAAQ,CAAA;AACT,CAAC,EAJW,qBAAa,KAAb,qBAAa,QAIxB;AAJD,IAAY,aAAa,GAAb,qBAIX,CAAA;AAED;IAOC;QACC,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;QACf,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;QAChB,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAAyB,CAAC;QACjD,IAAI,CAAC,UAAU,GAAG,IAAI,GAAG,EAAsC,CAAC;QAChE,IAAI,CAAC,YAAY,GAAG,IAAI,GAAG,EAA2B,CAAC;IACxD,CAAC;IACF,2BAAC;AAAD,CAdA,AAcC,IAAA;AAdY,4BAAoB,uBAchC,CAAA;AAED;IAAA;QACC,QAAG,GAAiB,IAAI,CAAC;QACzB,YAAO,GAAW,IAAI,CAAC;QACvB,gBAAW,GAAiB,IAAI,CAAC;QACjC,aAAQ,GAAU,IAAI,CAAC;QACvB,kBAAa,GAAiB,IAAI,CAAC;IACpC,CAAC;IAAD,iCAAC;AAAD,CANA,AAMC,IAAA;AANY,kCAA0B,6BAMtC,CAAA;AAMD;IAAA;IAgJA,CAAC;IA7IO,qBAAY,GAAnB,UAAqB,eAAmB;QACvC,EAAE,CAAA,CAAE,CAAE,KAAK,CAAC,OAAO,CAAE,eAAe,CAAG,CAAC;YAAC,MAAM,CAAC,QAAQ,CAAC,kBAAkB,CAAE,eAAe,CAAE,CAAC;QAE/F,IAAI,eAAe,GAA0B,EAAE,CAAC;QAChD,GAAG,CAAA,CAAgB,UAAyB,EAAzB,KAAU,eAAe,EAAzB,cAAyB,EAAzB,IAA0B,CAAC;YAAzC,IAAI,MAAM,SAAA;YACd,eAAe,CAAC,IAAI,CAAE,QAAQ,CAAC,kBAAkB,CAAE,MAAM,CAAE,CAAE,CAAC;SAC9D;QAED,MAAM,CAAC,QAAQ,CAAC,4BAA4B,CAAE,eAAe,CAAE,CAAC;IACjE,CAAC;IAEM,qCAA4B,GAAnC,UAAqC,eAAsC;QAC1E,EAAE,CAAA,CAAE,eAAe,CAAC,MAAM,KAAK,CAAE,CAAC;YAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,0DAA0D,CAAE,CAAC;QAEvI,IAAI,cAAc,GAAwB,IAAI,oBAAoB,EAAE,CAAC;QAErE,GAAG,CAAA,CAAwB,UAAe,EAAf,mCAAe,EAAf,6BAAe,EAAf,IAAgB,CAAC;YAAvC,IAAI,cAAc,wBAAA;YACtB,KAAK,CAAC,CAAC,CAAC,MAAM,CAAE,cAAc,CAAC,QAAQ,EAAE,cAAc,CAAC,QAAQ,CAAE,CAAC;YACnE,KAAK,CAAC,CAAC,CAAC,MAAM,CAAE,cAAc,CAAC,YAAY,EAAE,cAAc,CAAC,YAAY,CAAE,CAAC;YAC3E,KAAK,CAAC,CAAC,CAAC,MAAM,CAAE,cAAc,CAAC,UAAU,EAAE,cAAc,CAAC,UAAU,CAAE,CAAC;SACvE;QAED,QAAQ,CAAC,mBAAmB,CAAE,cAAc,CAAE,CAAC;QAE/C,MAAM,CAAC,cAAc,CAAC;IACvB,CAAC;IAEc,2BAAkB,GAAjC,UAAmC,MAAY;QAC9C,IAAI,cAAc,GAAwB,IAAI,oBAAoB,EAAE,CAAC;QAErE,GAAG,CAAA,CAAE,IAAI,YAAY,IAAI,MAAO,CAAC,CAAC,CAAC;YAClC,EAAE,CAAA,CAAE,CAAE,MAAM,CAAC,cAAc,CAAE,YAAY,CAAG,CAAC;gBAAC,QAAQ,CAAC;YAEvD,EAAE,CAAA,CAAE,YAAY,KAAK,UAAW,CAAC;gBAAC,QAAQ,CAAC;YAC3C,EAAE,CAAA,CAAE,YAAY,KAAK,QAAS,CAAC;gBAAC,QAAQ,CAAC;YACzC,EAAE,CAAA,CAAE,YAAY,KAAK,OAAQ,CAAC;gBAAC,QAAQ,CAAC;YAExC,IAAI,aAAa,GAAmC,MAAM,CAAE,YAAY,CAAE,CAAC;YAE3E,EAAE,CAAA,CAAE,KAAK,CAAC,QAAQ,CAAE,aAAa,CAAG,CAAC,CAAC,CAAC;gBACtC,EAAE,CAAA,CAAE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAE,YAAY,CAAG,CAAC;oBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,qDAAqD,CAAE,CAAC;gBAE7I,IAAI,GAAG,GAAiB,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,CAAW,aAAa,CAAE,CAAC;gBACpE,EAAE,CAAA,CAAE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAE,GAAG,CAAC,WAAW,CAAG,CAAC;oBAAC,GAAG,GAAG,QAAQ,CAAC,kBAAkB,CAAE,GAAG,EAAE,cAAc,CAAE,CAAC;gBAE1G,EAAE,CAAC,CAAE,YAAY,KAAK,QAAS,CAAC,CAAC,CAAC;oBACjC,cAAc,CAAC,KAAK,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC;gBACvC,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACP,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAE,YAAY,EAAE,GAAG,CAAE,CAAC;gBAClD,CAAC;YACF,CAAC;YAAC,IAAI,CAAC,EAAE,CAAA,CAAE,CAAC,CAAE,aAAa,IAAI,KAAK,CAAC,QAAQ,CAAE,aAAa,CAAG,CAAC,CAAC,CAAC;gBACjE,IAAI,gBAAgB,GAA2C,aAAa,CAAC;gBAC7E,IAAI,kBAAkB,GAA8B,IAAI,0BAA0B,EAAE,CAAC;gBAErF,EAAE,CAAA,CAAE,KAAK,IAAI,gBAAiB,CAAC,CAAC,CAAC;oBAChC,EAAE,CAAA,CAAE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAE,YAAY,CAAG,CAAC;wBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,uDAAuD,CAAE,CAAC;oBAE/I,EAAE,CAAA,CAAE,CAAE,KAAK,CAAC,QAAQ,CAAE,gBAAgB,CAAE,KAAK,CAAE,CAAG,CAAC;wBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,gCAAgC,CAAE,CAAC;oBAC9H,kBAAkB,CAAC,GAAG,GAAG,QAAQ,CAAC,kBAAkB,CAAE,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,CAAE,gBAAgB,CAAE,KAAK,CAAE,CAAE,EAAE,cAAc,CAAE,CAAC;gBACxH,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAA,CAAE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAE,YAAY,CAAG,CAAC,CAAC,CAAC;oBACrD,kBAAkB,CAAC,GAAG,GAAG,QAAQ,CAAC,kBAAkB,CAAE,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,CAAE,YAAY,CAAE,EAAE,cAAc,CAAE,CAAC;gBAC3G,CAAC;gBAAC,IAAI,CAAC,CAAC;oBAEP,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,wDAAwD,CAAE,CAAC;gBACnG,CAAC;gBAED,EAAE,CAAA,CAAE,OAAO,IAAI,gBAAiB,CAAC,CAAC,CAAC;oBAClC,EAAE,CAAA,CAAE,CAAE,KAAK,CAAC,QAAQ,CAAE,gBAAgB,CAAE,OAAO,CAAE,CAAG,CAAC;wBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,kCAAkC,CAAE,CAAC;oBAElI,EAAE,CAAA,CAAE,gBAAgB,CAAE,OAAO,CAAE,KAAK,KAAM,CAAC,CAAC,CAAC;wBAC5C,kBAAkB,CAAC,OAAO,GAAG,KAAK,CAAC;oBACpC,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACP,kBAAkB,CAAC,OAAO,GAAG,IAAI,CAAC;wBAClC,kBAAkB,CAAC,WAAW,GAAG,QAAQ,CAAC,kBAAkB,CAAE,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,CAAE,gBAAgB,CAAE,OAAO,CAAE,CAAE,EAAE,cAAc,CAAE,CAAC;oBAClI,CAAC;gBACF,CAAC;gBAED,EAAE,CAAA,CAAE,WAAW,IAAI,gBAAiB,CAAC,CAAC,CAAC;oBACtC,EAAE,CAAA,CAAE,CAAE,KAAK,CAAC,QAAQ,CAAE,gBAAgB,CAAE,WAAW,CAAE,CAAG,CAAC;wBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,sCAAsC,CAAE,CAAC;oBAC1I,kBAAkB,CAAC,QAAQ,GAAG,gBAAgB,CAAE,WAAW,CAAE,CAAC;gBAC/D,CAAC;gBAED,EAAE,CAAA,CAAE,YAAY,IAAI,gBAAiB,CAAC,CAAC,CAAC;oBACvC,MAAM,CAAA,CAAE,gBAAgB,CAAE,YAAY,CAAG,CAAC,CAAC,CAAC;wBAC3C,KAAK,MAAM;4BACV,kBAAkB,CAAC,aAAa,GAAG,aAAa,CAAC,GAAG,CAAC;4BACrD,KAAK,CAAC;wBACP,KAAK,OAAO;4BACX,kBAAkB,CAAC,aAAa,GAAG,aAAa,CAAC,IAAI,CAAC;4BACtD,KAAK,CAAC;wBACP,KAAK,WAAW;4BACf,EAAE,CAAA,CAAE,kBAAkB,CAAC,QAAQ,KAAK,IAAK,CAAC;gCAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,uGAAuG,CAAE,CAAC;4BAC5L,kBAAkB,CAAC,aAAa,GAAG,aAAa,CAAC,QAAQ,CAAC;4BAC1D,KAAK,CAAC;wBACP;4BACC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,iEAAiE,CAAE,CAAC;oBAC7G,CAAC;gBACF,CAAC;gBAED,cAAc,CAAC,UAAU,CAAC,GAAG,CAAE,YAAY,EAAE,kBAAkB,CAAE,CAAC;YACnE,CAAC;YAAC,IAAI,CAAC,CAAC;gBACP,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,uEAAuE,CAAE,CAAC;YAClH,CAAC;QACF,CAAC;QAED,QAAQ,CAAC,mBAAmB,CAAE,cAAc,CAAE,CAAC;QAE/C,MAAM,CAAC,cAAc,CAAC;IACvB,CAAC;IAEc,4BAAmB,GAAlC,UAAoC,cAAmC;QACtE,cAAc,CAAC,QAAQ,CAAC,OAAO,CAAE,UAAE,WAAyB,EAAE,UAAiB;YAC9E,EAAE,CAAA,CAAE,CAAE,cAAc,CAAC,YAAY,CAAC,GAAG,CAAE,UAAU,CAAG,CAAC;gBAAC,MAAM,CAAC;YAE7D,IAAI,YAAY,GAAmB,cAAc,CAAC,YAAY,CAAC,GAAG,CAAE,UAAU,CAAE,CAAC;YACjF,GAAG,CAAA,CAAqB,UAAY,EAAZ,6BAAY,EAAZ,0BAAY,EAAZ,IAAa,CAAC;gBAAjC,IAAI,WAAW,qBAAA;gBACnB,QAAQ,CAAC,kBAAkB,CAAE,WAAW,EAAE,cAAc,CAAE,CAAC;aAC3D;YAED,cAAc,CAAC,YAAY,CAAC,MAAM,CAAE,UAAU,CAAE,CAAC;QAClD,CAAC,CAAE,CAAC;QAEJ,MAAM,CAAC,cAAc,CAAC;IACvB,CAAC;IAEc,2BAAkB,GAAjC,UAAmC,GAAiB,EAAE,cAAmC;QACxF,EAAE,CAAA,CAAE,CAAE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAE,GAAG,CAAC,WAAW,CAAG,CAAC;YAAC,MAAM,CAAC,GAAG,CAAC;QAE9D,IAAI,QAAQ,GAAY,GAAG,CAAC,WAAW,CAAC,KAAK,CAAE,GAAG,CAAE,CAAC;QACrD,IAAI,MAAM,GAAU,QAAQ,CAAE,CAAC,CAAE,CAAC;QAClC,IAAI,IAAI,GAAU,QAAQ,CAAE,CAAC,CAAE,CAAC;QAEhC,EAAE,CAAA,CAAE,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAE,MAAM,CAAG,CAAC,CAAC,CAAC;YAC5C,GAAG,CAAC,WAAW,GAAG,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAE,MAAM,CAAE,GAAG,IAAI,CAAC;QAChE,CAAC;QAAC,IAAI,CAAC,CAAC;YACP,EAAE,CAAA,CAAE,CAAE,cAAc,CAAC,YAAY,CAAC,GAAG,CAAE,MAAM,CAAG,CAAC;gBAAC,cAAc,CAAC,YAAY,CAAC,GAAG,CAAE,MAAM,EAAE,EAAE,CAAE,CAAC;YAChG,cAAc,CAAC,YAAY,CAAC,GAAG,CAAE,MAAM,CAAE,CAAC,IAAI,CAAE,GAAG,CAAE,CAAC;QACvD,CAAC;QAED,MAAM,CAAC,GAAG,CAAC;IACZ,CAAC;IACF,eAAC;AAAD,CAhJA,AAgJC,IAAA;AAhJY,gBAAQ,WAgJpB,CAAA","file":"ObjectSchema.js","sourcesContent":["import * as Errors from \"./Errors\";\nimport * as NS from \"./NS\";\nimport * as Pointer from \"./Pointer\";\nimport * as RDF from \"./RDF\";\nimport * as Utils from \"./Utils\";\n\nexport interface PropertyDefinition {\n\t\"@id\"?:string;\n\t\"@type\"?:string;\n\t\"@language\"?:string;\n\t\"@container\"?:string;\n}\n\nexport interface Class {\n\t\"@base\"?:string;\n\t\"@index\"?:Object;\n\t\"@language\"?:string;\n\t\"@reverse\"?:Object;\n\t\"@vocab\"?:string;\n\t[ name:string ]:(string | PropertyDefinition);\n}\n\nexport enum ContainerType {\n\tSET,\n\tLIST,\n\tLANGUAGE\n}\n\nexport class DigestedObjectSchema {\n\tbase:string;\n\tvocab:string;\n\tprefixes:Map<string, RDF.URI.Class>;\n\tproperties:Map<string, DigestedPropertyDefinition>;\n\tprefixedURIs:Map<string, RDF.URI.Class[]>;\n\n\tconstructor() {\n\t\tthis.base = \"\";\n\t\tthis.vocab = \"\";\n\t\tthis.prefixes = new Map<string, RDF.URI.Class>();\n\t\tthis.properties = new Map<string, DigestedPropertyDefinition>();\n\t\tthis.prefixedURIs = new Map<string, RDF.URI.Class[]>();\n\t}\n}\n\nexport class DigestedPropertyDefinition {\n\turi:RDF.URI.Class = null;\n\tliteral:boolean = null;\n\tliteralType:RDF.URI.Class = null;\n\tlanguage:string = null;\n\tcontainerType:ContainerType = null;\n}\n\nexport interface Resolver {\n\tgetSchemaFor( object:Object ):DigestedObjectSchema;\n}\n\nexport class Digester {\n\tstatic digestSchema( schemas:Class[] ):DigestedObjectSchema;\n\tstatic digestSchema( schema:Class ):DigestedObjectSchema;\n\tstatic digestSchema( schemaOrSchemas:any ):DigestedObjectSchema {\n\t\tif( ! Utils.isArray( schemaOrSchemas ) ) return Digester.digestSingleSchema( schemaOrSchemas );\n\n\t\tlet digestedSchemas:DigestedObjectSchema[] = [];\n\t\tfor( let schema of <Class[]> schemaOrSchemas ) {\n\t\t\tdigestedSchemas.push( Digester.digestSingleSchema( schema ) );\n\t\t}\n\n\t\treturn Digester.combineDigestedObjectSchemas( digestedSchemas );\n\t}\n\n\tstatic combineDigestedObjectSchemas( digestedSchemas:DigestedObjectSchema[] ):DigestedObjectSchema {\n\t\tif( digestedSchemas.length === 0 ) throw new Errors.IllegalArgumentError( \"At least one DigestedObjectSchema needs to be specified.\" );\n\n\t\tlet combinedSchema:DigestedObjectSchema = new DigestedObjectSchema();\n\n\t\tfor( let digestedSchema of digestedSchemas ) {\n\t\t\tUtils.M.extend( combinedSchema.prefixes, digestedSchema.prefixes );\n\t\t\tUtils.M.extend( combinedSchema.prefixedURIs, digestedSchema.prefixedURIs );\n\t\t\tUtils.M.extend( combinedSchema.properties, digestedSchema.properties );\n\t\t}\n\n\t\tDigester.resolvePrefixedURIs( combinedSchema );\n\n\t\treturn combinedSchema;\n\t}\n\n\tprivate static digestSingleSchema( schema:Class ):DigestedObjectSchema {\n\t\tlet digestedSchema:DigestedObjectSchema = new DigestedObjectSchema();\n\n\t\tfor( let propertyName in schema ) {\n\t\t\tif( ! schema.hasOwnProperty( propertyName ) ) continue;\n\n\t\t\tif( propertyName === \"@reverse\" ) continue;\n\t\t\tif( propertyName === \"@index\" ) continue;\n\t\t\tif( propertyName === \"@base\" ) continue;\n\n\t\t\tlet propertyValue:( string | PropertyDefinition ) = schema[ propertyName ];\n\n\t\t\tif( Utils.isString( propertyValue ) ) {\n\t\t\t\tif( RDF.URI.Util.isPrefixed( propertyName ) ) throw new Errors.IllegalArgumentError( \"A prefixed property cannot be equal to another URI.\" );\n\n\t\t\t\tlet uri:RDF.URI.Class = new RDF.URI.Class( <string> propertyValue );\n\t\t\t\tif( RDF.URI.Util.isPrefixed( uri.stringValue ) ) uri = Digester.resolvePrefixedURI( uri, digestedSchema );\n\n\t\t\t\tif ( propertyName === \"@vocab\" ) {\n\t\t\t\t\tdigestedSchema.vocab = uri.toString();\n\t\t\t\t} else {\n\t\t\t\t\tdigestedSchema.prefixes.set( propertyName, uri );\n\t\t\t\t}\n\t\t\t} else if( !! propertyValue && Utils.isObject( propertyValue ) ) {\n\t\t\t\tlet schemaDefinition:PropertyDefinition = <PropertyDefinition> propertyValue;\n\t\t\t\tlet digestedDefinition:DigestedPropertyDefinition = new DigestedPropertyDefinition();\n\n\t\t\t\tif( \"@id\" in schemaDefinition ) {\n\t\t\t\t\tif( RDF.URI.Util.isPrefixed( propertyName ) ) throw new Errors.IllegalArgumentError( \"A prefixed property cannot have assigned another URI.\" );\n\n\t\t\t\t\tif( ! Utils.isString( schemaDefinition[ \"@id\" ] ) ) throw new Errors.IllegalArgumentError( \"@id needs to point to a string\" );\n\t\t\t\t\tdigestedDefinition.uri = Digester.resolvePrefixedURI( new RDF.URI.Class( schemaDefinition[ \"@id\" ] ), digestedSchema );\n\t\t\t\t} else if( RDF.URI.Util.isPrefixed( propertyName ) ) {\n\t\t\t\t\tdigestedDefinition.uri = Digester.resolvePrefixedURI( new RDF.URI.Class( propertyName ), digestedSchema );\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Handle @vocab or @base case\n\t\t\t\t\tthrow new Errors.IllegalArgumentError( \"Every property definition needs to have a uri defined.\" );\n\t\t\t\t}\n\n\t\t\t\tif( \"@type\" in schemaDefinition ) {\n\t\t\t\t\tif( ! Utils.isString( schemaDefinition[ \"@type\" ] ) ) throw new Errors.IllegalArgumentError( \"@type needs to point to a string\" );\n\n\t\t\t\t\tif( schemaDefinition[ \"@type\" ] === \"@id\" ) {\n\t\t\t\t\t\tdigestedDefinition.literal = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdigestedDefinition.literal = true;\n\t\t\t\t\t\tdigestedDefinition.literalType = Digester.resolvePrefixedURI( new RDF.URI.Class( schemaDefinition[ \"@type\" ] ), digestedSchema );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif( \"@language\" in schemaDefinition ) {\n\t\t\t\t\tif( ! Utils.isString( schemaDefinition[ \"@language\" ] ) ) throw new Errors.IllegalArgumentError( \"@language needs to point to a string\" );\n\t\t\t\t\tdigestedDefinition.language = schemaDefinition[ \"@language\" ];\n\t\t\t\t}\n\n\t\t\t\tif( \"@container\" in schemaDefinition ) {\n\t\t\t\t\tswitch( schemaDefinition[ \"@container\" ] ) {\n\t\t\t\t\t\tcase \"@set\":\n\t\t\t\t\t\t\tdigestedDefinition.containerType = ContainerType.SET;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"@list\":\n\t\t\t\t\t\t\tdigestedDefinition.containerType = ContainerType.LIST;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"@language\":\n\t\t\t\t\t\t\tif( digestedDefinition.language !== null ) throw new Errors.IllegalArgumentError( \"@container cannot be set to @language when the property definition already contains an @language tag.\" );\n\t\t\t\t\t\t\tdigestedDefinition.containerType = ContainerType.LANGUAGE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Errors.IllegalArgumentError( \"@container needs to be equal to '@list', '@set', or '@language'\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdigestedSchema.properties.set( propertyName, digestedDefinition );\n\t\t\t} else {\n\t\t\t\tthrow new Errors.IllegalArgumentError( \"ObjectSchema Properties can only have string values or object values.\" );\n\t\t\t}\n\t\t}\n\n\t\tDigester.resolvePrefixedURIs( digestedSchema );\n\n\t\treturn digestedSchema;\n\t}\n\n\tprivate static resolvePrefixedURIs( digestedSchema:DigestedObjectSchema ):DigestedObjectSchema {\n\t\tdigestedSchema.prefixes.forEach( ( prefixValue:RDF.URI.Class, prefixName:string ) => {\n\t\t\tif( ! digestedSchema.prefixedURIs.has( prefixName ) ) return;\n\n\t\t\tlet prefixedURIs:RDF.URI.Class[] = digestedSchema.prefixedURIs.get( prefixName );\n\t\t\tfor( let prefixedURI of prefixedURIs ) {\n\t\t\t\tDigester.resolvePrefixedURI( prefixedURI, digestedSchema );\n\t\t\t}\n\n\t\t\tdigestedSchema.prefixedURIs.delete( prefixName );\n\t\t} );\n\n\t\treturn digestedSchema;\n\t}\n\n\tprivate static resolvePrefixedURI( uri:RDF.URI.Class, digestedSchema:DigestedObjectSchema ):RDF.URI.Class {\n\t\tif( ! RDF.URI.Util.isPrefixed( uri.stringValue ) ) return uri;\n\n\t\tlet uriParts:string[] = uri.stringValue.split( \":\" );\n\t\tlet prefix:string = uriParts[ 0 ];\n\t\tlet slug:string = uriParts[ 1 ];\n\n\t\tif( digestedSchema.prefixes.has( prefix ) ) {\n\t\t\turi.stringValue = digestedSchema.prefixes.get( prefix ) + slug;\n\t\t} else {\n\t\t\tif( ! digestedSchema.prefixedURIs.has( prefix ) ) digestedSchema.prefixedURIs.set( prefix, [] );\n\t\t\tdigestedSchema.prefixedURIs.get( prefix ).push( uri );\n\t\t}\n\n\t\treturn uri;\n\t}\n}\n\n\nexport default Class;\n"],"sourceRoot":"/source/"}