{"version":3,"sources":["HTTP/Header.ts"],"names":[],"mappings":";;AAAA;IAoCC,gBAAa,MAA2B;QACvC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,OAAO,CAAE,MAAM,CAAE,CAAC,CAAC;YACtC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,CAAE,MAAM,CAAE,CAAC;IACzC,CAAC;IApCM,mBAAY,GAAnB,UAAqB,aAAoB;QACxC,IAAM,OAAO,GAAuB,IAAI,GAAG,EAAkB,CAAC;QAE9D,aAAa,CAAC,KAAK,CAAE,OAAO,CAAE,CAAC,OAAO,CAAE,UAAA,SAAS;YAChD,IAAI,CAAE,SAAS,CAAC,IAAI,EAAE;gBAAG,OAAO;YAEhC,IAAM,KAAK,GAAY,SAAS,CAAC,KAAK,CAAE,GAAG,CAAE,CAAC;YAC9C,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC;gBAAG,MAAM,IAAI,KAAK,CAAE,4CAA4C,CAAE,CAAC;YAEvF,IAAM,IAAI,GAAU,KAAK,CAAE,CAAC,CAAE,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,CAAC;YACpD,IAAM,MAAM,GAAY,MAAM,CAAC,YAAY,CAAE,KAAK,CAAC,KAAK,CAAE,CAAC,CAAE,CAAC,IAAI,CAAE,GAAG,CAAE,CAAE,CAAC;YAE5E,IAAI,OAAO,CAAC,GAAG,CAAE,IAAI,CAAE,EAAG;gBACzB,CAAA,KAAA,OAAO,CAAC,GAAG,CAAE,IAAI,CAAE,CAAC,MAAM,CAAA,CAAC,IAAI,WAAK,MAAM,EAAG;aAC7C;iBAAM;gBACN,OAAO,CAAC,GAAG,CAAE,IAAI,EAAE,IAAI,MAAM,CAAE,MAAM,CAAE,CAAE,CAAC;aAC1C;;QACF,CAAC,CAAE,CAAC;QAEJ,OAAO,OAAO,CAAC;IAChB,CAAC;IAEc,mBAAY,GAA3B,UAA6B,SAA4B;QACxD,IAAI,CAAE,SAAS;YAAG,OAAO,EAAE,CAAC;QAE5B,OAAO,SAAS;aACd,KAAK,CAAE,GAAG,CAAE;aACZ,GAAG,CAAE,UAAA,WAAW;YAChB,OAAO,WAAW,CAAC,IAAI,EAAE,CAAC;QAC3B,CAAC,CAAE,CACF;IACH,CAAC;IAOD,yBAAQ,GAAR,UAAU,KAAY;QACrB,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAE,KAAK,CAAE,KAAK,CAAE,CAAC,CAAC;IAC7C,CAAC;IAED,yBAAQ,GAAR;QACC,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAE,IAAI,CAAE,CAAC;IACjC,CAAC;IACF,aAAC;AAAD,CAhDA,AAgDC,IAAA;AAhDY,wBAAM","file":"Header.js","sourcesContent":["export class Header {\n\treadonly values:string[];\n\n\tstatic parseHeaders( headersString:string ):Map<string, Header> {\n\t\tconst headers:Map<string, Header> = new Map<string, Header>();\n\n\t\theadersString.split( /\\r?\\n/ ).forEach( strHeader => {\n\t\t\tif( ! strHeader.trim() ) return;\n\n\t\t\tconst parts:string[] = strHeader.split( \":\" );\n\t\t\tif( parts.length < 2 ) throw new Error( \"ParseError: The header couldn't be parsed.\" );\n\n\t\t\tconst name:string = parts[ 0 ].trim().toLowerCase();\n\t\t\tconst values:string[] = Header._parseValues( parts.slice( 1 ).join( \":\" ) );\n\n\t\t\tif( headers.has( name ) ) {\n\t\t\t\theaders.get( name ).values.push( ...values );\n\t\t\t} else {\n\t\t\t\theaders.set( name, new Header( values ) );\n\t\t\t}\n\t\t} );\n\n\t\treturn headers;\n\t}\n\n\tprivate static _parseValues( strValues:string | undefined ):string[] {\n\t\tif( ! strValues ) return [];\n\n\t\treturn strValues\n\t\t\t.split( \",\" )\n\t\t\t.map( valueString => {\n\t\t\t\treturn valueString.trim();\n\t\t\t} )\n\t\t\t;\n\t}\n\n\tconstructor( values?:(string | string[]) ) {\n\t\tthis.values = Array.isArray( values ) ?\n\t\t\tvalues : Header._parseValues( values );\n\t}\n\n\thasValue( value:string ):boolean {\n\t\treturn this.values.indexOf( value ) !== - 1;\n\t}\n\n\ttoString():string {\n\t\treturn this.values.join( \", \" );\n\t}\n}\n"]}