{"version":3,"sources":["HTTP/Request.ts"],"names":[],"mappings":"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","file":"Request.js","sourcesContent":["import HTTP from \"http\";\nimport HTTPS from \"https\";\nimport URL from \"url\";\n\nimport * as Utils from \"./../Utils\";\nimport { BadResponseError } from \"./Errors\";\nimport { Header } from \"./Header\";\nimport { HTTPMethod } from \"./HTTPMethod\";\nimport { Parser } from \"./Parser\";\nimport { Response } from \"./Response\";\n\nexport interface RequestOptions {\n\theaders?:Map<string, Header>;\n\tsendCredentialsOnCORS?:boolean;\n\ttimeout?:number;\n\trequest?:XMLHttpRequest;\n}\n\nexport interface GETOptions extends RequestOptions {\n\tensureLatest?:boolean;\n}\n\nexport interface RetrievalPreferences {\n\tinclude?:string[];\n\tomit?:string[];\n}\n\ninterface ResponseCallback {\n\t( response:Response ):void;\n}\n\nfunction forEachHeaders( headers:Map<string, Header>, setHeader:( name:string, value:string ) => any ):void {\n\tlet namesIterator:Iterator<string> = headers.keys();\n\tlet next:IteratorResult<string> = namesIterator.next();\n\twhile( ! next.done ) {\n\t\tlet name:string = next.value;\n\t\tlet value:Header = headers.get( name );\n\t\tsetHeader( name, value.toString() );\n\t\tnext = namesIterator.next();\n\t}\n}\n\nfunction onResolve( resolve:ResponseCallback, reject:ResponseCallback, response:Response ):void {\n\tif( response.status >= 200 && response.status <= 299 ) {\n\t\tresolve( response );\n\t} else {\n\t\treject( response );\n\t}\n}\n\nfunction sendWithBrowser( method:string, url:string, body:string | Blob, options:RequestOptions ):Promise<Response> {\n\treturn new Promise<Response>( ( resolve:ResponseCallback, reject:ResponseCallback ):void => {\n\t\tlet request:XMLHttpRequest = options.request ? options.request : new XMLHttpRequest();\n\t\trequest.open( method, url, true );\n\n\t\tif( options.headers ) forEachHeaders( options.headers, ( name:string, value:string ) => request.setRequestHeader( name, value ) );\n\t\trequest.withCredentials = options.sendCredentialsOnCORS;\n\t\tif( options.timeout ) request.timeout = options.timeout;\n\n\t\trequest.onload = request.onerror = () => {\n\t\t\tlet response:Response = new Response( request );\n\t\t\tonResolve( resolve, reject, response );\n\t\t};\n\n\t\tif( body ) {\n\t\t\trequest.send( body );\n\t\t} else {\n\t\t\trequest.send();\n\t\t}\n\t} );\n}\n\nfunction sendWithNode( method:string, url:string, body:string | Buffer, options:RequestOptions ):Promise<Response> {\n\treturn new Promise<Response>( ( resolve:ResponseCallback, reject:ResponseCallback ):void => {\n\t\tfunction returnResponse( request:HTTP.ClientRequest, res:HTTP.IncomingMessage ):void {\n\t\t\tlet rawData:Buffer[] = [];\n\n\t\t\tres.on( \"data\", ( chunk:string | Buffer ):void => {\n\t\t\t\tif( typeof chunk === \"string\" ) chunk = Buffer.from( <any>chunk, \"utf-8\" );\n\t\t\t\trawData.push( chunk );\n\t\t\t} ).on( \"end\", () => {\n\t\t\t\tlet data:string = Buffer.concat( rawData ).toString( \"utf8\" );\n\t\t\t\tlet response:Response = new Response( request, data, res );\n\n\t\t\t\tonResolve( resolve, reject, response );\n\t\t\t} );\n\t\t}\n\n\t\tlet numberOfRedirects:number = 0;\n\n\t\tfunction sendRequestWithRedirect( _url:string ):void {\n\t\t\tlet parsedURL:URL.Url = URL.parse( _url );\n\t\t\tlet Adapter:any = parsedURL.protocol === \"http:\" ? HTTP : HTTPS;\n\n\t\t\tlet requestOptions:HTTP.RequestOptions = {\n\t\t\t\tprotocol: parsedURL.protocol,\n\t\t\t\thostname: parsedURL.hostname,\n\t\t\t\tport: parsedURL.port,\n\t\t\t\tpath: parsedURL.path,\n\t\t\t\tmethod: method,\n\t\t\t\theaders: {},\n\t\t\t};\n\t\t\tif( options.headers ) forEachHeaders( options.headers, ( name:string, value:string ) => requestOptions.headers[ name ] = value );\n\n\t\t\tlet request:HTTP.ClientRequest = Adapter.request( requestOptions );\n\t\t\tif( options.timeout ) request.setTimeout( options.timeout );\n\t\t\trequest.on( \"response\", ( res:HTTP.IncomingMessage ) => {\n\t\t\t\tif( res.statusCode >= 300 && res.statusCode <= 399 && \"location\" in res.headers ) {\n\t\t\t\t\tif( ++ numberOfRedirects < 10 ) return sendRequestWithRedirect( URL.resolve( _url, res.headers.location ) );\n\t\t\t\t}\n\n\t\t\t\treturnResponse( request, res );\n\t\t\t} );\n\n\t\t\trequest.on( \"error\", ( error ) => {\n\t\t\t\tlet response:Response = new Response( request, error.message );\n\t\t\t\tonResolve( resolve, reject, response );\n\t\t\t} );\n\t\t\trequest.end( body );\n\t\t}\n\n\t\tsendRequestWithRedirect( url );\n\n\t} );\n}\n\nfunction sendRequest( method:string, url:string, body:string | Blob | Buffer, options:RequestOptions ):Promise<Response> {\n\treturn typeof XMLHttpRequest !== \"undefined\" ?\n\t\tsendWithBrowser( method, url, <string | Blob> body, options ) :\n\t\tsendWithNode( method, url, <string | Buffer> body, options );\n}\n\nfunction isBody( data:string | Blob | Buffer ):boolean {\n\treturn Utils.isString( data )\n\t\t|| typeof Blob !== \"undefined\" && data instanceof Blob\n\t\t|| typeof Buffer !== \"undefined\" && data instanceof Buffer;\n}\n\nexport class RequestService {\n\tprivate static defaultOptions:RequestOptions = {\n\t\tsendCredentialsOnCORS: true,\n\t};\n\n\tstatic send( method:(HTTPMethod | string), url:string, options?:RequestOptions ):Promise<Response>;\n\tstatic send( method:(HTTPMethod | string), url:string, body:string | Blob | Buffer, options?:RequestOptions ):Promise<Response>;\n\tstatic send( method:(HTTPMethod | string), url:string, body:string | Blob | Buffer, options?:RequestOptions ):Promise<Response>;\n\tstatic send<T>( method:(HTTPMethod | string), url:string, options?:RequestOptions, parser?:Parser<T> ):Promise<[ T, Response ]>;\n\tstatic send<T>( method:(HTTPMethod | string), url:string, body:string | Blob | Buffer, options?:RequestOptions, parser?:Parser<T> ):Promise<[ T, Response ]>;\n\tstatic send<T>( method:any, url:string, bodyOrOptions:any = RequestService.defaultOptions, optionsOrParser:any = RequestService.defaultOptions, parser:Parser<T> = null ):any {\n\t\tlet body:string | Blob | Buffer = null;\n\t\tlet options:RequestOptions = Utils.hasProperty( optionsOrParser, \"parse\" ) ? bodyOrOptions : optionsOrParser;\n\t\tparser = Utils.hasProperty( optionsOrParser, \"parse\" ) ? optionsOrParser : parser;\n\n\t\tif( isBody( bodyOrOptions ) ) {\n\t\t\tbody = bodyOrOptions;\n\t\t} else {\n\t\t\toptions = bodyOrOptions ? bodyOrOptions : options;\n\t\t}\n\n\t\toptions = Object.assign( {}, RequestService.defaultOptions, options );\n\n\t\tif( Utils.isNumber( method ) ) method = HTTPMethod[ method ];\n\n\t\tconst requestPromise:Promise<Response> = sendRequest( method, url, body, options )\n\t\t\t.then( response => {\n\t\t\t\tif( method === \"GET\" && options.headers ) return this._handleGETResponse( url, options, response );\n\t\t\t\telse return response;\n\t\t\t} )\n\t\t;\n\n\t\tif( parser === null ) return requestPromise;\n\n\t\treturn requestPromise.then( ( response:Response ) => {\n\t\t\treturn parser.parse( response.data ).then( ( parsedBody:T ) => {\n\t\t\t\treturn [ parsedBody, response ];\n\t\t\t} );\n\t\t} );\n\t}\n\n\tstatic options( url:string, options:RequestOptions = RequestService.defaultOptions ):Promise<Response> {\n\t\treturn RequestService.send( HTTPMethod.OPTIONS, url, options );\n\t}\n\n\tstatic head( url:string, options:RequestOptions = RequestService.defaultOptions ):Promise<Response> {\n\t\treturn RequestService.send( HTTPMethod.HEAD, url, options );\n\t}\n\n\tstatic get( url:string, options?:RequestOptions ):Promise<Response>;\n\tstatic get<T>( url:string, options?:RequestOptions, parser?:Parser<T> ):Promise<[ T, Response ]>;\n\tstatic get<T>( url:string, options:RequestOptions = RequestService.defaultOptions, parser:Parser<T> = null ):any {\n\t\treturn RequestService.send( HTTPMethod.GET, url, null, options, parser );\n\t}\n\n\tstatic post( url:string, body:Buffer, options?:RequestOptions ):Promise<Response>;\n\tstatic post<T>( url:string, body:Buffer, options?:RequestOptions, parser?:Parser<T> ):Promise<[ T, Response ]>;\n\tstatic post( url:string, body:Blob, options?:RequestOptions ):Promise<Response>;\n\tstatic post<T>( url:string, body:Blob, options?:RequestOptions, parser?:Parser<T> ):Promise<[ T, Response ]>;\n\tstatic post( url:string, body:string, options?:RequestOptions ):Promise<Response>;\n\tstatic post<T>( url:string, body:string, options?:RequestOptions, parser?:Parser<T> ):Promise<[ T, Response ]>;\n\tstatic post<T>( url:string, bodyOrOptions:any = RequestService.defaultOptions, options:RequestOptions = RequestService.defaultOptions, parser:Parser<T> = null ):any {\n\t\treturn RequestService.send( HTTPMethod.POST, url, bodyOrOptions, options, parser );\n\t}\n\n\tstatic put( url:string, body:string, options?:RequestOptions ):Promise<Response>;\n\tstatic put<T>( url:string, body:string, options?:RequestOptions, parser?:Parser<T> ):Promise<[ T, Response ]>;\n\tstatic put<T>( url:string, bodyOrOptions:any = RequestService.defaultOptions, options:RequestOptions = RequestService.defaultOptions, parser:Parser<T> = null ):any {\n\t\treturn RequestService.send( HTTPMethod.PUT, url, bodyOrOptions, options, parser );\n\t}\n\n\tstatic patch( url:string, body:string, options?:RequestOptions ):Promise<Response>;\n\tstatic patch<T>( url:string, body:string, options?:RequestOptions, parser?:Parser<T> ):Promise<[ T, Response ]>;\n\tstatic patch<T>( url:string, bodyOrOptions:any = RequestService.defaultOptions, options:RequestOptions = RequestService.defaultOptions, parser:Parser<T> = null ):any {\n\t\treturn RequestService.send( HTTPMethod.PATCH, url, bodyOrOptions, options, parser );\n\t}\n\n\tstatic delete( url:string, options?:RequestOptions ):Promise<Response>;\n\tstatic delete( url:string, body:string, options?:RequestOptions ):Promise<Response>;\n\tstatic delete<T>( url:string, options?:RequestOptions, parser?:Parser<T> ):Promise<[ T, Response ]>;\n\tstatic delete<T>( url:string, body:string, options?:RequestOptions, parser?:Parser<T> ):Promise<[ T, Response ]>;\n\tstatic delete<T>( url:string, bodyOrOptions:any = RequestService.defaultOptions, optionsOrParser:any = RequestService.defaultOptions, parser:Parser<T> = null ):any {\n\t\treturn RequestService.send( HTTPMethod.DELETE, url, bodyOrOptions, optionsOrParser, parser );\n\t}\n\n\t/**\n\t * GET requests can be affected by previously cached resources that were originally requested with a different Accept header. This method identifies that\n\t * and retries the request with headers that force browsers to ignore cache.\n\t */\n\tprivate static _handleGETResponse( url:string, requestOptions:RequestOptions, response:Response ):Promise<Response> {\n\t\treturn Promise.resolve()\n\t\t\t.then( () => {\n\t\t\t\tif( this._contentTypeIsAccepted( requestOptions, response ) ) return response;\n\n\t\t\t\tthis._setNoCacheHeaders( requestOptions );\n\n\t\t\t\tif( ! this._isChromiumAgent() ) this._setFalseETag( requestOptions );\n\n\t\t\t\treturn sendRequest( \"GET\", url, null, requestOptions )\n\t\t\t\t\t.then( noCachedResponse => {\n\t\t\t\t\t\tif( ! this._contentTypeIsAccepted( requestOptions, response ) ) {\n\t\t\t\t\t\t\tthrow new BadResponseError( \"The server responded with an unacceptable Content-Type\", response );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn noCachedResponse;\n\t\t\t\t\t} );\n\t\t\t} );\n\t}\n\n\tprivate static _contentTypeIsAccepted( requestOptions:RequestOptions, response:Response ):boolean {\n\t\tconst accepts:string[] = requestOptions.headers.has( \"accept\" ) ?\n\t\t\trequestOptions.headers.get( \"accept\" ).values :\n\t\t\t[]\n\t\t;\n\n\t\tconst contentType:Header = response.headers.has( \"content-type\" ) ?\n\t\t\tresponse.headers.get( \"content-type\" ) :\n\t\t\tnull\n\t\t;\n\t\treturn ! contentType || accepts.some( contentType.hasValue, contentType );\n\t}\n\n\tprivate static _setNoCacheHeaders( requestOptions:RequestOptions ):void {\n\t\trequestOptions.headers\n\t\t\t.set( \"pragma\", new Header( \"no-cache\" ) )\n\t\t\t.set( \"cache-control\", new Header( \"no-cache, max-age=0\" ) )\n\t\t;\n\t}\n\n\tprivate static _isChromiumAgent():boolean {\n\t\treturn typeof window !== \"undefined\" && ! window[ \"chrome\" ];\n\t}\n\n\tprivate static _setFalseETag( requestOptions:RequestOptions ):void {\n\t\trequestOptions.headers.set( \"if-none-match\", new Header() );\n\t}\n}\n\nexport class RequestUtils {\n\n\tstatic getHeader( headerName:string, requestOptions:RequestOptions, initialize:boolean = false ):Header {\n\t\theaderName = headerName.toLowerCase();\n\n\t\tif( initialize ) {\n\t\t\tlet headers:Map<string, Header> = requestOptions.headers ? requestOptions.headers : requestOptions.headers = new Map<string, Header>();\n\t\t\tif( ! headers.has( headerName ) )\n\t\t\t\theaders.set( headerName, new Header() );\n\t\t}\n\n\t\tif( ! requestOptions.headers ) return undefined;\n\t\treturn requestOptions.headers.get( headerName );\n\t}\n\n\tstatic setAcceptHeader( accept:string, requestOptions:RequestOptions ):RequestOptions {\n\t\tlet headers:Map<string, Header> = requestOptions.headers ? requestOptions.headers : requestOptions.headers = new Map<string, Header>();\n\t\theaders.set( \"accept\", new Header( accept ) );\n\t\treturn requestOptions;\n\t}\n\n\tstatic setContentTypeHeader( contentType:string, requestOptions:RequestOptions ):RequestOptions {\n\t\tlet headers:Map<string, Header> = requestOptions.headers ? requestOptions.headers : requestOptions.headers = new Map<string, Header>();\n\t\theaders.set( \"content-type\", new Header( contentType ) );\n\t\treturn requestOptions;\n\t}\n\n\tstatic setIfMatchHeader( eTag:string, requestOptions:RequestOptions ):RequestOptions {\n\t\tif( ! eTag ) return;\n\n\t\tlet headers:Map<string, Header> = requestOptions.headers ? requestOptions.headers : requestOptions.headers = new Map<string, Header>();\n\t\theaders.set( \"if-match\", new Header( eTag ) );\n\t\treturn requestOptions;\n\t}\n\n\tstatic setIfNoneMatchHeader( eTag:string, requestOptions:RequestOptions ):RequestOptions {\n\t\tif( ! eTag ) return;\n\n\t\tlet headers:Map<string, Header> = requestOptions.headers ? requestOptions.headers : requestOptions.headers = new Map<string, Header>();\n\t\theaders.set( \"if-none-match\", new Header( eTag ) );\n\t\treturn requestOptions;\n\t}\n\n\tstatic setPreferredInteractionModel( interactionModelURI:string, requestOptions:RequestOptions ):RequestOptions {\n\t\tlet prefer:Header = RequestUtils.getHeader( \"prefer\", requestOptions, true );\n\t\tprefer.values.push( interactionModelURI + \"; rel=interaction-model\" );\n\n\t\treturn requestOptions;\n\t}\n\n\tstatic setPreferredRetrieval( retrievalType:\"representation\" | \"minimal\", requestOptions:RequestOptions ):RequestOptions {\n\t\tconst prefer:Header = RequestUtils.getHeader( \"prefer\", requestOptions, true );\n\n\t\tprefer.values.push( `return=${ retrievalType }` );\n\t\treturn requestOptions;\n\t}\n\n\tstatic setRetrievalPreferences( preferences:RetrievalPreferences, requestOptions:RequestOptions ):RequestOptions {\n\t\tlet prefer:Header = RequestUtils.getHeader( \"prefer\", requestOptions, true );\n\n\t\tlet keys:string[] = [ \"include\", \"omit\" ];\n\t\tfor( let key of keys ) {\n\t\t\tif( key in preferences && preferences[ key ].length > 0 ) {\n\t\t\t\tprefer.values.push( `${ key }=\"${ preferences[ key ].join( \" \" ) }\"` );\n\t\t\t}\n\t\t}\n\n\t\treturn requestOptions;\n\t}\n\n\tstatic setSlug( slug:string, requestOptions:RequestOptions ):RequestOptions {\n\t\tlet slugHeader:Header = RequestUtils.getHeader( \"slug\", requestOptions, true );\n\t\tslugHeader.values.push( slug );\n\n\t\treturn requestOptions;\n\t}\n\n\tstatic isOptions( object:Object ):object is RequestOptions {\n\t\treturn Utils.hasPropertyDefined( object, \"headers\" )\n\t\t\t|| Utils.hasPropertyDefined( object, \"sendCredentialsOnCORS\" )\n\t\t\t|| Utils.hasPropertyDefined( object, \"timeout\" )\n\t\t\t|| Utils.hasPropertyDefined( object, \"request\" );\n\t}\n\n\tstatic cloneOptions( options:RequestOptions ):RequestOptions {\n\t\tconst clone:RequestOptions = {\n\t\t\t...options,\n\t\t\theaders: new Map(),\n\t\t};\n\n\t\tif( options.headers ) options.headers\n\t\t\t.forEach( ( value, key ) => clone.headers.set( key, new Header( value.values.slice() ) ) );\n\n\t\treturn clone;\n\t}\n\n}\n"]}