{"version":3,"sources":["HTTP/Response.ts"],"names":[],"mappings":";;AAIA,mCAAkC;AAElC;IAQC,kBAAa,OAAsC,EAAE,IAAY,EAAE,QAAyB;QAA5F,iBAiBC;QAhBA,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,EAAE,CAAA,CAAE,OAAO,cAAc,KAAK,WAAW,IAAI,OAAO,YAAY,cAAe,CAAC,CAAC,CAAC;YACjF,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;YAC7B,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,YAAY,CAAC;YACjC,IAAI,CAAC,OAAO,GAAG,eAAM,CAAC,YAAY,CAAE,OAAO,CAAC,qBAAqB,EAAE,CAAE,CAAC;QAEvE,CAAC;QAAC,IAAI,CAAC,CAAC;YACP,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;YACvB,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,EAAkB,CAAC;YACzC,EAAE,CAAA,CAAE,CAAE,QAAS,CAAC;gBAAC,MAAM,CAAC;YAExB,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,UAAU,CAAC;YAClC,MAAM,CAAC,IAAI,CAAE,QAAQ,CAAC,OAAO,CAAE,CAAC,OAAO,CAAE,UAAA,IAAI;gBAC5C,KAAI,CAAC,OAAO,CAAC,GAAG,CAAE,IAAI,CAAC,WAAW,EAAE,EAAE,IAAI,eAAM,CAAE,QAAQ,CAAC,OAAO,CAAE,IAAI,CAAE,CAAE,CAAE,CAAC;YAChF,CAAC,CAAE,CAAC;QACL,CAAC;IACF,CAAC;IAED,4BAAS,GAAT,UAAW,IAAW;QACrB,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;QAC1B,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAE,IAAI,CAAE,IAAI,IAAI,CAAC;IACzC,CAAC;IAED,0BAAO,GAAP;QACC,IAAM,UAAU,GAAU,IAAI,CAAC,SAAS,CAAE,MAAM,CAAE,CAAC;QAGnD,EAAE,CAAA,CAAE,CAAE,UAAU,IAAI,CAAE,UAAU,CAAC,MAAM,CAAC,MAAO,CAAC;YAAC,MAAM,CAAC,IAAI,CAAC;QAC7D,MAAM,CAAC,UAAU,CAAC,MAAM,CAAE,CAAC,CAAE,CAAC;IAC/B,CAAC;IAEF,eAAC;AAAD,CAxCA,AAwCC,IAAA;AAxCY,4BAAQ;AA0CrB,kBAAe,QAAQ,CAAC","file":"Response.js","sourcesContent":["import {\n\tClientRequest,\n\tIncomingMessage,\n} from \"http\";\nimport { Header } from \"./Header\";\n\nexport class Response {\n\treadonly status:number;\n\treadonly data:string;\n\treadonly headers:Map<string, Header>;\n\treadonly request:XMLHttpRequest | ClientRequest;\n\n\tconstructor( request:XMLHttpRequest );\n\tconstructor( request:ClientRequest, data:string, response?:IncomingMessage );\n\tconstructor( request:XMLHttpRequest | ClientRequest, data?:string, response?:IncomingMessage ) {\n\t\tthis.request = request;\n\t\tif( typeof XMLHttpRequest !== \"undefined\" && request instanceof XMLHttpRequest ) {\n\t\t\tthis.status = request.status;\n\t\t\tthis.data = request.responseText;\n\t\t\tthis.headers = Header.parseHeaders( request.getAllResponseHeaders() );\n\n\t\t} else {\n\t\t\tthis.data = data || \"\";\n\t\t\tthis.headers = new Map<string, Header>();\n\t\t\tif( ! response ) return;\n\n\t\t\tthis.status = response.statusCode;\n\t\t\tObject.keys( response.headers ).forEach( name => {\n\t\t\t\tthis.headers.set( name.toLowerCase(), new Header( response.headers[ name ] ) );\n\t\t\t} );\n\t\t}\n\t}\n\n\tgetHeader( name:string ):Header {\n\t\tname = name.toLowerCase();\n\t\treturn this.headers.get( name ) || null;\n\t}\n\n\tgetETag():string {\n\t\tconst eTagHeader:Header = this.getHeader( \"ETag\" );\n\n\t\t// TODO: Warn multiple ETags\n\t\tif( ! eTagHeader || ! eTagHeader.values.length ) return null;\n\t\treturn eTagHeader.values[ 0 ];\n\t}\n\n}\n\nexport default Response;\n"]}