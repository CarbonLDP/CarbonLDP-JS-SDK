{"version":3,"sources":["HTTP/Response.ts"],"names":[],"mappings":";;AAIA,mCAA4C;AAC5C,mCAAkC;AAElC;IAQC,kBAAa,OAAsC,EAAE,IAAY,EAAE,QAAyB;QAA5F,iBAiBC;QAhBA,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,OAAO,cAAc,KAAK,WAAW,IAAI,OAAO,YAAY,cAAc,EAAG;YAChF,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;YAC7B,IAAI,CAAC,IAAI,GAAG,OAAO,CAAC,YAAY,CAAC;YACjC,IAAI,CAAC,OAAO,GAAG,eAAM,CAAC,YAAY,CAAE,OAAO,CAAC,qBAAqB,EAAE,CAAE,CAAC;SAEtE;aAAM;YACN,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;YACvB,IAAI,CAAC,OAAO,GAAG,IAAI,GAAG,EAAkB,CAAC;YACzC,IAAI,CAAE,QAAQ;gBAAG,OAAO;YAExB,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,UAAU,CAAC;YAClC,MAAM,CAAC,IAAI,CAAE,QAAQ,CAAC,OAAO,CAAE,CAAC,OAAO,CAAE,UAAA,IAAI;gBAC5C,KAAI,CAAC,OAAO,CAAC,GAAG,CAAE,IAAI,CAAC,WAAW,EAAE,EAAE,IAAI,eAAM,CAAE,QAAQ,CAAC,OAAO,CAAE,IAAI,CAAE,CAAE,CAAE,CAAC;YAChF,CAAC,CAAE,CAAC;SACJ;IACF,CAAC;IAED,4BAAS,GAAT,UAAW,IAAW;QACrB,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;QAC1B,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAE,IAAI,CAAE,IAAI,IAAI,CAAC;IACzC,CAAC;IAED,0BAAO,GAAP;QACC,IAAM,UAAU,GAAU,IAAI,CAAC,SAAS,CAAE,MAAM,CAAE,CAAC;QAGnD,IAAI,CAAE,UAAU,IAAI,CAAE,UAAU,CAAC,MAAM,CAAC,MAAM;YAC7C,MAAM,IAAI,yBAAgB,CAAE,sCAAsC,EAAE,IAAI,CAAE,CAAC;QAE5E,OAAO,UAAU,CAAC,MAAM,CAAE,CAAC,CAAE,CAAC;IAC/B,CAAC;IAEF,eAAC;AAAD,CA1CA,AA0CC,IAAA;AA1CY,4BAAQ","file":"Response.js","sourcesContent":["import {\n\tClientRequest,\n\tIncomingMessage,\n} from \"http\";\nimport { BadResponseError } from \"./Errors\";\nimport { Header } from \"./Header\";\n\nexport class Response {\n\treadonly status:number;\n\treadonly data:string;\n\treadonly headers:Map<string, Header>;\n\treadonly request:XMLHttpRequest | ClientRequest;\n\n\tconstructor( request:XMLHttpRequest );\n\tconstructor( request:ClientRequest, data:string, response?:IncomingMessage );\n\tconstructor( request:XMLHttpRequest | ClientRequest, data?:string, response?:IncomingMessage ) {\n\t\tthis.request = request;\n\t\tif( typeof XMLHttpRequest !== \"undefined\" && request instanceof XMLHttpRequest ) {\n\t\t\tthis.status = request.status;\n\t\t\tthis.data = request.responseText;\n\t\t\tthis.headers = Header.parseHeaders( request.getAllResponseHeaders() );\n\n\t\t} else {\n\t\t\tthis.data = data || \"\";\n\t\t\tthis.headers = new Map<string, Header>();\n\t\t\tif( ! response ) return;\n\n\t\t\tthis.status = response.statusCode;\n\t\t\tObject.keys( response.headers ).forEach( name => {\n\t\t\t\tthis.headers.set( name.toLowerCase(), new Header( response.headers[ name ] ) );\n\t\t\t} );\n\t\t}\n\t}\n\n\tgetHeader( name:string ):Header {\n\t\tname = name.toLowerCase();\n\t\treturn this.headers.get( name ) || null;\n\t}\n\n\tgetETag():string {\n\t\tconst eTagHeader:Header = this.getHeader( \"ETag\" );\n\n\t\t// TODO: Warn multiple ETags\n\t\tif( ! eTagHeader || ! eTagHeader.values.length )\n\t\t\tthrow new BadResponseError( \"The response doesn't contain an ETag\", this );\n\n\t\treturn eTagHeader.values[ 0 ];\n\t}\n\n}\n"]}