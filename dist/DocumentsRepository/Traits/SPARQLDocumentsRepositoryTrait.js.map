{"version":3,"sources":["DocumentsRepository/Traits/SPARQLDocumentsRepositoryTrait.ts"],"names":[],"mappings":"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","file":"SPARQLDocumentsRepositoryTrait.js","sourcesContent":["import { QueryClause } from \"sparqler/clauses\";\n\nimport { DocumentsContext } from \"../../Context/DocumentsContext\";\n\nimport { Document } from \"../../Document/Document\";\n\nimport { IllegalArgumentError } from \"../../Errors/IllegalArgumentError\";\n\nimport { GeneralRepository } from \"../../GeneralRepository/GeneralRepository\";\n\nimport { RequestOptions } from \"../../HTTP/Request\";\n\nimport { ModelDecorator } from \"../../Model/ModelDecorator\";\nimport { ModelPrototype } from \"../../Model/ModelPrototype\";\n\nimport { DigestedObjectSchema } from \"../../ObjectSchema/DigestedObjectSchema\";\n\nimport { FinishSPARQLSelect, SPARQLBuilder } from \"../../SPARQL/SPARQLBuilder\";\nimport { SPARQLSelectResults } from \"../../SPARQL/SelectResults\";\nimport { SPARQLService } from \"../../SPARQL/SPARQLService\";\n\nimport { BaseDocumentsRepository } from \"../BaseDocumentsRepository\";\nimport { _getErrorResponseParserFn } from \"../Utils\";\n\nimport { HTTPRepositoryTrait } from \"./HTTPRepositoryTrait\";\n\n\nexport interface SPARQLDocumentsRepositoryTrait extends GeneralRepository<Document> {\n\t$context:DocumentsContext;\n\n\n\texecuteASKQuery( uri:string, askQuery:string, requestOptions?:RequestOptions ):Promise<boolean>;\n\n\texecuteSELECTQuery<T extends object>( uri:string, selectQuery:string, requestOptions?:RequestOptions ):Promise<SPARQLSelectResults<T>>;\n\n\texecuteUPDATE( uri:string, update:string, requestOptions?:RequestOptions ):Promise<void>;\n\n\n\tsparql( uri:string ):QueryClause<FinishSPARQLSelect>;\n}\n\n\nexport type SPARQLDocumentsRepositoryTraitFactory =\n\t& ModelPrototype<SPARQLDocumentsRepositoryTrait, HTTPRepositoryTrait>\n\t& ModelDecorator<SPARQLDocumentsRepositoryTrait, BaseDocumentsRepository>\n\t;\n\nexport const SPARQLDocumentsRepositoryTrait:SPARQLDocumentsRepositoryTraitFactory = {\n\tPROTOTYPE: {\n\t\texecuteASKQuery( this:SPARQLDocumentsRepositoryTrait, uri:string, askQuery:string, requestOptions?:RequestOptions ):Promise<boolean> {\n\t\t\tif( ! this.$context.registry.inScope( uri, true ) ) return Promise.reject( new IllegalArgumentError( `\"${ uri }\" is out of scope.` ) );\n\t\t\tconst url:string = this.$context.getObjectSchema().resolveURI( uri, { base: true } );\n\n\t\t\treturn SPARQLService\n\t\t\t\t.executeASKQuery( url, askQuery, requestOptions )\n\t\t\t\t.then( ( [ rawResults ] ) => rawResults )\n\t\t\t\t.catch( _getErrorResponseParserFn( this.$context.registry ) );\n\t\t},\n\n\t\texecuteSELECTQuery<T extends object>( this:SPARQLDocumentsRepositoryTrait, uri:string, selectQuery:string, requestOptions?:RequestOptions ):Promise<SPARQLSelectResults<T>> {\n\t\t\tif( ! this.$context.registry.inScope( uri, true ) ) return Promise.reject( new IllegalArgumentError( `\"${ uri }\" is out of scope.` ) );\n\t\t\tconst url:string = this.$context.getObjectSchema().resolveURI( uri, { base: true } );\n\n\t\t\treturn SPARQLService\n\t\t\t\t.executeSELECTQuery<T>( url, selectQuery, this.$context.registry, requestOptions )\n\t\t\t\t.then( ( [ selectResults ] ) => selectResults )\n\t\t\t\t.catch( _getErrorResponseParserFn( this.$context.registry ) );\n\t\t},\n\n\t\texecuteUPDATE( this:SPARQLDocumentsRepositoryTrait, uri:string, update:string, requestOptions?:RequestOptions ):Promise<void> {\n\t\t\tif( ! this.$context.registry.inScope( uri, true ) ) return Promise.reject( new IllegalArgumentError( `\"${ uri }\" is out of scope.` ) );\n\t\t\tconst url:string = this.$context.getObjectSchema().resolveURI( uri, { base: true } );\n\n\t\t\treturn SPARQLService\n\t\t\t\t.executeUPDATE( url, update, requestOptions )\n\t\t\t\t.then( () => {} )\n\t\t\t\t.catch( _getErrorResponseParserFn( this.$context.registry ) );\n\t\t},\n\n\n\t\tsparql( this:SPARQLDocumentsRepositoryTrait, uri:string ):QueryClause<FinishSPARQLSelect> {\n\t\t\tif( ! this.$context.registry.inScope( uri, true ) ) throw new IllegalArgumentError( `\"${ uri }\" is out of scope.` );\n\t\t\tconst url:string = this.$context.getObjectSchema().resolveURI( uri, { base: true } );\n\n\t\t\tconst schema:DigestedObjectSchema = this.$context.registry.getGeneralSchema();\n\t\t\tlet builder:QueryClause<FinishSPARQLSelect> = new SPARQLBuilder( this, url )\n\t\t\t\t.base( schema.base )\n\t\t\t\t.vocab( schema.vocab );\n\n\t\t\tschema.prefixes.forEach( ( name:string, prefix:string ) => {\n\t\t\t\tbuilder = builder.prefix( prefix, name );\n\t\t\t} );\n\n\t\t\treturn builder;\n\t\t},\n\t},\n\n\n\tisDecorated( object:object ):object is SPARQLDocumentsRepositoryTrait {\n\t\treturn ModelDecorator\n\t\t\t.hasPropertiesFrom( SPARQLDocumentsRepositoryTrait.PROTOTYPE, object );\n\t},\n\n\tdecorate<T extends BaseDocumentsRepository>( object:T ):T & SPARQLDocumentsRepositoryTrait {\n\t\tif( SPARQLDocumentsRepositoryTrait.isDecorated( object ) ) return object;\n\n\t\tconst target:T & GeneralRepository<any> = ModelDecorator\n\t\t\t.decorateMultiple( object, GeneralRepository );\n\n\t\treturn ModelDecorator\n\t\t\t.definePropertiesFrom( SPARQLDocumentsRepositoryTrait.PROTOTYPE, target );\n\t},\n};\n"]}