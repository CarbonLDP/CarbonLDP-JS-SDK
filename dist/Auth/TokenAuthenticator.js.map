{"version":3,"sources":["Auth/TokenAuthenticator.ts"],"names":[],"mappings":"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","file":"TokenAuthenticator.js","sourcesContent":["import * as Errors from \"../Errors\";\nimport { FreeResources } from \"../FreeResources\";\nimport { BadResponseError } from \"../HTTP/Errors\";\nimport { Header } from \"../HTTP/Header\";\nimport {\n\tRequestOptions,\n\tRequestService,\n\tRequestUtils,\n} from \"../HTTP/Request\";\nimport { Response } from \"../HTTP/Response\";\nimport { JSONLDParser } from \"../JSONLD/Parser\";\nimport { LDP } from \"../Vocabularies/LDP\";\nimport Context from \"./../Context\";\nimport { ResponseMetadata } from \"../LDP\";\nimport { PersistedDocument } from \"./../PersistedDocument\";\nimport * as RDF from \"../RDF\";\nimport * as Utils from \"./../Utils\";\nimport Authenticator from \"./Authenticator\";\nimport BasicAuthenticator from \"./BasicAuthenticator\";\nimport * as Token from \"./Token\";\nimport * as UsernameAndPasswordToken from \"./UsernameAndPasswordToken\";\n\nexport const TOKEN_CONTAINER:string = \"auth-tokens/\";\n\nexport class Class implements Authenticator<UsernameAndPasswordToken.Class, Token.Class> {\n\n\tprivate context:Context;\n\tprivate basicAuthenticator:BasicAuthenticator;\n\tprivate _credentials:Token.Class;\n\n\tconstructor( context:Context ) {\n\t\tif( context === null ) throw new Errors.IllegalArgumentError( \"context cannot be null\" );\n\n\t\tthis.context = context;\n\t\tthis.basicAuthenticator = new BasicAuthenticator();\n\t}\n\n\tisAuthenticated():boolean {\n\t\treturn ! ! this._credentials && this._credentials.expirationTime > new Date();\n\t}\n\n\tauthenticate( authenticationToken:UsernameAndPasswordToken.Class ):Promise<Token.Class>;\n\tauthenticate( credentials:Token.Class ):Promise<Token.Class>;\n\tauthenticate( authenticationOrCredentials:UsernameAndPasswordToken.Class | Token.Class ):Promise<Token.Class> {\n\t\tif( authenticationOrCredentials instanceof UsernameAndPasswordToken.Class ) return this.basicAuthenticator.authenticate( authenticationOrCredentials ).then( () => {\n\t\t\treturn this.createToken();\n\t\t} ).then( ( [ token, response ]:[ Token.Class, Response ] ):Token.Class => {\n\t\t\tthis.basicAuthenticator.clearAuthentication();\n\t\t\tthis._credentials = token;\n\t\t\treturn token;\n\t\t} );\n\n\t\tlet credentials:Token.Class = <Token.Class> authenticationOrCredentials;\n\t\tif( Utils.isString( credentials.expirationTime ) ) authenticationOrCredentials.expirationTime = new Date( <any> credentials.expirationTime );\n\t\tif( credentials.expirationTime <= new Date() ) return Promise.reject<any>( new Errors.IllegalArgumentError( \"The token provided in not valid.\" ) );\n\n\t\tthis._credentials = credentials;\n\t\treturn Promise.resolve( credentials );\n\t}\n\n\taddAuthentication( requestOptions:RequestOptions ):RequestOptions {\n\t\tlet headers:Map<string, Header> = requestOptions.headers ? requestOptions.headers : requestOptions.headers = new Map<string, Header>();\n\n\t\tthis.addTokenAuthenticationHeader( headers );\n\n\t\treturn requestOptions;\n\t}\n\n\tclearAuthentication():void {\n\t\tthis._credentials = null;\n\t}\n\n\tprivate createToken():Promise<[ Token.Class, Response ]> {\n\t\tlet requestOptions:RequestOptions = {};\n\n\t\tthis.basicAuthenticator.addAuthentication( requestOptions );\n\n\t\tRequestUtils.setAcceptHeader( \"application/ld+json\", requestOptions );\n\t\tRequestUtils.setPreferredInteractionModel( LDP.RDFSource, requestOptions );\n\n\t\treturn Promise.resolve().then( () => {\n\t\t\tconst tokensURI:string = this.context._resolvePath( \"system\" ) + TOKEN_CONTAINER;\n\t\t\treturn RequestService.post( tokensURI, null, requestOptions, new JSONLDParser() );\n\t\t} ).then<[ Token.Class, Response ]>( ( [ expandedResult, response ]:[ any, Response ] ) => {\n\t\t\tlet freeNodes:RDF.Node.Class[] = RDF.Node.Util.getFreeNodes( expandedResult );\n\n\t\t\tlet freeResources:FreeResources = this.context.documents._getFreeResources( freeNodes );\n\t\t\tlet tokenResources:Token.Class[] = <Token.Class[]> freeResources.getResources().filter( resource => resource.hasType( Token.RDF_CLASS ) );\n\n\t\t\tif( tokenResources.length === 0 ) throw new BadResponseError( \"No '\" + Token.RDF_CLASS + \"' was returned.\", response );\n\t\t\tif( tokenResources.length > 1 ) throw new BadResponseError( \"Multiple '\" + Token.RDF_CLASS + \"' were returned. \", response );\n\t\t\tlet token:Token.Class = tokenResources[ 0 ];\n\n\t\t\tlet userDocuments:RDF.Document.Class[] = RDF.Document.Util.getDocuments( expandedResult ).filter( rdfDocument => rdfDocument[ \"@id\" ] === token.user.id );\n\t\t\tuserDocuments.forEach( document => this.context.documents._getPersistedDocument( document, response ) );\n\n\t\t\tconst responseMetadata:ResponseMetadata.Class = <ResponseMetadata.Class> freeResources\n\t\t\t\t.getResources()\n\t\t\t\t.find( ResponseMetadata.Factory.is );\n\n\t\t\tif( responseMetadata ) responseMetadata\n\t\t\t\t.documentsMetadata\n\t\t\t\t.forEach( documentMetadata => {\n\t\t\t\t\tconst document:PersistedDocument = documentMetadata.relatedDocument as PersistedDocument;\n\t\t\t\t\tdocument._eTag = documentMetadata.eTag;\n\t\t\t\t} );\n\n\t\t\treturn [ token, response ];\n\t\t}, response => this.context.documents._parseErrorResponse( response ) );\n\t}\n\n\tprivate addTokenAuthenticationHeader( headers:Map<string, Header> ):void {\n\t\tif( headers.has( \"authorization\" ) ) return;\n\n\t\tlet header:Header = new Header();\n\t\theaders.set( \"authorization\", header );\n\n\t\tlet authorization:string = \"Token \" + this._credentials.key;\n\t\theader.values.push( authorization );\n\t}\n}\n\nexport default Class;\n"]}