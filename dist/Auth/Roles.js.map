{"version":3,"sources":["Auth/Roles.ts"],"names":[],"mappings":"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","file":"Roles.js","sourcesContent":["import {\n\tisString,\n\tMinus,\n\tpromiseMethod,\n} from \"../Utils\";\nimport Context from \"./../Context\";\nimport * as Document from \"./../Document\";\nimport * as Errors from \"./../Errors\";\nimport * as HTTP from \"./../HTTP\";\nimport * as Pointer from \"./../Pointer\";\nimport * as URI from \"./../RDF/URI\";\nimport * as SPARQL from \"./../SPARQL\";\nimport {\n\tQueryDocumentBuilder,\n\tQueryDocumentsBuilder,\n} from \"./../SPARQL/QueryDocument\";\nimport * as PersistedRole from \"./PersistedRole\";\nimport * as PersistedUser from \"./PersistedUser\";\nimport * as Role from \"./Role\";\n\nexport type NewRole = Minus<Role.Class, Document.Class>;\n\nexport class Class {\n\tprivate context:Context;\n\n\tconstructor( context:Context ) {\n\t\tthis.context = context;\n\t}\n\n\t// TODO: Requests must return all the responses made\n\tcreateChild<T extends object>( parentRole:string | Pointer.Class, role:T & NewRole, requestOptions?:HTTP.Request.Options ):Promise<[ T & PersistedRole.Class, HTTP.Response.Class ]>;\n\tcreateChild<T extends object>( parentRole:string | Pointer.Class, role:T & NewRole, slug?:string, requestOptions?:HTTP.Request.Options ):Promise<[ T & PersistedRole.Class, HTTP.Response.Class ]>;\n\tcreateChild<T extends object>( parentRole:string | Pointer.Class, role:T & NewRole, slugOrRequestOptions?:any, requestOptions?:HTTP.Request.Options ):Promise<[ T & PersistedRole.Class, HTTP.Response.Class ]> {\n\t\tconst slug:string = isString( slugOrRequestOptions ) ? slugOrRequestOptions : void 0;\n\t\trequestOptions = HTTP.Request.Util.isOptions( slugOrRequestOptions ) ? slugOrRequestOptions : requestOptions;\n\n\t\tlet parentURI:string = isString( parentRole ) ? parentRole : parentRole.id;\n\t\tconst responses:HTTP.Response.Class[] = [];\n\t\treturn promiseMethod( () => {\n\t\t\tparentURI = this.resolveURI( parentURI );\n\n\t\t\treturn this.context\n\t\t\t\t.documents\n\t\t\t\t.exists( parentURI );\n\t\t} ).then( ( [ exists ] ) => {\n\t\t\tif( ! exists ) throw new Errors.IllegalArgumentError( `The parent role \"${ parentURI }\" doesn't exists.` );\n\n\t\t\tconst container:string = this.resolveURI();\n\t\t\treturn this.context\n\t\t\t\t.documents\n\t\t\t\t.createChild<T>( container, role, slug, requestOptions );\n\t\t} ).then( ( [ document, response ] ) => {\n\t\t\tresponses.push( response );\n\n\t\t\treturn this.context\n\t\t\t\t.documents\n\t\t\t\t.addMember( parentURI, document );\n\t\t} ).then<[ T & PersistedRole.Class, HTTP.Response.Class ]>( () => {\n\t\t\tconst persistedRole:T & PersistedRole.Class = PersistedRole.Factory.decorate( role, this.context.documents );\n\t\t\treturn [ persistedRole, responses[ 0 ] ];\n\t\t} );\n\t}\n\n\tget<T extends object>( roleURI:string, requestOptions?:HTTP.Request.Options, queryBuilderFn?:( queryBuilder:QueryDocumentBuilder.Class ) => QueryDocumentBuilder.Class ):Promise<[ T & PersistedRole.Class, HTTP.Response.Class ]>;\n\tget<T extends object>( roleURI:string, queryBuilderFn?:( queryBuilder:QueryDocumentBuilder.Class ) => QueryDocumentBuilder.Class ):Promise<[ T & PersistedRole.Class, HTTP.Response.Class ]>;\n\tget<T extends object>( roleURI:string, queryBuilderFnOrOptions:any, queryBuilderFn?:( queryBuilder:QueryDocumentBuilder.Class ) => QueryDocumentBuilder.Class ):Promise<[ T & PersistedRole.Class, HTTP.Response.Class ]> {\n\t\treturn promiseMethod( () => {\n\t\t\tconst uri:string = this.resolveURI( roleURI );\n\n\t\t\treturn this.context\n\t\t\t\t.documents\n\t\t\t\t.get<T & PersistedRole.Class>( uri, queryBuilderFnOrOptions, queryBuilderFn );\n\t\t} );\n\t}\n\n\tgetUsers<T extends object>( roleURI:string, requestOptions?:HTTP.Request.Options, queryBuilderFn?:( queryBuilder:QueryDocumentsBuilder.Class ) => QueryDocumentsBuilder.Class ):Promise<[ (T & PersistedUser.Class)[], HTTP.Response.Class ]>;\n\tgetUsers<T extends object>( roleURI:string, queryBuilderFn?:( queryBuilder:QueryDocumentsBuilder.Class ) => QueryDocumentsBuilder.Class ):Promise<[ (T & PersistedUser.Class)[], HTTP.Response.Class ]>;\n\tgetUsers<T extends object>( roleURI:string, queryBuilderFnOrOptions:any, queryBuilderFn?:( queryBuilder:QueryDocumentsBuilder.Class ) => QueryDocumentsBuilder.Class ):Promise<[ (T & PersistedUser.Class)[], HTTP.Response.Class ]> {\n\t\treturn this\n\t\t\t.getUsersAccessPoint( roleURI )\n\t\t\t.then( accessPoint => {\n\t\t\t\treturn this\n\t\t\t\t\t.context\n\t\t\t\t\t.documents\n\t\t\t\t\t.getMembers<T & PersistedUser.Class>( accessPoint.id, queryBuilderFnOrOptions, queryBuilderFn );\n\t\t\t} );\n\t}\n\n\taddUser( roleURI:string, user:Pointer.Class | string, requestOptions?:HTTP.Request.Options ):Promise<HTTP.Response.Class> {\n\t\treturn this.addUsers( roleURI, [ user ], requestOptions );\n\t}\n\n\taddUsers( roleURI:string, users:(Pointer.Class | string)[], requestOptions?:HTTP.Request.Options ):Promise<HTTP.Response.Class> {\n\t\treturn this\n\t\t\t.getUsersAccessPoint( roleURI )\n\t\t\t.then( accessPoint => {\n\t\t\t\treturn this\n\t\t\t\t\t.context\n\t\t\t\t\t.documents\n\t\t\t\t\t.addMembers( accessPoint.id, users, requestOptions );\n\t\t\t} );\n\t}\n\n\tremoveUser( roleURI:string, user:Pointer.Class | string, requestOptions?:HTTP.Request.Options ):Promise<HTTP.Response.Class> {\n\t\treturn this.removeUsers( roleURI, [ user ], requestOptions );\n\t}\n\n\tremoveUsers( roleURI:string, users:(Pointer.Class | string)[], requestOptions?:HTTP.Request.Options ):Promise<HTTP.Response.Class> {\n\t\treturn this\n\t\t\t.getUsersAccessPoint( roleURI )\n\t\t\t.then( ( accessPoint:Pointer.Class ) => {\n\t\t\t\treturn this\n\t\t\t\t\t.context\n\t\t\t\t\t.documents\n\t\t\t\t\t.removeMembers( accessPoint.id, users, requestOptions );\n\t\t\t} );\n\t}\n\n\t// TODO: Optimize\n\tprivate getUsersAccessPoint( roleURI:string ):Promise<Pointer.Class> {\n\t\treturn promiseMethod( () => {\n\t\t\tconst uri:string = this.resolveURI( roleURI );\n\n\t\t\treturn this.context\n\t\t\t\t.documents\n\t\t\t\t.executeSELECTQuery( uri, `PREFIX:<https://carbonldp.com/ns/v1/>SELECT DISTINCT?accessPoint{<${ uri }>:platform#accessPoint?accessPoint.?accessPoint<http://www.w3.org/ns/ldp#hasMemberRelation>:security#user}` );\n\t\t} ).then( ( [ selectResults ]:[ SPARQL.SELECTResults.Class<{ accessPoint:Pointer.Class }>, HTTP.Response.Class ] ) => {\n\t\t\treturn selectResults.bindings[ 0 ].accessPoint;\n\t\t} );\n\t}\n\n\tprivate resolveURI( relativeURI?:string ):string {\n\t\tif( ! this.context.hasSetting( \"system.security.roles.container\" ) ) throw new Errors.IllegalStateError( `The \"system.security.roles.container\" setting hasn't been defined.` );\n\t\tconst containerURI:string = this.context.auth._resolveSecurityURL( this.context.getSetting( \"system.security.roles.container\" ) );\n\n\t\tif( ! relativeURI ) return containerURI;\n\n\t\tconst absoluteURI:string = URI.Util.resolve( containerURI, relativeURI );\n\t\tif( ! absoluteURI.startsWith( containerURI ) ) throw new Errors.IllegalArgumentError( `The URI \"${ relativeURI }\" isn't a valid role URI.` );\n\n\t\treturn absoluteURI;\n\t}\n\n}\n\nexport default Class;\n"]}