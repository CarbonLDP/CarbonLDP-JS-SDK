{"version":3,"sources":["Auth/Roles.ts"],"names":[],"mappings":";AACA,IAAY,MAAM,WAAM,aAAa,CAAC,CAAA;AAEtC,IAAY,IAAI,WAAM,WAAW,CAAC,CAAA;AAIlC,IAAY,0BAA0B,WAAM,iCAAiC,CAAC,CAAA;AAC9E,IAAY,aAAa,WAAM,iBAAiB,CAAC,CAAA;AAGjD,IAAY,GAAG,WAAM,cAAc,CAAC,CAAA;AACpC,IAAY,KAAK,WAAM,YAAY,CAAC,CAAA;AAEpC;IAGC,eAAa,OAAe;QAC3B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACxB,CAAC;IAID,2BAAW,GAAX,UAAgB,UAAiC,EAAE,IAAmB,EAAE,oBAAyB,EAAE,cAAoC;QAAvI,iBA2BC;QA1BA,IAAI,SAAS,GAAU,KAAK,CAAC,QAAQ,CAAE,UAAU,CAAE,GAAY,UAAU,GAAqB,UAAW,CAAC,EAAE,CAAC;QAC7G,IAAI,IAAI,GAAU,KAAK,CAAC,QAAQ,CAAE,oBAAoB,CAAE,GAAG,oBAAoB,GAAG,IAAI,CAAC;QACvF,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAE,oBAAoB,CAAE,GAAG,oBAAoB,GAAG,cAAc,CAAC;QAE7G,IAAI,YAAmB,CAAC;QACxB,IAAI,aAAqC,CAAC;QAC1C,IAAI,eAAmC,CAAC;QACxC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAE,EAAE,CAAE,CAAC,IAAI,CAAE,UAAE,GAAU;YAC9C,YAAY,GAAG,GAAG,CAAC;YAEnB,SAAS,GAAG,GAAG,CAAC,IAAI,CAAC,OAAO,CAAE,YAAY,EAAE,SAAS,CAAE,CAAC;YACxD,EAAE,CAAA,CAAE,CAAE,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAE,YAAY,EAAE,SAAS,CAAG,CAAC;gBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,sEAAsE,CAAE,CAAC;YACrK,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,MAAM,CAAE,SAAS,CAAE,CAAC;QAEnD,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,EAAqD;gBAAnD,cAAM,EAAE,gBAAQ;YAC7B,EAAE,CAAA,CAAE,CAAE,MAAO,CAAC;gBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,0CAA0C,CAAE,CAAC;YACnG,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAK,YAAY,EAAE,IAAI,EAAE,IAAI,EAAE,cAAc,CAAE,CAAC;QAE1F,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,EAA0E;gBAAxE,eAAO,EAAE,gBAAQ;YAC9B,eAAe,GAAG,QAAQ,CAAC;YAC3B,aAAa,GAAG,aAAa,CAAC,OAAO,CAAC,QAAQ,CAAE,OAAO,EAAE,KAAI,CAAE,CAAC;YAChE,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,SAAS,CAAE,SAAS,EAAE,OAAO,CAAE,CAAC;QAE/D,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,iBAAqC;YAChD,MAAM,CAAC,CAAE,aAAa,EAAE,CAAE,eAAe,EAAE,iBAAiB,CAAE,CAAE,CAAC;QAClE,CAAC,CAAE,CAAC;IACL,CAAC;IAID,8BAAc,GAAd,UAAmB,UAAiC,EAAE,KAAwB,EAAE,qBAA0B,EAAE,cAAoC;QAAhJ,iBA2BC;QA1BA,IAAI,SAAS,GAAU,KAAK,CAAC,QAAQ,CAAE,UAAU,CAAE,GAAY,UAAU,GAAqB,UAAW,CAAC,EAAE,CAAC;QAC7G,IAAI,KAAK,GAAY,KAAK,CAAC,OAAO,CAAE,qBAAqB,CAAE,GAAG,qBAAqB,GAAG,IAAI,CAAC;QAC3F,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAE,qBAAqB,CAAE,GAAG,qBAAqB,GAAG,cAAc,CAAC;QAE/G,IAAI,YAAmB,CAAC;QACxB,IAAI,cAA0C,CAAC;QAC/C,IAAI,gBAAsC,CAAC;QAC3C,MAAM,CAAC,IAAI,CAAC,UAAU,CAAE,EAAE,CAAE,CAAC,IAAI,CAAE,UAAE,GAAU;YAC9C,YAAY,GAAG,GAAG,CAAC;YAEnB,SAAS,GAAG,GAAG,CAAC,IAAI,CAAC,OAAO,CAAE,YAAY,EAAE,SAAS,CAAE,CAAC;YACxD,EAAE,CAAA,CAAE,CAAE,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAE,YAAY,EAAE,SAAS,CAAG,CAAC;gBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,sEAAsE,CAAE,CAAC;YACrK,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,MAAM,CAAE,SAAS,CAAE,CAAC;QAEnD,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,EAAqD;gBAAnD,cAAM,EAAE,gBAAQ;YAC7B,EAAE,CAAA,CAAE,CAAE,MAAO,CAAC;gBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,0CAA0C,CAAE,CAAC;YACnG,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,cAAc,CAAK,YAAY,EAAE,KAAK,EAAE,KAAK,EAAE,cAAc,CAAE,CAAC;QAE/F,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,EAAkF;gBAAhF,gBAAQ,EAAE,iBAAS;YAChC,gBAAgB,GAAG,SAAS,CAAC;YAC7B,cAAc,GAAG,QAAQ,CAAC,GAAG,CAAE,UAAA,IAAI,IAAI,OAAA,aAAa,CAAC,OAAO,CAAC,QAAQ,CAAE,IAAI,EAAE,KAAI,CAAE,EAA5C,CAA4C,CAAE,CAAC;YACtF,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU,CAAE,SAAS,EAAE,QAAQ,CAAE,CAAC;QAEjE,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,iBAAqC;YAChD,MAAM,CAAC,CAAE,cAAc,EAAE,gBAAgB,CAAC,MAAM,CAAE,iBAAiB,CAAE,CAAE,CAAC;QACzE,CAAC,CAAE,CAAC;IACL,CAAC;IAID,sCAAsB,GAAtB,UAA2B,UAAiC,EAAE,IAAmB,EAAE,oBAAyB,EAAE,cAAoC;QAAlJ,iBAQC;QAPA,IAAI,eAA4D,CAAC;QACjE,MAAM,CAAC,IAAI,CAAC,WAAW,CAAK,UAAU,EAAE,IAAI,EAAE,oBAAoB,EAAE,cAAc,CAAE,CAAC,IAAI,CAAE,UAAE,EAAiG;gBAA/F,gBAAQ,EAAE,iBAAS;YACjH,eAAe,GAAG,SAAS,CAAC;YAC5B,MAAM,CAAC,KAAI,CAAC,GAAG,CAAK,QAAQ,CAAC,EAAE,CAAE,CAAC;QACnC,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,EAA6F;gBAA3F,yBAAiB,EAAE,gBAAQ;YACxC,MAAM,CAAC,CAAE,iBAAiB,EAAE,eAAe,CAAC,MAAM,CAAE,QAAQ,CAAE,CAAE,CAAC;QAClE,CAAC,CAAE,CAAC;IACL,CAAC;IAID,yCAAyB,GAAzB,UAA8B,UAAiC,EAAE,KAAwB,EAAE,qBAA0B,EAAE,cAAoC;QAA3J,iBA2BC;QA1BA,IAAI,SAAS,GAAU,KAAK,CAAC,QAAQ,CAAE,UAAU,CAAE,GAAY,UAAU,GAAqB,UAAW,CAAC,EAAE,CAAC;QAC7G,IAAI,KAAK,GAAY,KAAK,CAAC,OAAO,CAAE,qBAAqB,CAAE,GAAG,qBAAqB,GAAG,IAAI,CAAC;QAC3F,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAE,qBAAqB,CAAE,GAAG,qBAAqB,GAAG,cAAc,CAAC;QAE/G,IAAI,YAAmB,CAAC;QACxB,IAAI,cAA0C,CAAC;QAC/C,IAAI,gBAAmE,CAAC;QACxE,MAAM,CAAC,IAAI,CAAC,UAAU,CAAE,EAAE,CAAE,CAAC,IAAI,CAAE,UAAE,GAAU;YAC9C,YAAY,GAAG,GAAG,CAAC;YAEnB,SAAS,GAAG,GAAG,CAAC,IAAI,CAAC,OAAO,CAAE,YAAY,EAAE,SAAS,CAAE,CAAC;YACxD,EAAE,CAAA,CAAE,CAAE,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAE,YAAY,EAAE,SAAS,CAAG,CAAC;gBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,sEAAsE,CAAE,CAAC;YACrK,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,MAAM,CAAE,SAAS,CAAE,CAAC;QAEnD,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,EAAqD;gBAAnD,cAAM,EAAE,gBAAQ;YAC7B,EAAE,CAAA,CAAE,CAAE,MAAO,CAAC;gBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,0CAA0C,CAAE,CAAC;YACnG,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,yBAAyB,CAAK,YAAY,EAAE,KAAK,EAAE,KAAK,EAAE,cAAc,CAAE,CAAC;QAE1G,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,EAA6G;gBAA3G,gBAAQ,EAAE,iBAAS;YAChC,gBAAgB,GAAG,SAAS,CAAC;YAC7B,cAAc,GAAG,QAAQ,CAAC,GAAG,CAAE,UAAA,IAAI,IAAI,OAAA,aAAa,CAAC,OAAO,CAAC,QAAQ,CAAE,IAAI,EAAE,KAAI,CAAE,EAA5C,CAA4C,CAAE,CAAC;YACtF,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU,CAAE,SAAS,EAAE,QAAQ,CAAE,CAAC;QAEjE,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,iBAAqC;YAChD,MAAM,CAAC,CAAE,cAAc,EAAE,gBAAgB,CAAC,MAAM,CAAE,iBAAiB,CAAE,CAAE,CAAC;QACzE,CAAC,CAAE,CAAC;IACL,CAAC;IAED,mBAAG,GAAH,UAAQ,OAAc,EAAE,cAAoC;QAA5D,iBAIC;QAHA,MAAM,CAAC,IAAI,CAAC,UAAU,CAAE,OAAO,CAAE,CAAC,IAAI,CAAE,UAAE,GAAU;YACnD,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,CAA2B,GAAG,EAAE,cAAc,CAAE,CAAC;QACnF,CAAC,CAAE,CAAC;IACL,CAAC;IAED,0BAAU,GAAV,UAAY,OAAc,EAAE,cAAoC;QAAhE,iBAMC;QALA,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAE,OAAO,CAAE,CAAC,IAAI,CAAE,UAAE,iBAA+B;YAClF,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,WAAW,CAAE,iBAAiB,CAAC,EAAE,EAAE,cAAc,CAAE,CAAC;QACnF,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,EAAuE;gBAArE,cAAM,EAAE,gBAAQ;YAC7B,MAAM,CAAC,CAAE,MAAM,CAAC,GAAG,CAAE,UAAA,KAAK,IAAI,OAAA,0BAA0B,CAAC,OAAO,CAAC,QAAQ,CAAE,KAAK,CAAE,EAApD,CAAoD,CAAE,EAAE,QAAQ,CAAE,CAAC;QAClG,CAAC,CAAE,CAAC;IACL,CAAC;IAID,yBAAS,GAAT,UAAc,OAAc,EAAE,oCAAgE,EAAE,cAAoC;QAApI,iBAIC;QAHA,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAE,OAAO,CAAE,CAAC,IAAI,CAAE,UAAE,iBAA+B;YAClF,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU,CAAK,iBAAiB,CAAC,EAAE,EAAE,oCAAoC,EAAE,cAAc,CAAE,CAAC;QAC3H,CAAC,CAAE,CAAC;IACL,CAAC;IAED,wBAAQ,GAAR,UAAU,OAAc,EAAE,KAA4B,EAAE,cAAoC;QAC3F,MAAM,CAAC,IAAI,CAAC,SAAS,CAAE,OAAO,EAAE,CAAE,KAAK,CAAE,EAAE,cAAc,CAAE,CAAC;IAC7D,CAAC;IAED,yBAAS,GAAT,UAAW,OAAc,EAAE,MAAiC,EAAE,cAAoC;QAAlG,iBAIC;QAHA,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAE,OAAO,CAAE,CAAC,IAAI,CAAE,UAAE,iBAA+B;YAClF,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU,CAAE,iBAAiB,CAAC,EAAE,EAAE,MAAM,EAAE,cAAc,CAAE,CAAC;QAC1F,CAAC,CAAE,CAAC;IACL,CAAC;IAED,2BAAW,GAAX,UAAa,OAAc,EAAE,KAA4B,EAAE,cAAoC;QAC9F,MAAM,CAAC,IAAI,CAAC,YAAY,CAAE,OAAO,EAAE,CAAE,KAAK,CAAE,EAAE,cAAc,CAAE,CAAC;IAChE,CAAC;IAED,4BAAY,GAAZ,UAAc,OAAc,EAAE,MAAiC,EAAE,cAAoC;QAArG,iBAIC;QAHA,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAE,OAAO,CAAE,CAAC,IAAI,CAAE,UAAE,iBAA+B;YAClF,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,aAAa,CAAE,iBAAiB,CAAC,EAAE,EAAE,MAAM,EAAE,cAAc,CAAE,CAAC;QAC7F,CAAC,CAAE,CAAC;IACL,CAAC;IAEO,0BAAU,GAAlB,UAAoB,QAAe;QAAnC,iBASC;QARA,MAAM,CAAC,IAAI,OAAO,CAAU,UAAE,OAA8B;YAC3D,IAAI,YAAY,GAAU,KAAI,CAAC,OAAO,CAAC,OAAO,CAAE,KAAI,CAAC,eAAe,EAAE,CAAE,CAAC;YACzE,IAAI,GAAG,GAAU,GAAG,CAAC,IAAI,CAAC,OAAO,CAAE,YAAY,EAAE,QAAQ,CAAE,CAAC;YAE5D,EAAE,CAAA,CAAE,CAAE,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAE,YAAY,EAAE,GAAG,CAAG,CAAC;gBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,8DAA8D,CAAE,CAAC;YAEvJ,OAAO,CAAE,GAAG,CAAE,CAAC;QAChB,CAAC,CAAE,CAAC;IACL,CAAC;IAGO,oCAAoB,GAA5B,UAA8B,OAAc;QAA5C,iBASC;QARA,MAAM,CAAC,IAAI,CAAC,UAAU,CAAE,OAAO,CAAE,CAAC,IAAI,CAAE,UAAE,GAAU;YACnD,MAAM,CAAC,KAAI,CAAC,OAAO,CAAC,SAAS,CAAC,kBAAkB,CAAE,GAAG,EAAE,2DAClD,GAAG,+MAEN,CAAE,CAAC;QACN,CAAC,CAAE,CAAC,IAAI,CAAE,UAAE,EAA+E;gBAA7E,qBAAa,EAAE,gBAAQ;YACpC,MAAM,CAAiB,aAAa,CAAC,QAAQ,CAAE,CAAC,CAAE,CAAE,mBAAmB,CAAE,CAAC;QAC3E,CAAC,CAAE,CAAC;IACL,CAAC;IAEO,+BAAe,GAAvB;QACC,EAAE,CAAA,CAAE,CAAE,IAAI,CAAC,OAAO,CAAC,UAAU,CAAE,0BAA0B,CAAG,CAAC;YAAC,MAAM,IAAI,MAAM,CAAC,iBAAiB,CAAE,mDAAmD,CAAE,CAAC;QACxJ,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAE,0BAA0B,CAAE,CAAC;IAC9D,CAAC;IAEF,YAAC;AAAD,CAtLA,AAsLC,IAAA;AAtLqB,aAAK,QAsL1B,CAAA;AAED;kBAAe,KAAK,CAAC","file":"Roles.js","sourcesContent":["import Context from \"./../Context\";\nimport * as Errors from \"./../Errors\";\nimport * as Pointer from \"./../Pointer\";\nimport * as HTTP from \"./../HTTP\";\nimport * as PersistedAgent from \"./../Auth/PersistedAgent\";\nimport * as PersistedDocument from \"./../PersistedDocument\";\nimport * as RetrievalPreferences from \"./../RetrievalPreferences\";\nimport * as PersistedProtectedDocument from \"./../PersistedProtectedDocument\";\nimport * as PersistedRole from \"./PersistedRole\";\nimport * as Role from \"./Role\";\nimport * as SPARQL from \"./../SPARQL\";\nimport * as URI from \"./../RDF/URI\";\nimport * as Utils from \"./../Utils\";\n\nexport abstract class Class {\n\tprivate context:Context;\n\n\tconstructor( context:Context ) {\n\t\tthis.context = context;\n\t}\n\n\tcreateChild<T>( parentRole:string | Pointer.Class, role:T & Role.Class, requestOptions?:HTTP.Request.Options ):Promise<[ T & PersistedRole.Class, [ HTTP.Response.Class, HTTP.Response.Class ] ]>;\n\tcreateChild<T>( parentRole:string | Pointer.Class, role:T & Role.Class, slug?:string, requestOptions?:HTTP.Request.Options ):Promise<[ T & PersistedRole.Class, [ HTTP.Response.Class, HTTP.Response.Class ] ]>;\n\tcreateChild<T>( parentRole:string | Pointer.Class, role:T & Role.Class, slugOrRequestOptions?:any, requestOptions?:HTTP.Request.Options ):Promise<[ T & PersistedRole.Class, [ HTTP.Response.Class, HTTP.Response.Class ] ]> {\n\t\tlet parentURI:string = Utils.isString( parentRole ) ? <string> parentRole : ( <Pointer.Class> parentRole).id;\n\t\tlet slug:string = Utils.isString( slugOrRequestOptions ) ? slugOrRequestOptions : null;\n\t\trequestOptions = HTTP.Request.Util.isOptions( slugOrRequestOptions ) ? slugOrRequestOptions : requestOptions;\n\n\t\tlet containerURI:string;\n\t\tlet persistedRole:T & PersistedRole.Class;\n\t\tlet responseCreated:HTTP.Response.Class;\n\t\treturn this.resolveURI( \"\" ).then( ( uri:string ) => {\n\t\t\tcontainerURI = uri;\n\n\t\t\tparentURI = URI.Util.resolve( containerURI, parentURI );\n\t\t\tif( ! URI.Util.isBaseOf( containerURI, parentURI ) ) throw new Errors.IllegalArgumentError( \"The parent role provided is not a valid role of the current context.\" );\n\t\t\treturn this.context.documents.exists( parentURI );\n\n\t\t} ).then( ( [ exists, response ]:[ boolean, HTTP.Response.Class ] ) => {\n\t\t\tif( ! exists ) throw new Errors.IllegalArgumentError( \"The parent role provided does not exist.\" );\n\t\t\treturn this.context.documents.createChild<T>( containerURI, role, slug, requestOptions );\n\n\t\t} ).then( ( [ newRole, response ]:[ T & PersistedDocument.Class, HTTP.Response.Class ] ) => {\n\t\t\tresponseCreated = response;\n\t\t\tpersistedRole = PersistedRole.Factory.decorate( newRole, this );\n\t\t\treturn this.context.documents.addMember( parentURI, newRole );\n\n\t\t} ).then( ( responseAddMember:HTTP.Response.Class ) => {\n\t\t\treturn [ persistedRole, [ responseCreated, responseAddMember ] ];\n\t\t} );\n\t}\n\n\tcreateChildren<T>( parentRole:string | Pointer.Class, roles:(T & Role.Class)[], requestOptions?:HTTP.Request.Options ):Promise<[ (T & PersistedRole.Class)[], HTTP.Response.Class[] ]>;\n\tcreateChildren<T>( parentRole:string | Pointer.Class, roles:(T & Role.Class)[], slugs?:string[], requestOptions?:HTTP.Request.Options ):Promise<[ (T & PersistedRole.Class)[], HTTP.Response.Class[] ]>;\n\tcreateChildren<T>( parentRole:string | Pointer.Class, roles:(T & Role.Class)[], slugsOrRequestOptions?:any, requestOptions?:HTTP.Request.Options ):Promise<[ (T & PersistedRole.Class)[], HTTP.Response.Class[] ]> {\n\t\tlet parentURI:string = Utils.isString( parentRole ) ? <string> parentRole : ( <Pointer.Class> parentRole).id;\n\t\tlet slugs:string[] = Utils.isArray( slugsOrRequestOptions ) ? slugsOrRequestOptions : null;\n\t\trequestOptions = HTTP.Request.Util.isOptions( slugsOrRequestOptions ) ? slugsOrRequestOptions : requestOptions;\n\n\t\tlet containerURI:string;\n\t\tlet persistedRoles:(T & PersistedRole.Class)[];\n\t\tlet responsesCreated:HTTP.Response.Class[];\n\t\treturn this.resolveURI( \"\" ).then( ( uri:string ) => {\n\t\t\tcontainerURI = uri;\n\n\t\t\tparentURI = URI.Util.resolve( containerURI, parentURI );\n\t\t\tif( ! URI.Util.isBaseOf( containerURI, parentURI ) ) throw new Errors.IllegalArgumentError( \"The parent role provided is not a valid role of the current context.\" );\n\t\t\treturn this.context.documents.exists( parentURI );\n\n\t\t} ).then( ( [ exists, response ]:[ boolean, HTTP.Response.Class ] ) => {\n\t\t\tif( ! exists ) throw new Errors.IllegalArgumentError( \"The parent role provided does not exist.\" );\n\t\t\treturn this.context.documents.createChildren<T>( containerURI, roles, slugs, requestOptions );\n\n\t\t} ).then( ( [ newRoles, responses ]:[ (T & PersistedDocument.Class)[], HTTP.Response.Class[] ] ) => {\n\t\t\tresponsesCreated = responses;\n\t\t\tpersistedRoles = newRoles.map( role => PersistedRole.Factory.decorate( role, this ) );\n\t\t\treturn this.context.documents.addMembers( parentURI, newRoles );\n\n\t\t} ).then( ( responseAddMember:HTTP.Response.Class ) => {\n\t\t\treturn [ persistedRoles, responsesCreated.concat( responseAddMember ) ];\n\t\t} );\n\t}\n\n\tcreateChildAndRetrieve<T>( parentRole:string | Pointer.Class, role:T & Role.Class, slug?:string, requestOptions?:HTTP.Request.Options ):Promise<[ T & PersistedRole.Class, [ HTTP.Response.Class, HTTP.Response.Class, HTTP.Response.Class ] ]>;\n\tcreateChildAndRetrieve<T>( parentRole:string | Pointer.Class, role:T & Role.Class, requestOptions?:HTTP.Request.Options ):Promise<[ T & PersistedRole.Class, [ HTTP.Response.Class, HTTP.Response.Class, HTTP.Response.Class ] ]>;\n\tcreateChildAndRetrieve<T>( parentRole:string | Pointer.Class, role:T & Role.Class, slugOrRequestOptions?:any, requestOptions?:HTTP.Request.Options ):Promise<[ T & PersistedRole.Class, [ HTTP.Response.Class, HTTP.Response.Class, HTTP.Response.Class ] ]> {\n\t\tlet createResponses:[ HTTP.Response.Class, HTTP.Response.Class ];\n\t\treturn this.createChild<T>( parentRole, role, slugOrRequestOptions, requestOptions ).then( ( [ document, responses ]:[ T & PersistedRole.Class, [ HTTP.Response.Class, HTTP.Response.Class ] ] ) => {\n\t\t\tcreateResponses = responses;\n\t\t\treturn this.get<T>( document.id );\n\t\t} ).then( ( [ persistedDocument, response ]:[ T & PersistedProtectedDocument.Class, HTTP.Response.Class ] ) => {\n\t\t\treturn [ persistedDocument, createResponses.concat( response ) ];\n\t\t} );\n\t}\n\n\tcreateChildrenAndRetrieve<T>( parentRole:string | Pointer.Class, roles:(T & Role.Class)[], requestOptions?:HTTP.Request.Options ):Promise<[ (T & PersistedRole.Class)[], [ HTTP.Response.Class[], HTTP.Response.Class[], HTTP.Response.Class ] ]>;\n\tcreateChildrenAndRetrieve<T>( parentRole:string | Pointer.Class, roles:(T & Role.Class)[], slugs?:string[], requestOptions?:HTTP.Request.Options ):Promise<[ (T & PersistedRole.Class)[], [ HTTP.Response.Class[], HTTP.Response.Class[], HTTP.Response.Class ] ]>;\n\tcreateChildrenAndRetrieve<T>( parentRole:string | Pointer.Class, roles:(T & Role.Class)[], slugsOrRequestOptions?:any, requestOptions?:HTTP.Request.Options ):Promise<[ (T & PersistedRole.Class)[], [ HTTP.Response.Class[], HTTP.Response.Class[], HTTP.Response.Class ] ]> {\n\t\tlet parentURI:string = Utils.isString( parentRole ) ? <string> parentRole : ( <Pointer.Class> parentRole).id;\n\t\tlet slugs:string[] = Utils.isArray( slugsOrRequestOptions ) ? slugsOrRequestOptions : null;\n\t\trequestOptions = HTTP.Request.Util.isOptions( slugsOrRequestOptions ) ? slugsOrRequestOptions : requestOptions;\n\n\t\tlet containerURI:string;\n\t\tlet persistedRoles:(T & PersistedRole.Class)[];\n\t\tlet responsesCreated: ( HTTP.Response.Class[] | HTTP.Response.Class )[];\n\t\treturn this.resolveURI( \"\" ).then( ( uri:string ) => {\n\t\t\tcontainerURI = uri;\n\n\t\t\tparentURI = URI.Util.resolve( containerURI, parentURI );\n\t\t\tif( ! URI.Util.isBaseOf( containerURI, parentURI ) ) throw new Errors.IllegalArgumentError( \"The parent role provided is not a valid role of the current context.\" );\n\t\t\treturn this.context.documents.exists( parentURI );\n\n\t\t} ).then( ( [ exists, response ]:[ boolean, HTTP.Response.Class ] ) => {\n\t\t\tif( ! exists ) throw new Errors.IllegalArgumentError( \"The parent role provided does not exist.\" );\n\t\t\treturn this.context.documents.createChildrenAndRetrieve<T>( containerURI, roles, slugs, requestOptions );\n\n\t\t} ).then( ( [ newRoles, responses ]:[ (T & PersistedDocument.Class)[], [ HTTP.Response.Class[], HTTP.Response.Class[] ] ] ) => {\n\t\t\tresponsesCreated = responses;\n\t\t\tpersistedRoles = newRoles.map( role => PersistedRole.Factory.decorate( role, this ) );\n\t\t\treturn this.context.documents.addMembers( parentURI, newRoles );\n\n\t\t} ).then( ( responseAddMember:HTTP.Response.Class ) => {\n\t\t\treturn [ persistedRoles, responsesCreated.concat( responseAddMember ) ];\n\t\t} );\n\t}\n\n\tget<T>( roleURI:string, requestOptions?:HTTP.Request.Options ):Promise<[ T & PersistedRole.Class, HTTP.Response.Class ]> {\n\t\treturn this.resolveURI( roleURI ).then( ( uri:string ) => {\n\t\t\treturn this.context.documents.get<T & PersistedRole.Class>( uri, requestOptions );\n\t\t} );\n\t}\n\n\tlistAgents( roleURI:string, requestOptions?:HTTP.Request.Options ):Promise<[ PersistedProtectedDocument.Class[], HTTP.Response.Class ]> {\n\t\treturn this.getAgentsAccessPoint( roleURI ).then( ( agentsAccessPoint:Pointer.Class ) => {\n\t\t\treturn this.context.documents.listMembers( agentsAccessPoint.id, requestOptions );\n\t\t} ).then( ( [ agents, response ]:[ PersistedDocument.Class[], HTTP.Response.Class ] ) => {\n\t\t\treturn [ agents.map( agent => PersistedProtectedDocument.Factory.decorate( agent ) ), response ];\n\t\t} );\n\t}\n\n\tgetAgents<T>( roleURI:string, requestOptions?:HTTP.Request.Options ):Promise<[ (T & PersistedAgent.Class)[], HTTP.Response.Class ]>;\n\tgetAgents<T>( roleURI:string, retrievalPreferences?:RetrievalPreferences.Class, requestOptions?:HTTP.Request.Options ):Promise<[ (T & PersistedAgent.Class)[], HTTP.Response.Class ]>;\n\tgetAgents<T>( roleURI:string, retrievalPreferencesOrRequestOptions?:RetrievalPreferences.Class, requestOptions?:HTTP.Request.Options ):Promise<[ (T & PersistedAgent.Class)[], HTTP.Response.Class ]> {\n\t\treturn this.getAgentsAccessPoint( roleURI ).then( ( agentsAccessPoint:Pointer.Class ) => {\n\t\t\treturn this.context.documents.getMembers<T>( agentsAccessPoint.id, retrievalPreferencesOrRequestOptions, requestOptions );\n\t\t} );\n\t}\n\n\taddAgent( roleURI:string, agent:Pointer.Class | string, requestOptions?:HTTP.Request.Options ):Promise<HTTP.Response.Class> {\n\t\treturn this.addAgents( roleURI, [ agent ], requestOptions );\n\t}\n\n\taddAgents( roleURI:string, agents:(Pointer.Class | string)[], requestOptions?:HTTP.Request.Options ):Promise<HTTP.Response.Class> {\n\t\treturn this.getAgentsAccessPoint( roleURI ).then( ( agentsAccessPoint:Pointer.Class ) => {\n\t\t\treturn this.context.documents.addMembers( agentsAccessPoint.id, agents, requestOptions );\n\t\t} );\n\t}\n\n\tremoveAgent( roleURI:string, agent:Pointer.Class | string, requestOptions?:HTTP.Request.Options ):Promise<HTTP.Response.Class> {\n\t\treturn this.removeAgents( roleURI, [ agent ], requestOptions );\n\t}\n\n\tremoveAgents( roleURI:string, agents:(Pointer.Class | string)[], requestOptions?:HTTP.Request.Options ):Promise<HTTP.Response.Class> {\n\t\treturn this.getAgentsAccessPoint( roleURI ).then( ( agentsAccessPoint:Pointer.Class ) => {\n\t\t\treturn this.context.documents.removeMembers( agentsAccessPoint.id, agents, requestOptions );\n\t\t} );\n\t}\n\n\tprivate resolveURI( agentURI:string ):Promise<string> {\n\t\treturn new Promise<string>( ( resolve:( uri:string ) => void ) => {\n\t\t\tlet containerURI:string = this.context.resolve( this.getContainerURI() );\n\t\t\tlet uri:string = URI.Util.resolve( containerURI, agentURI );\n\n\t\t\tif( ! URI.Util.isBaseOf( containerURI, uri ) ) throw new Errors.IllegalArgumentError( \"The URI provided is not a valid role of the current context.\" );\n\n\t\t\tresolve( uri );\n\t\t} );\n\t}\n\n\t// TODO: Optimize\n\tprivate getAgentsAccessPoint( roleURI:string ):Promise<Pointer.Class> {\n\t\treturn this.resolveURI( roleURI ).then( ( uri:string ) => {\n\t\t\treturn this.context.documents.executeSELECTQuery( uri, ` select distinct ?agentsAccessPoint where {\n\t\t\t\t<${ uri }> <https://carbonldp.com/ns/v1/platform#accessPoint> ?agentsAccessPoint .\n\t\t\t\t?agentsAccessPoint <http://www.w3.org/ns/ldp#hasMemberRelation> <https://carbonldp.com/ns/v1/security#agent> .\n\t\t\t}` );\n\t\t} ).then( ( [ selectResults, response ]:[ SPARQL.SELECTResults.Class, HTTP.Response.Class ] ) => {\n\t\t\treturn <Pointer.Class> selectResults.bindings[ 0 ][ \"agentsAccessPoint\" ];\n\t\t} );\n\t}\n\n\tprivate getContainerURI():string {\n\t\tif( ! this.context.hasSetting( \"platform.roles.container\" ) ) throw new Errors.IllegalStateError( \"The roles container setting hasn't been declared.\" );\n\t\treturn this.context.getSetting( \"platform.roles.container\" );\n\t}\n\n}\n\nexport default Class;\n"]}