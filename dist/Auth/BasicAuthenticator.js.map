{"version":3,"sources":["Auth/BasicAuthenticator.ts"],"names":[],"mappings":";;;;;;;;;AAAA,gDAAoC;AACpC,yCAAwC;AAGxC,+FAAmF;AAGnF;IAAA;IA2CA,CAAC;IAxCA,+BAAe,GAAf;QACC,MAAM,CAAC,CAAE,CAAE,IAAI,CAAC,WAAW,CAAC;IAC7B,CAAC;IAED,4BAAY,GAAZ,UAAc,mBAAkD;QAAhE,iBAWC;QAVA,EAAE,CAAA,CAAE,mBAAmB,KAAK,IAAK,CAAC;YAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,yCAAyC,CAAE,CAAC;QAEtH,MAAM,CAAC,IAAI,OAAO,CAAwC,UAAE,OAA8B,EAAE,MAA4B;YACvH,EAAE,CAAA,CAAE,CAAE,mBAAmB,CAAC,QAAS,CAAC;gBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,+BAA+B,CAAE,CAAC;YAC9G,EAAE,CAAA,CAAE,CAAE,mBAAmB,CAAC,QAAS,CAAC;gBAAC,MAAM,IAAI,MAAM,CAAC,oBAAoB,CAAE,+BAA+B,CAAE,CAAC;YAE9G,KAAI,CAAC,WAAW,GAAG,IAAI,8BAA8B,CAAC,KAAK,CAAE,mBAAmB,CAAC,QAAQ,EAAE,mBAAmB,CAAC,QAAQ,CAAE,CAAC;YAE1H,OAAO,CAAE,KAAI,CAAC,WAAW,CAAE,CAAC;QAC7B,CAAC,CAAE,CAAC;IACL,CAAC;IAED,iCAAiB,GAAjB,UAAmB,cAA6B;QAC/C,EAAE,CAAA,CAAE,CAAE,IAAI,CAAC,eAAe,EAAG,CAAC;YAAC,MAAM,IAAI,MAAM,CAAC,iBAAiB,CAAE,wCAAwC,CAAE,CAAC;QAE9G,IAAI,OAAO,GAAuB,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,GAAG,IAAI,GAAG,EAAkB,CAAC;QAEvI,IAAI,CAAC,4BAA4B,CAAE,OAAO,CAAE,CAAC;QAE7C,MAAM,CAAC,cAAc,CAAC;IACvB,CAAC;IAED,mCAAmB,GAAnB;QACC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;IACzB,CAAC;IAEO,4CAA4B,GAApC,UAAsC,OAA2B;QAChE,EAAE,CAAA,CAAE,OAAO,CAAC,GAAG,CAAE,eAAe,CAAG,CAAC;YAAC,MAAM,CAAC;QAE5C,IAAI,MAAM,GAAU,IAAI,eAAM,EAAE,CAAC;QACjC,OAAO,CAAC,GAAG,CAAE,eAAe,EAAE,MAAM,CAAE,CAAC;QAEvC,IAAI,aAAa,GAAU,QAAQ,GAAG,KAAK,CAAE,IAAI,CAAC,WAAW,CAAC,QAAQ,GAAG,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAE,CAAC;QAC3G,MAAM,CAAC,MAAM,CAAC,IAAI,CAAE,aAAa,CAAE,CAAC;IACrC,CAAC;IACF,YAAC;AAAD,CA3CA,AA2CC,IAAA;AA3CY,sBAAK;AA6ClB,eAAgB,GAAU;IACzB,MAAM,CAAC,CAAE,OAAO,IAAI,KAAK,WAAW,CAAE,CAAC,CAAC,CAAC,IAAI,CAAE,GAAG,CAAE,CAAC,CAAC,CAAC,IAAI,MAAM,CAAE,GAAG,CAAE,CAAC,QAAQ,CAAE,QAAQ,CAAE,CAAC;AAC/F,CAAC;AAED,kBAAe,KAAK,CAAC","file":"BasicAuthenticator.js","sourcesContent":["import * as Errors from \"../Errors\";\nimport { Header } from \"../HTTP/Header\";\nimport { RequestOptions } from \"../HTTP/Request\";\nimport Authenticator from \"./Authenticator\";\nimport * as UsernameAndPasswordCredentials from \"./UsernameAndPasswordCredentials\";\nimport * as UsernameAndPasswordToken from \"./UsernameAndPasswordToken\";\n\nexport class Class implements Authenticator<UsernameAndPasswordToken.Class, UsernameAndPasswordCredentials.Class> {\n\tprivate credentials:UsernameAndPasswordCredentials.Class;\n\n\tisAuthenticated():boolean {\n\t\treturn ! ! this.credentials;\n\t}\n\n\tauthenticate( authenticationToken:UsernameAndPasswordToken.Class ):Promise<UsernameAndPasswordCredentials.Class> {\n\t\tif( authenticationToken === null ) throw new Errors.IllegalArgumentError( \"The authenticationToken cannot be null.\" );\n\n\t\treturn new Promise<UsernameAndPasswordCredentials.Class>( ( resolve:( result:any ) => void, reject:( error:any ) => void ) => {\n\t\t\tif( ! authenticationToken.username ) throw new Errors.IllegalArgumentError( \"The username cannot be empty.\" );\n\t\t\tif( ! authenticationToken.password ) throw new Errors.IllegalArgumentError( \"The password cannot be empty.\" );\n\n\t\t\tthis.credentials = new UsernameAndPasswordCredentials.Class( authenticationToken.username, authenticationToken.password );\n\n\t\t\tresolve( this.credentials );\n\t\t} );\n\t}\n\n\taddAuthentication( requestOptions:RequestOptions ):RequestOptions {\n\t\tif( ! this.isAuthenticated() ) throw new Errors.IllegalStateError( \"The authenticator isn't authenticated.\" );\n\n\t\tlet headers:Map<string, Header> = requestOptions.headers ? requestOptions.headers : requestOptions.headers = new Map<string, Header>();\n\n\t\tthis.addBasicAuthenticationHeader( headers );\n\n\t\treturn requestOptions;\n\t}\n\n\tclearAuthentication():void {\n\t\tthis.credentials = null;\n\t}\n\n\tprivate addBasicAuthenticationHeader( headers:Map<string, Header> ):void {\n\t\tif( headers.has( \"authorization\" ) ) return;\n\n\t\tlet header:Header = new Header();\n\t\theaders.set( \"authorization\", header );\n\n\t\tlet authorization:string = \"Basic \" + toB64( this.credentials.username + \":\" + this.credentials.password );\n\t\theader.values.push( authorization );\n\t}\n}\n\nfunction toB64( str:string ):string {\n\treturn ( typeof btoa !== \"undefined\" ) ? btoa( str ) : new Buffer( str ).toString( \"base64\" );\n}\n\nexport default Class;\n"]}