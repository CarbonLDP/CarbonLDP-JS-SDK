{"version":3,"sources":["PersistedProtectedDocument.ts"],"names":[],"mappings":";;;;;;;;;AAAA,2CAA+B;AAE/B,2CAA+B;AAE/B,qEAAyD;AAGzD,6CAAiC;AACjC,wCAAuC;AAQvC;IAAA;IAgCA,CAAC;IA9BO,0BAAkB,GAAzB,UAA2B,MAAa;QACvC,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAE,MAAM,CAAE;eAC3B,KAAK,CAAC,WAAW,CAAE,MAAM,EAAE,QAAQ,CAAE,CACvC;IACH,CAAC;IAEM,UAAE,GAAT,UAAW,MAAa;QACvB,MAAM,CAAC,OAAO,CAAC,kBAAkB,CAAE,MAAM,CAAE;eACvC,iBAAiB,CAAC,OAAO,CAAC,EAAE,CAAE,MAAM,CAAE,CACxC;IACH,CAAC;IAEM,gBAAQ,GAAf,UAAmC,QAAU,EAAE,SAAmB;QACjE,IAAM,0BAA0B,GAAa,QAAqB,CAAC;QAEnE,EAAE,CAAA,CAAE,OAAO,CAAC,kBAAkB,CAAE,QAAQ,CAAG,CAAC;YAAC,MAAM,CAAC,0BAA0B,CAAC;QAC/E,iBAAiB,CAAC,OAAO,CAAC,QAAQ,CAAE,QAAQ,EAAE,SAAS,CAAE,CAAC;QAE1D,MAAM,CAAC,gBAAgB,CAAE,0BAA0B,EAAE;YACpD,QAAQ,EAAE;gBACT,QAAQ,EAAE,KAAK;gBACf,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;gBAClB,KAAK,EAAE,MAAM;aACb;SACD,CAAE,CAAC;QAEJ,MAAM,CAAC,0BAA0B,CAAC;IACnC,CAAC;IAEF,cAAC;AAAD,CAhCA,AAgCC,IAAA;AAhCY,0BAAO;AAsCpB,gBAAiB,cAAoC;IACpD,IAAI,iBAAiB,GAAiB,IAAI,CAAC;IAE3C,IAAI,UAA2B,CAAC;IAEhC,EAAE,CAAA,CAAE,iBAAiB,CAAC,UAAU,EAAG,CAAC,CAAC,CAAC;QACrC,UAAU,GAAG,OAAO,CAAC,OAAO,CAAE,iBAAiB,CAAC,iBAAiB,CAAE,CAAC;IACrE,CAAC;IAAC,IAAI,CAAC,CAAC;QACP,UAAU,GAAG,iBAAiB,CAAC,kBAAkB,CAAa,iCACzD,iBAAiB,CAAC,EAAE,WAAQ,OAAE,CAAC,iBAAiB,mBACnD,CAAE,CAAC,IAAI,CAAE,UAAE,EAAkD;gBAAhD,eAAO;YACrB,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAE,CAAC,CAAE,CAAC,GAAG,CAAC;QAClC,CAAC,CAAE,CAAC;IACL,CAAC;IAED,MAAM,CAAC,UAAU,CAAC,IAAI,CAAE,UAAE,GAAW;QACpC,MAAM,CAAC,iBAAiB,CAAC,UAAU,CAAC,GAAG,CAAE,GAAG,CAAC,EAAE,EAAE,cAAc,CAAE,CAAC;IACnE,CAAC,CAAE,CAAC,IAAI,CAAyC,UAAE,EAAuD;YAArD,WAAG,EAAE,gBAAQ;QACjE,EAAE,CAAA,CAAE,CAAE,GAAG,CAAC,OAAO,CAAE,IAAI,CAAC,GAAG,CAAC,SAAS,CAAG,CAAC;YAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAE,sCAAqC,IAAI,CAAC,GAAG,CAAC,SAAS,aAAW,EAAE,QAAQ,CAAE,CAAC;QACjK,MAAM,CAAC,CAAE,GAAG,EAAE,QAAQ,CAAE,CAAC;IAC1B,CAAC,CAAE,CAAC;AACL,CAAC","file":"PersistedProtectedDocument.js","sourcesContent":["import * as Auth from \"./Auth\";\nimport { Documents } from \"./Documents\";\nimport * as HTTP from \"./HTTP\";\nimport { Response } from \"./HTTP/Response\";\nimport * as PersistedDocument from \"./PersistedDocument\";\nimport { Pointer } from \"./Pointer\";\nimport SELECTResults from \"./SPARQL/SELECTResults\";\nimport * as Utils from \"./Utils\";\nimport { CS } from \"./Vocabularies/CS\";\n\nexport interface Class extends PersistedDocument.Class {\n\taccessControlList?:Pointer;\n\n\tgetACL( requestOptions?:HTTP.Request.Options ):Promise<[ Auth.PersistedACL.Class, Response ]>;\n}\n\nexport class Factory {\n\n\tstatic hasClassProperties( object:Object ):boolean {\n\t\treturn Utils.isObject( object )\n\t\t\t&& Utils.hasFunction( object, \"getACL\" )\n\t\t\t;\n\t}\n\n\tstatic is( object:Object ):boolean {\n\t\treturn Factory.hasClassProperties( object )\n\t\t\t&& PersistedDocument.Factory.is( object )\n\t\t\t;\n\t}\n\n\tstatic decorate<T extends object>( document:T, documents:Documents ):T & Class {\n\t\tconst persistedProtectedDocument:T & Class = document as T & Class;\n\n\t\tif( Factory.hasClassProperties( document ) ) return persistedProtectedDocument;\n\t\tPersistedDocument.Factory.decorate( document, documents );\n\n\t\tObject.defineProperties( persistedProtectedDocument, {\n\t\t\t\"getACL\": {\n\t\t\t\twritable: false,\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: getACL,\n\t\t\t},\n\t\t} );\n\n\t\treturn persistedProtectedDocument;\n\t}\n\n}\n\ninterface ACLResult {\n\tacl:Pointer;\n}\n\nfunction getACL( requestOptions?:HTTP.Request.Options ):Promise<[ Auth.PersistedACL.Class, Response ]> {\n\tlet protectedDocument:Class = <Class> this;\n\n\tlet aclPromise:Promise<Pointer>;\n\n\tif( protectedDocument.isResolved() ) {\n\t\taclPromise = Promise.resolve( protectedDocument.accessControlList );\n\t} else {\n\t\taclPromise = protectedDocument.executeSELECTQuery<ACLResult>( `SELECT ?acl WHERE {\n\t\t\t<${ protectedDocument.id }> <${ CS.accessControlList }> ?acl.\n\t\t}` ).then( ( [ results ]:[ SELECTResults<ACLResult>, Response ] ) => {\n\t\t\treturn results.bindings[ 0 ].acl;\n\t\t} );\n\t}\n\n\treturn aclPromise.then( ( acl:Pointer ) => {\n\t\treturn protectedDocument._documents.get( acl.id, requestOptions );\n\t} ).then<[ Auth.PersistedACL.Class, Response ]>( ( [ acl, response ]:[ Auth.PersistedACL.Class, Response ] ) => {\n\t\tif( ! acl.hasType( Auth.ACL.RDF_CLASS ) ) throw new HTTP.Errors.BadResponseError( `The response does not contains a ${ Auth.ACL.RDF_CLASS } object.`, response );\n\t\treturn [ acl, response ];\n\t} );\n}\n\nexport default Class;\n"]}