{"version":3,"sources":["QueryDocuments/QueryContextBuilder.ts"],"names":[],"mappings":"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","file":"QueryContextBuilder.js","sourcesContent":["import { AbstractContext } from \"../Context\";\nimport { IllegalArgumentError } from \"../Errors\";\nimport {\n\tDigestedObjectSchema,\n\tDigestedObjectSchemaProperty,\n\tObjectSchemaDigester,\n\tObjectSchemaUtils,\n} from \"../ObjectSchema\";\nimport { QueryContext } from \"./QueryContext\";\nimport {\n\tQueryProperty,\n\tQueryPropertyType,\n} from \"./QueryProperty\";\nimport {\n\tgetLevelRegExp,\n\tgetParentPath,\n} from \"./Utils\";\n\nexport class QueryContextBuilder extends QueryContext {\n\n\tprivate _propertiesMap:Map<string, QueryProperty>;\n\tprivate _schemas:DigestedObjectSchema[];\n\n\tconstructor( context?:AbstractContext<any, any, any> ) {\n\t\tsuper( context );\n\t\tthis._propertiesMap = new Map();\n\t}\n\n\thasProperty( name:string ):boolean {\n\t\treturn this._propertiesMap.has( name );\n\t}\n\n\thasProperties( name:string ):boolean {\n\t\tconst levelRegex:RegExp = getLevelRegExp( name );\n\t\treturn Array.from( this._propertiesMap.keys() )\n\t\t\t.some( propertyName => levelRegex.test( propertyName ) );\n\t}\n\n\taddProperty( name:string ):QueryProperty {\n\t\tconst property:QueryProperty = new QueryProperty( this, name, );\n\t\tthis._propertiesMap.set( name, property );\n\t\treturn property;\n\t}\n\n\tgetProperty( name:string ):QueryProperty {\n\t\treturn this._propertiesMap.get( name );\n\t}\n\n\tgetProperties( name:string ):QueryProperty[] {\n\t\tconst levelRegex:RegExp = getLevelRegExp( name );\n\t\treturn Array.from( this._propertiesMap.entries() )\n\t\t\t.filter( ( [ propertyName ] ) => levelRegex.test( propertyName ) )\n\t\t\t.map( ( [ propertyName, property ] ) => property );\n\t}\n\n\tgetInheritTypeDefinition( existingSchema:DigestedObjectSchema, propertyName:string, propertyURI?:string ):DigestedObjectSchemaProperty {\n\t\tconst schemas:DigestedObjectSchema[] = [ existingSchema, ...this._getTypeSchemas() ];\n\n\t\tfor( const schema of schemas ) {\n\t\t\tif( ! schema.properties.has( propertyName ) ) continue;\n\n\t\t\tconst mergeSchema:DigestedObjectSchema = ObjectSchemaDigester.combineDigestedObjectSchemas( [ existingSchema, schema ] );\n\t\t\tconst digestedProperty:DigestedObjectSchemaProperty = ObjectSchemaUtils.resolveProperty( mergeSchema, schema.properties.get( propertyName ) );\n\n\t\t\tif( ! propertyURI || propertyURI === digestedProperty.uri ) return digestedProperty;\n\t\t}\n\t}\n\n\thasSchemaFor( object:object, path?:string ):boolean {\n\t\tif( path === void 0 ) return super.hasSchemaFor( object );\n\t\tif( ! this.hasProperty( path ) ) return false;\n\n\t\tconst type:QueryPropertyType = this\n\t\t\t.getProperty( path )\n\t\t\t.getType();\n\n\t\treturn type !== void 0 && type !== QueryPropertyType.EMPTY;\n\t}\n\n\tgetSchemaFor( object:object, path?:string ):DigestedObjectSchema {\n\t\tif( path === void 0 ) return super.getSchemaFor( object );\n\n\t\tconst property:QueryProperty = this.getProperty( path );\n\t\tif( property ) {\n\t\t\tswitch( property.getType() ) {\n\t\t\t\tcase QueryPropertyType.PARTIAL:\n\t\t\t\t\treturn this.getProperty( path ).getSchema();\n\n\t\t\t\tcase QueryPropertyType.FULL:\n\t\t\t\tcase QueryPropertyType.ALL:\n\t\t\t\t\treturn super.getSchemaFor( object );\n\n\t\t\t\tcase QueryPropertyType.EMPTY:\n\t\t\t\t\treturn new DigestedObjectSchema();\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalArgumentError( `Property \"${ path }\" is not a resource.` );\n\t\t\t}\n\t\t}\n\n\t\tconst parent:QueryProperty = this.getProperty( getParentPath( path ) );\n\t\tif( ! parent || parent.getType() !== QueryPropertyType.FULL )\n\t\t\tthrow new IllegalArgumentError( `Schema path \"${ path }\" does not exists.` );\n\n\t\treturn super.getSchemaFor( object );\n\t}\n\n\tprivate _getTypeSchemas():DigestedObjectSchema[] {\n\t\tif( this._schemas ) return this._schemas;\n\n\t\treturn this._schemas = this.context ?\n\t\t\tthis.context._getTypeObjectSchemas() :\n\t\t\t[];\n\t}\n\n}\n"]}