{"version":3,"sources":["QueryDocuments/QueryableMetadata.ts"],"names":[],"mappings":";;AAAA,uEAAsE;AAEtE,6EAA4E;AAI5E;IAMC,2BAAa,MAA2B,EAAE,eAAkC;QAC3E,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,CAAE,eAAe,CAAC,CAAC,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,2CAAoB,EAAE,EAAE,MAAM,CAAE,CAAC;IAClH,CAAC;IAEO,wCAAY,GAApB,UAAsB,SAA8B,EAAE,SAA8B;QACnF,IAAI,SAAS,KAAK,iBAAiB,CAAC,GAAG,IAAI,SAAS,KAAK,iBAAiB,CAAC,GAAG;YAAG,OAAO,iBAAiB,CAAC,GAAG,CAAC;QAE9G,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAE,UAAE,MAAM,EAAE,SAAS;YAC9C,MAAM,GAAG,SAAS,CAAC,UAAU,CAAE,MAAM,CAAE,CAAC;YACxC,IAAI,CAAE,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAE,SAAS,CAAE;gBAAG,OAAO,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAE,SAAS,EAAE,MAAM,CAAE,CAAC;YAE/F,IAAM,MAAM,GAAU,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAE,SAAS,CAAE,CAAC;YAC1D,IAAI,MAAM,KAAK,MAAM;gBAAG,MAAM,IAAI,2CAAoB,CAAE,cAAY,SAAS,kCAA6B,MAAM,cAAS,MAAM,QAAK,CAAE,CAAC;QACxI,CAAC,CAAE,CAAC;QAEJ,SAAS,CAAC,UAAU,CAAC,OAAO,CAAE,UAAE,aAAa,EAAE,YAAY;YAC1D,IAAI,CAAE,SAAS,CAAC,UAAU,CAAC,GAAG,CAAE,YAAY,CAAE;gBAAG,OAAO,SAAS,CAAC,UAAU,CAAC,GAAG,CAAE,YAAY,EAAE,aAAa,CAAE,CAAC;YAEhH,IAAM,aAAa,GAAgC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAE,YAAY,CAAE,CAAC;YAC5F,KAAK,IAAM,GAAG,IAAI,aAAa,EAAG;gBACjC,IAAM,QAAQ,GAAO,aAAa,CAAE,GAAG,CAAE,CAAC;gBAC1C,IAAM,QAAQ,GAAO,aAAa,CAAE,GAAG,CAAE,CAAC;gBAE1C,IAAI,QAAQ,KAAK,QAAQ;oBAAG,MAAM,IAAI,2CAAoB,CAAE,gBAAc,YAAY,2BAAsB,GAAG,cAAS,QAAQ,cAAS,QAAQ,QAAK,CAAE,CAAC;aACzJ;QACF,CAAC,CAAE,CAAC;QAEJ,OAAO,SAAS,CAAC;IAClB,CAAC;IAhCe,qBAAG,GAAkC,MAAM,CAAC,MAAM,CAAE,IAAI,2CAAoB,EAAE,CAAE,CAAC;IAkClG,wBAAC;CApCD,AAoCC,IAAA;AApCY,8CAAiB","file":"QueryableMetadata.js","sourcesContent":["import { IllegalArgumentError } from \"../Errors/IllegalArgumentError\";\n\nimport { DigestedObjectSchema } from \"../ObjectSchema/DigestedObjectSchema\";\nimport { DigestedObjectSchemaProperty } from \"../ObjectSchema/DigestedObjectSchemaProperty\";\n\n\nexport class QueryableMetadata {\n\n\tstatic readonly ALL:Readonly<DigestedObjectSchema> = Object.freeze( new DigestedObjectSchema() );\n\n\treadonly schema:DigestedObjectSchema;\n\n\tconstructor( schema:DigestedObjectSchema, previousPartial?:QueryableMetadata ) {\n\t\tthis.schema = this.mergeSchemas( previousPartial ? previousPartial.schema : new DigestedObjectSchema(), schema );\n\t}\n\n\tprivate mergeSchemas( oldSchema:DigestedObjectSchema, newSchema:DigestedObjectSchema ):DigestedObjectSchema {\n\t\tif( newSchema === QueryableMetadata.ALL || oldSchema === QueryableMetadata.ALL ) return QueryableMetadata.ALL;\n\n\t\tnewSchema.prefixes.forEach( ( newURI, namespace ) => {\n\t\t\tnewURI = newSchema.resolveURI( newURI );\n\t\t\tif( ! oldSchema.prefixes.has( namespace ) ) return oldSchema.prefixes.set( namespace, newURI );\n\n\t\t\tconst oldURI:string = oldSchema.prefixes.get( namespace );\n\t\t\tif( oldURI !== newURI ) throw new IllegalArgumentError( `Prefix \"${ namespace }\" has different value: \"${ oldURI }\", \"${ newURI }\".` );\n\t\t} );\n\n\t\tnewSchema.properties.forEach( ( newDefinition, propertyName ) => {\n\t\t\tif( ! oldSchema.properties.has( propertyName ) ) return oldSchema.properties.set( propertyName, newDefinition );\n\n\t\t\tconst oldDefinition:DigestedObjectSchemaProperty = oldSchema.properties.get( propertyName );\n\t\t\tfor( const key in newDefinition ) {\n\t\t\t\tconst newValue:any = newDefinition[ key ];\n\t\t\t\tconst oldValue:any = oldDefinition[ key ];\n\n\t\t\t\tif( newValue !== oldValue ) throw new IllegalArgumentError( `Property \"${ propertyName }\" has different \"${ key }\": \"${ oldValue }\", \"${ newValue }\".` );\n\t\t\t}\n\t\t} );\n\n\t\treturn oldSchema;\n\t}\n\n}\n"]}