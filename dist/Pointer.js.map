{"version":3,"sources":["Pointer.ts"],"names":[],"mappings":"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","file":"Pointer.js","sourcesContent":["import * as Errors from \"./Errors\";\nimport * as HTTP from \"./HTTP\";\nimport * as PersistedDocument from \"./PersistedDocument\";\nimport * as Utils from \"./Utils\";\n\nexport interface Class {\n\t_id:string;\n\t_resolved:boolean;\n\n\tid:string;\n\tisResolved():boolean;\n\tresolve<T>():Promise<[ T & PersistedDocument.Class, HTTP.Response.Class ]>;\n}\n\nexport interface Library {\n\thasPointer( id:string ):boolean;\n\tgetPointer( id:string ):Class;\n}\n\nexport class Factory {\n\tstatic hasClassProperties( object:Object ):boolean {\n\t\treturn (\n\t\t\tUtils.hasPropertyDefined( object, \"_id\" ) &&\n\t\t\tUtils.hasPropertyDefined( object, \"_resolved\" ) &&\n\n\t\t\tUtils.hasPropertyDefined( object, \"id\" ) &&\n\t\t\tUtils.hasFunction( object, \"isResolved\" ) &&\n\t\t\tUtils.hasPropertyDefined( object, \"resolve\" )\n\t\t);\n\t}\n\n\tstatic is( value:any ):boolean {\n\t\treturn (\n\t\t\tUtils.isObject( value ) &&\n\t\t\tFactory.hasClassProperties( value )\n\t\t);\n\t}\n\n\tstatic create( id?:string ):Class {\n\t\treturn Factory.createFrom( {}, id );\n\t}\n\n\tstatic createFrom<T extends Object>( object:T, id?:string ):T & Class {\n\t\tconst pointer:T & Class = object as T & Class;\n\t\tpointer.id = id || pointer.id;\n\n\t\treturn Factory.decorate<T>( pointer );\n\t}\n\n\tstatic decorate<T extends Object>( object:T ):T & Class {\n\t\tconst pointer:T & Class = object as T & Class;\n\t\tif( Factory.hasClassProperties( object ) ) return pointer;\n\n\t\tObject.defineProperties( pointer, {\n\t\t\t\"_id\": {\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: pointer.id,\n\t\t\t},\n\t\t\t\"_resolved\": {\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: ! ! (pointer._resolved as boolean | null),\n\t\t\t},\n\t\t\t\"id\": {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function():string {\n\t\t\t\t\tif( ! this._id ) return \"\";\n\t\t\t\t\treturn this._id || \"\";\n\t\t\t\t},\n\t\t\t\tset: function( value:string ):void {\n\t\t\t\t\tthis._id = value;\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"isResolved\": {\n\t\t\t\twritable: false,\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function():boolean {\n\t\t\t\t\treturn this._resolved;\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"resolve\": {\n\t\t\t\twritable: false,\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: function():Promise<[ Class, HTTP.Response.Class ]> {\n\t\t\t\t\treturn Promise.reject<any>( new Errors.NotImplementedError( \"A simple pointer cannot be resolved by it self.\" ) );\n\t\t\t\t},\n\t\t\t},\n\t\t} );\n\n\t\treturn pointer;\n\t}\n}\n\nexport class Util {\n\tstatic areEqual( pointer1:Class, pointer2:Class ):boolean {\n\t\treturn pointer1.id === pointer2.id;\n\t}\n\n\tstatic getIDs( pointers:Class[] ):string[] {\n\t\tlet ids:string[] = [];\n\t\tfor( let pointer of pointers ) {\n\t\t\tids.push( pointer.id );\n\t\t}\n\t\treturn ids;\n\t}\n\n\tstatic resolveAll<T>( pointers:Class[] ):Promise<[ (T & PersistedDocument.Class)[], HTTP.Response.Class[] ]> {\n\t\tlet promises:Promise<[ T & PersistedDocument.Class, HTTP.Response.Class ]>[] = pointers.map( ( pointer:Class ) => pointer.resolve<T>() );\n\t\treturn Promise.all<[ T & PersistedDocument.Class, HTTP.Response.Class ]>( promises ).then( ( results:[ T & PersistedDocument.Class, HTTP.Response.Class ][] ) => {\n\t\t\tlet resolvedPointers:(T & PersistedDocument.Class)[] = results.map( ( result:[ T & PersistedDocument.Class, HTTP.Response.Class ] ) => result[ 0 ] );\n\t\t\tlet responses:HTTP.Response.Class[] = results.map( ( result:[ T & PersistedDocument.Class, HTTP.Response.Class ] ) => result[ 1 ] );\n\n\t\t\treturn [ resolvedPointers, responses ];\n\t\t} );\n\t}\n}\n\nexport interface Validator {\n\tinScope( id:string ):boolean;\n\tinScope( pointer:Class ):boolean;\n}\n\nexport default Class;\n"]}