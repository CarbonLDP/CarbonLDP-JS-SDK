{"version":3,"sources":["SPARQL/QueryDocument/Utils.ts"],"names":[],"mappings":"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","file":"Utils.js","sourcesContent":["import {\n\tFilterToken,\n\tGraphToken,\n\tIRIToken,\n\tOptionalToken,\n\tPatternToken,\n\tPredicateToken,\n\tPrefixedNameToken,\n\tSubjectToken,\n\tVariableToken\n} from \"sparqler/tokens\";\n\nimport { DigestedObjectSchemaProperty } from \"../../ObjectSchema\";\nimport { isObject } from \"../../Utils\";\nimport { QueryContext } from \"./QueryContext\";\n\nexport function getLevelRegExp( property:string ):RegExp {\n\tif( property ) property += \".\";\n\tconst parsedName:string = property.replace( /\\./g, \"\\\\.\" );\n\n\treturn new RegExp( `^${ parsedName }[^.]+$` );\n}\n\nexport function createPropertyPatterns( context:QueryContext, resourcePath:string, propertyPath:string, propertyDefinition:DigestedObjectSchemaProperty ):PatternToken[] {\n\tconst { uri, literalType, pointerType } = propertyDefinition;\n\n\tconst propertyIRI:IRIToken | PrefixedNameToken = context.compactIRI( uri );\n\n\tconst resource:VariableToken = context.getVariable( resourcePath );\n\tconst propertyObject:VariableToken = context.getVariable( propertyPath );\n\n\tconst propertyPatterns:PatternToken[] = [ new SubjectToken( resource )\n\t\t.addPredicate( new PredicateToken( propertyIRI )\n\t\t\t.addObject( propertyObject ) ),\n\t];\n\n\tif( literalType !== null ) propertyPatterns\n\t\t.push( new FilterToken( `datatype( ${ propertyObject } ) = ${ context.compactIRI( literalType ) }` ) );\n\tif( pointerType !== null ) propertyPatterns\n\t\t.push( new FilterToken( `! isLiteral( ${ propertyObject } )` ) );\n\n\treturn propertyPatterns;\n}\n\nexport function createTypesPattern( context:QueryContext, resourcePath:string ):PatternToken {\n\treturn new OptionalToken()\n\t\t.addPattern( new SubjectToken( context.getVariable( resourcePath ) )\n\t\t\t.addPredicate( new PredicateToken( \"a\" )\n\t\t\t\t.addObject( context.getVariable( `${ resourcePath }.types` ) )\n\t\t\t)\n\t\t);\n}\n\nexport function createGraphPattern( context:QueryContext, resourcePath:string ):PatternToken {\n\treturn new GraphToken( context.getVariable( resourcePath ) )\n\t\t.addPattern( new SubjectToken( context.getVariable( `${ resourcePath }._subject` ) )\n\t\t\t.addPredicate( new PredicateToken( context.getVariable( `${ resourcePath }._predicate` ) )\n\t\t\t\t.addObject( context.getVariable( `${ resourcePath }._object` ) ) )\n\t\t)\n\t\t;\n}\n\nexport function createAllPattern( context:QueryContext, resourcePath:string ):PatternToken {\n\treturn new SubjectToken( context.getVariable( resourcePath ) )\n\t\t.addPredicate( new PredicateToken( context.getVariable( `${ resourcePath }._predicate` ) )\n\t\t\t.addObject( context.getVariable( `${ resourcePath }._object` ) )\n\t\t)\n\t\t;\n}\n\nexport function getParentPath( path:string ):string {\n\treturn path\n\t\t.split( \".\" )\n\t\t.slice( 0, - 1 )\n\t\t.join( \".\" )\n\t\t;\n}\n\nexport function isFullTriple( triple:SubjectToken ):boolean {\n\treturn triple\n\t\t.predicates\n\t\t.map( x => x.predicate )\n\t\t.some( x => isObject( x ) && x.token === \"variable\" )\n\t\t;\n}\n\nexport function getAllTriples( patterns:PatternToken[] ):SubjectToken[] {\n\tconst subjectsMap:Map<string, SubjectToken> = new Map();\n\tinternalTripleAdder( subjectsMap, patterns );\n\n\treturn Array.from( subjectsMap.values() );\n}\n\nfunction internalTripleAdder( subjectsMap:Map<string, SubjectToken>, patterns:PatternToken[] ):void {\n\tpatterns.forEach( ( pattern:PatternToken ) => {\n\t\tif( pattern.token === \"optional\" || pattern.token === \"graph\" )\n\t\t\treturn internalTripleAdder( subjectsMap, pattern.patterns );\n\n\t\tif( pattern.token !== \"subject\" ) return;\n\n\t\tconst valid:boolean = pattern.predicates\n\t\t\t.map( predicate => predicate.objects )\n\t\t\t.some( objects => objects.some( object => object.token === \"variable\" ) );\n\n\t\tif( valid ) {\n\t\t\tconst subject:SubjectToken = getSubject( subjectsMap, pattern );\n\t\t\tif( isFullTriple( subject ) ) return;\n\n\t\t\tif( isFullTriple( pattern ) ) subject.predicates.length = 0;\n\t\t\tsubject.predicates.push( ...pattern.predicates );\n\t\t}\n\t} );\n}\n\nfunction getSubject( subjectsMap:Map<string, SubjectToken>, original:SubjectToken ):SubjectToken {\n\tconst subjectStr:string = original.subject.toString();\n\tif( subjectsMap.has( subjectStr ) ) return subjectsMap.get( subjectStr );\n\n\tconst subject:SubjectToken = new SubjectToken( original.subject );\n\tsubjectsMap.set( subjectStr, subject );\n\n\treturn subject;\n}\n\nexport function getResourcesVariables( patterns:PatternToken[] ):VariableToken[] {\n\tconst resourcesVariables:Set<VariableToken> = new Set<VariableToken>();\n\tpatterns.forEach( pattern => {\n\t\tif( pattern.token === \"optional\" )\n\t\t\tgetResourcesVariables( pattern.patterns )\n\t\t\t\t.forEach( resourcesVariables.add, resourcesVariables );\n\n\t\tif( pattern.token === \"graph\" && pattern.graph.token === \"variable\" )\n\t\t\tresourcesVariables.add( pattern.graph );\n\n\t\tif( pattern.token !== \"subject\" ) return;\n\t\tif( pattern.subject.token !== \"variable\" ) return;\n\n\t\tconst predicate:PredicateToken = pattern.predicates\n\t\t\t.find( p => p.predicate === \"a\" || p.predicate.token === \"variable\" );\n\n\t\tif( predicate )\n\t\t\tresourcesVariables.add( pattern.subject );\n\t} );\n\n\treturn Array.from( resourcesVariables );\n}\n\nexport function getPathProperty( element:any, path:string ):any {\n\tif( element === void 0 || ! path ) return element;\n\n\tconst [ propName, ...restParts ] = path.split( \".\" );\n\n\tconst property:any = element[ propName ];\n\tconst restPath:string = restParts.join( \".\" );\n\n\treturn getPathProperty( property, restPath );\n}\n\nexport function areDifferentType( a:any, b:any ):boolean {\n\tif( typeof a !== typeof b ) return true;\n\tif( typeof a === \"object\" ) return a instanceof Date !== b instanceof Date;\n\n\treturn false;\n}\n"]}