{"version":3,"sources":["SPARQL/QueryDocument/QueryValue.ts"],"names":[],"mappings":";;AAAA,oCAA0C;AAC1C,0CAA+C;AAE/C,0EAAyE;AACzE,qCAAqC;AACrC,8CAA6C;AAG7C;IAMC,oBAAa,OAAoB,EAAE,KAAsC;QACxE,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;QACpB,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAExB,EAAE,CAAA,CAAE,cAAM,CAAE,KAAK,CAAG,CAAC,CAAC,CAAC;YACtB,IAAI,CAAC,QAAQ,GAAG,IAAI,qBAAY,EAAE,CAAC;YACnC,IAAI,CAAC,QAAQ,CAAE,SAAG,CAAC,QAAQ,CAAE,CAAC;QAC/B,CAAC;QAAC,IAAI,CAAC,CAAC;YACP,IAAI,CAAC,QAAQ,GAAG,IAAI,qBAAY,CAAE,KAAK,CAAE,CAAC;QAC3C,CAAC;IACF,CAAC;IAED,6BAAQ,GAAR,UAAU,IAAW;QACpB,EAAE,CAAA,CAAE,CAAE,gBAAU,CAAE,IAAI,CAAG,CAAC,CAAC,CAAC;YAC3B,EAAE,CAAA,CAAE,CAAE,SAAG,CAAC,cAAc,CAAE,IAAI,CAAG,CAAC;gBAAC,MAAM,IAAI,2CAAoB,CAAE,wBAAwB,CAAE,CAAC;YAC9F,IAAI,GAAG,SAAG,CAAE,IAAI,CAAE,CAAC;QACpB,CAAC;QACD,IAAM,KAAK,GAAU,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAE,IAAI,EAAE,IAAI,CAAC,MAAM,CAAE,CAAC;QACzE,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAE,KAAK,CAAE,CAAC;QAChC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAE,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAE,IAAI,CAAE,CAAE,CAAC;QAE1D,MAAM,CAAC,IAAI,CAAC;IACb,CAAC;IAED,iCAAY,GAAZ,UAAc,QAAe;QAC5B,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAE,QAAQ,CAAE,CAAC;QAEtC,MAAM,CAAC,IAAI,CAAC;IACb,CAAC;IAED,6BAAQ,GAAR;QACC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;IACtB,CAAC;IAED,6BAAQ,GAAR;QACC,MAAM,CAAC,KAAI,IAAI,CAAC,QAAW,CAAC;IAC7B,CAAC;IACF,iBAAC;AAAD,CA3CA,AA2CC,IAAA;AA3CY,gCAAU;AA6CvB,kBAAe,UAAU,CAAC","file":"QueryValue.js","sourcesContent":["import { isAbsolute } from \"sparqler/iri\";\nimport { LiteralToken } from \"sparqler/tokens\";\n\nimport { IllegalArgumentError } from \"../../Errors/IllegalArgumentError\";\nimport { isDate } from \"../../Utils\";\nimport { XSD } from \"../../Vocabularies/XSD\";\nimport { QueryContext } from \"./QueryContext\";\n\nexport class QueryValue {\n\tprivate _value:string | number | boolean | Date;\n\n\tprivate _literal:LiteralToken;\n\tprivate _context:QueryContext;\n\n\tconstructor( context:QueryContext, value:string | number | boolean | Date ) {\n\t\tthis._value = value;\n\t\tthis._context = context;\n\n\t\tif( isDate( value ) ) {\n\t\t\tthis._literal = new LiteralToken();\n\t\t\tthis.withType( XSD.dateTime );\n\t\t} else {\n\t\t\tthis._literal = new LiteralToken( value );\n\t\t}\n\t}\n\n\twithType( type:string ):this {\n\t\tif( ! isAbsolute( type ) ) {\n\t\t\tif( ! XSD.hasOwnProperty( type ) ) throw new IllegalArgumentError( \"Invalid type provided.\" );\n\t\t\ttype = XSD[ type ];\n\t\t}\n\t\tconst value:string = this._context.serializeLiteral( type, this._value );\n\t\tthis._literal.setValue( value );\n\t\tthis._literal.setType( this._context.compactIRI( type ) );\n\n\t\treturn this;\n\t}\n\n\twithLanguage( language:string ):this {\n\t\tthis._literal.setLanguage( language );\n\n\t\treturn this;\n\t}\n\n\tgetToken():LiteralToken {\n\t\treturn this._literal;\n\t}\n\n\ttoString():string {\n\t\treturn `${ this._literal }`;\n\t}\n}\n\nexport default QueryValue;\n\n\n\n"]}