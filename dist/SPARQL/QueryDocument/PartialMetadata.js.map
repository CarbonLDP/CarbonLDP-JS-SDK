{"version":3,"sources":["SPARQL/QueryDocument/PartialMetadata.ts"],"names":[],"mappings":"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","file":"PartialMetadata.js","sourcesContent":["import { DigestedObjectSchema, DigestedPropertyDefinition } from \"../../ObjectSchema\";\nimport { IRIToken, LiteralToken, OptionalToken, PredicateToken, PrefixedNameToken, PrefixToken, SubjectToken, VariableToken } from \"sparqler/tokens\";\nimport { M as MUtils } from \"../../Utils\";\nimport * as URI from \"../../RDF/URI\";\nimport { IllegalArgumentError } from \"../../Errors\";\n\nexport class Class {\n\treadonly schema:DigestedObjectSchema;\n\treadonly query:OptionalToken[];\n\n\tconstructor( schema:DigestedObjectSchema, query:OptionalToken[], partialData?:Class ) {\n\t\tthis.schema = partialData ? this.mergeSchemas( partialData.schema, schema ) : schema;\n\t\tthis.query = partialData ? this.mergeQueries( partialData.query, query ) : query;\n\t}\n\n\tprivate mergeSchemas( oldSchema:DigestedObjectSchema, newSchema:DigestedObjectSchema ):DigestedObjectSchema {\n\t\toldSchema.prefixes.forEach( ( oldURI, namespace ) => {\n\t\t\tif( ! newSchema.prefixes.has( namespace ) ) return newSchema.prefixes.set( namespace, oldURI );\n\n\t\t\tconst newURI:URI.Class = newSchema.prefixes.get( namespace );\n\t\t\tif( newURI.stringValue !== oldURI.stringValue ) throw new IllegalArgumentError( `Prefix \"${ namespace }\" has different values: \"${ oldURI.stringValue }\", \"${ newURI.stringValue }\"` );\n\t\t} );\n\n\t\toldSchema.properties.forEach( ( oldDefinition, propertyName ) => {\n\t\t\tif( ! newSchema.properties.has( propertyName ) ) return newSchema.properties.set( propertyName, oldDefinition );\n\n\t\t\tconst newDefinition:DigestedPropertyDefinition = newSchema.properties.get( propertyName );\n\t\t\tfor( const definitionProperty in newDefinition ) {\n\t\t\t\tconst newValue:any = newDefinition[ definitionProperty ] instanceof URI.Class ? newDefinition[ definitionProperty ].stringValue : newDefinition[ definitionProperty ];\n\t\t\t\tconst oldValue:any = oldDefinition[ definitionProperty ] instanceof URI.Class ? oldDefinition[ definitionProperty ].stringValue : oldDefinition[ definitionProperty ];\n\n\t\t\t\tif( newValue !== oldValue ) throw new IllegalArgumentError( `Property \"${ propertyName }\" has different \"${ propertyName }\": \"${ oldValue }\", \"${ newValue }\"` );\n\t\t\t}\n\t\t} );\n\n\t\treturn newSchema;\n\t}\n\n\tprivate mergeQueries( oldQuery:OptionalToken[], newQuery:OptionalToken[] ):OptionalToken[] {\n\t\tconst getPredicate:( optional:OptionalToken ) => string = optional =>\n\t\t\t`${ ( optional.patterns[ 0 ] as SubjectToken ).predicates[ 0 ] }`;\n\n\t\tconst newPredicates:Set<string> = new Set( newQuery.map( getPredicate ) );\n\n\t\toldQuery.forEach( optional => {\n\t\t\tconst oldPredicate:string = getPredicate( optional );\n\t\t\tif( ! newPredicates.has( oldPredicate ) ) newQuery.push( optional );\n\t\t} );\n\n\t\treturn newQuery;\n\t}\n\n}\n\nexport default Class;\n"]}