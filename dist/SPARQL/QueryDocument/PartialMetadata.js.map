{"version":3,"sources":["SPARQL/QueryDocument/PartialMetadata.ts"],"names":[],"mappings":";;AAAA,uCAAoD;AACpD,mDAG4B;AAC5B,mCAAqC;AAExB,QAAA,GAAG,GAAkC,MAAM,CAAC,MAAM,CAAE,IAAI,mCAAoB,EAAE,CAAE,CAAC;AAE9F;IAGC,eAAa,MAA2B,EAAE,eAAsB;QAC/D,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,CAAE,eAAe,CAAC,CAAC,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,mCAAoB,EAAE,EAAE,MAAM,CAAE,CAAC;IAClH,CAAC;IAEO,4BAAY,GAApB,UAAsB,SAA8B,EAAE,SAA8B;QACnF,EAAE,CAAA,CAAE,SAAS,KAAK,WAAG,IAAI,SAAS,KAAK,WAAI,CAAC;YAAC,MAAM,CAAC,WAAG,CAAC;QAExD,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAE,UAAE,MAAM,EAAE,SAAS;YAC9C,EAAE,CAAA,CAAE,CAAE,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAE,SAAS,CAAG,CAAC;gBAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAE,SAAS,EAAE,MAAM,CAAE,CAAC;YAE/F,IAAM,MAAM,GAAa,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAE,SAAS,CAAE,CAAC;YAC7D,EAAE,CAAA,CAAE,MAAM,CAAC,WAAW,KAAK,MAAM,CAAC,WAAY,CAAC;gBAAC,MAAM,IAAI,6BAAoB,CAAE,cAAY,SAAS,mCAA8B,MAAM,CAAC,WAAW,cAAS,MAAM,CAAC,WAAW,OAAI,CAAE,CAAC;QACxL,CAAC,CAAE,CAAC;QAEJ,SAAS,CAAC,UAAU,CAAC,OAAO,CAAE,UAAE,aAAa,EAAE,YAAY;YAC1D,EAAE,CAAA,CAAE,CAAE,SAAS,CAAC,UAAU,CAAC,GAAG,CAAE,YAAY,CAAG,CAAC;gBAAC,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAE,YAAY,EAAE,aAAa,CAAE,CAAC;YAEhH,IAAM,aAAa,GAA8B,SAAS,CAAC,UAAU,CAAC,GAAG,CAAE,YAAY,CAAE,CAAC;YAC1F,GAAG,CAAA,CAAE,IAAM,GAAG,IAAI,aAAc,CAAC,CAAC,CAAC;gBAClC,IAAM,QAAQ,GAAO,aAAa,CAAE,GAAG,CAAE,YAAY,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAE,GAAG,CAAE,CAAC,WAAW,CAAC,CAAC,CAAC,aAAa,CAAE,GAAG,CAAE,CAAC;gBACzH,IAAM,QAAQ,GAAO,aAAa,CAAE,GAAG,CAAE,YAAY,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAE,GAAG,CAAE,CAAC,WAAW,CAAC,CAAC,CAAC,aAAa,CAAE,GAAG,CAAE,CAAC;gBAEzH,EAAE,CAAA,CAAE,QAAQ,KAAK,QAAS,CAAC;oBAAC,MAAM,IAAI,6BAAoB,CAAE,gBAAc,YAAY,2BAAsB,GAAG,cAAS,QAAQ,cAAS,QAAQ,OAAI,CAAE,CAAC;YACzJ,CAAC;QACF,CAAC,CAAE,CAAC;QAEJ,MAAM,CAAC,SAAS,CAAC;IAClB,CAAC;IAEF,YAAC;AAAD,CAhCA,AAgCC,IAAA;AAhCY,sBAAK;AAkClB,kBAAe,KAAK,CAAC","file":"PartialMetadata.js","sourcesContent":["import { IllegalArgumentError } from \"../../Errors\";\nimport {\n\tDigestedObjectSchema,\n\tDigestedPropertyDefinition,\n} from \"../../ObjectSchema\";\nimport * as URI from \"../../RDF/URI\";\n\nexport const ALL:Readonly<DigestedObjectSchema> = Object.freeze( new DigestedObjectSchema() );\n\nexport class Class {\n\treadonly schema:DigestedObjectSchema;\n\n\tconstructor( schema:DigestedObjectSchema, previousPartial?:Class ) {\n\t\tthis.schema = this.mergeSchemas( previousPartial ? previousPartial.schema : new DigestedObjectSchema(), schema );\n\t}\n\n\tprivate mergeSchemas( oldSchema:DigestedObjectSchema, newSchema:DigestedObjectSchema ):DigestedObjectSchema {\n\t\tif( newSchema === ALL || oldSchema === ALL ) return ALL;\n\n\t\tnewSchema.prefixes.forEach( ( newURI, namespace ) => {\n\t\t\tif( ! oldSchema.prefixes.has( namespace ) ) return oldSchema.prefixes.set( namespace, newURI );\n\n\t\t\tconst oldURI:URI.Class = oldSchema.prefixes.get( namespace );\n\t\t\tif( oldURI.stringValue !== newURI.stringValue ) throw new IllegalArgumentError( `Prefix \"${ namespace }\" has different values: \"${ oldURI.stringValue }\", \"${ newURI.stringValue }\"` );\n\t\t} );\n\n\t\tnewSchema.properties.forEach( ( newDefinition, propertyName ) => {\n\t\t\tif( ! oldSchema.properties.has( propertyName ) ) return oldSchema.properties.set( propertyName, newDefinition );\n\n\t\t\tconst oldDefinition:DigestedPropertyDefinition = oldSchema.properties.get( propertyName );\n\t\t\tfor( const key in newDefinition ) {\n\t\t\t\tconst newValue:any = newDefinition[ key ] instanceof URI.Class ? newDefinition[ key ].stringValue : newDefinition[ key ];\n\t\t\t\tconst oldValue:any = oldDefinition[ key ] instanceof URI.Class ? oldDefinition[ key ].stringValue : oldDefinition[ key ];\n\n\t\t\t\tif( newValue !== oldValue ) throw new IllegalArgumentError( `Property \"${ propertyName }\" has different \"${ key }\": \"${ oldValue }\", \"${ newValue }\"` );\n\t\t\t}\n\t\t} );\n\n\t\treturn oldSchema;\n\t}\n\n}\n\nexport default Class;\n"]}