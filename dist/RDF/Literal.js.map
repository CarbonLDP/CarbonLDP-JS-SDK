{"version":3,"sources":["RDF/Literal.ts"],"names":[],"mappings":"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","file":"RDF/Literal.js","sourcesContent":["import * as Utils from \"./../Utils\";\nimport * as XSD from \"./../NS/XSD\" ;\nimport * as Errors from \"./../Errors\";\n\nimport Serializer from \"./Literal/Serializer\";\nimport * as Serializers from \"./Literal/Serializers\";\n\nexport interface Class {\n\t\"@type\"?:string;\n\t\"@value\":string;\n}\n\nexport class Factory {\n\tstatic from( value:any ):Class {\n\t\tif( Utils.isNull( value ) )\n\t\t\tthrow new Errors.IllegalArgumentError( \"Null cannot be converted into a Literal\" );\n\t\tif( ! Utils.isDefined( value ) )\n\t\t\tthrow new Errors.IllegalArgumentError( \"The value is undefined\" );\n\n\t\tlet type:any;\n\n\t\tswitch( true ) {\n\t\t\tcase Utils.isDate( value ):\n\t\t\t\ttype = XSD.DataType.dateTime;\n\t\t\t\tvalue = value.toISOString();\n\t\t\t\tbreak;\n\t\t\tcase Utils.isNumber( value ):\n\t\t\t\tif( Utils.isInteger( value ) ) {\n\t\t\t\t\ttype = XSD.DataType.integer;\n\t\t\t\t} else {\n\t\t\t\t\ttype = XSD.DataType.double;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Utils.isString( value ):\n\t\t\t\ttype = XSD.DataType.string;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isBoolean( value ):\n\t\t\t\ttype = XSD.DataType.boolean;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Treat it as an unknown object\n\t\t\t\ttype = XSD.DataType.object;\n\t\t\t\tvalue = JSON.stringify( value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet literal:Class = {\"@value\": value.toString()};\n\t\tif( type ) literal[ \"@type\" ] = type;\n\n\t\treturn literal;\n\t}\n\n\tstatic parse( literalValue:string, literalDataType?:string ):any;\n\tstatic parse( literal:Class ):any;\n\tstatic parse( literalValueOrLiteral:any, literalDataType:string = null ):any {\n\t\tlet literalValue:string;\n\t\tif( Utils.isString( literalValueOrLiteral ) ) {\n\t\t\tliteralValue = literalValueOrLiteral;\n\t\t} else {\n\t\t\tlet literal:Class = literalValueOrLiteral;\n\t\t\tif( ! literal ) return null;\n\t\t\tif( ! Utils.hasProperty( literal, \"@value\" ) ) return null;\n\n\t\t\tliteralDataType = \"@type\" in literal ? literal[ \"@type\" ] : null;\n\t\t\tliteralValue = literal[ \"@value\" ];\n\t\t}\n\n\t\tif( literalDataType === null ) return literalValue;\n\t\t// The DataType isn't supported\n\t\tif( ! Utils.hasProperty( XSD.DataType, literalDataType ) ) return literalValue;\n\n\t\tlet value:any;\n\t\tlet parts:string[];\n\t\tswitch( literalDataType ) {\n\t\t\t// Dates\n\t\t\tcase XSD.DataType.date:\n\t\t\tcase XSD.DataType.dateTime:\n\t\t\t\tvalue = new Date( literalValue );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.time:\n\t\t\t\tparts = literalValue.match( /(\\d+):(\\d+):(\\d+)\\.(\\d+)Z/ );\n\t\t\t\tvalue = new Date();\n\t\t\t\tvalue.setUTCHours( parseFloat( parts[ 1 ] ), parseFloat( parts[ 2 ] ), parseFloat( parts[ 3 ] ), parseFloat( parts[ 4 ] ) );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.duration:\n\t\t\t\t// TODO: Support duration values (create a class or something...)\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.gDay:\n\t\t\tcase XSD.DataType.gMonth:\n\t\t\tcase XSD.DataType.gMonthDay:\n\t\t\tcase XSD.DataType.gYear:\n\t\t\tcase XSD.DataType.gYearMonth:\n\t\t\t\t// TODO: Decide. Should we return it as a Date?\n\t\t\t\tbreak;\n\n\t\t\t// Numbers\n\t\t\tcase XSD.DataType.byte :\n\t\t\tcase XSD.DataType.decimal :\n\t\t\tcase XSD.DataType.int :\n\t\t\tcase XSD.DataType.integer :\n\t\t\tcase XSD.DataType.long :\n\t\t\tcase XSD.DataType.negativeInteger :\n\t\t\tcase XSD.DataType.nonNegativeInteger :\n\t\t\tcase XSD.DataType.nonPositiveInteger :\n\t\t\tcase XSD.DataType.positiveInteger :\n\t\t\tcase XSD.DataType.short :\n\t\t\tcase XSD.DataType.unsignedLong :\n\t\t\tcase XSD.DataType.unsignedInt :\n\t\t\tcase XSD.DataType.unsignedShort :\n\t\t\tcase XSD.DataType.unsignedByte :\n\t\t\tcase XSD.DataType.double :\n\t\t\tcase XSD.DataType.float :\n\t\t\t\tvalue = parseFloat( literalValue );\n\t\t\t\tbreak;\n\n\t\t\t// Misc\n\t\t\tcase XSD.DataType.boolean :\n\t\t\t\tvalue = Utils.parseBoolean( literalValue );\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.string:\n\t\t\t\tvalue = literalValue;\n\t\t\t\tbreak;\n\t\t\tcase XSD.DataType.object:\n\t\t\t\tvalue = JSON.parse( literalValue );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tstatic is( value:any ):boolean {\n\t\treturn Utils.hasProperty( value, \"@value\" )\n\t\t\t&& Utils.isString( value[ \"@value\" ] );\n\t}\n\n\tstatic hasType( value:Class, type:string ):boolean {\n\t\tif( ! value[ \"@type\" ] && type === <any> XSD.DataType.string ) return true;\n\t\treturn value[ \"@type\" ] === type;\n\t}\n}\n\nexport default Class;\n\nexport {\n\tSerializer,\n\tSerializers\n};\n"],"sourceRoot":"/source/"}