{"version":3,"sources":["RDF/Literal.ts"],"names":[],"mappings":"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","file":"Literal.js","sourcesContent":["import * as Utils from \"./../Utils\";\nimport { XSD } from \"../Vocabularies/XSD\" ;\nimport * as Errors from \"./../Errors\";\n\nimport Serializer from \"./Literal/Serializer\";\nimport * as Serializers from \"./Literal/Serializers\";\n\nexport interface Class {\n\t\"@type\"?:string;\n\t\"@value\":string;\n}\n\nexport class Factory {\n\tstatic from( value:any ):Class {\n\t\tif( Utils.isNull( value ) )\n\t\t\tthrow new Errors.IllegalArgumentError( \"Null cannot be converted into a Literal\" );\n\t\tif( ! Utils.isDefined( value ) )\n\t\t\tthrow new Errors.IllegalArgumentError( \"The value is undefined\" );\n\n\t\tlet type:any;\n\n\t\tswitch( true ) {\n\t\t\tcase Utils.isDate( value ):\n\t\t\t\ttype = XSD.dateTime;\n\t\t\t\tvalue = value.toISOString();\n\t\t\t\tbreak;\n\t\t\tcase Utils.isNumber( value ):\n\t\t\t\tif( Utils.isInteger( value ) ) {\n\t\t\t\t\ttype = XSD.integer;\n\t\t\t\t} else {\n\t\t\t\t\ttype = XSD.double;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Utils.isString( value ):\n\t\t\t\ttype = XSD.string;\n\t\t\t\tbreak;\n\t\t\tcase Utils.isBoolean( value ):\n\t\t\t\ttype = XSD.boolean;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Treat it as an unknown object\n\t\t\t\ttype = XSD.object;\n\t\t\t\tvalue = JSON.stringify( value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlet literal:Class = {\"@value\": value.toString()};\n\t\tif( type ) literal[ \"@type\" ] = type;\n\n\t\treturn literal;\n\t}\n\n\tstatic parse( literalValue:string, literalDataType?:string ):any;\n\tstatic parse( literal:Class ):any;\n\tstatic parse( literalValueOrLiteral:any, literalDataType:string = null ):any {\n\t\tlet literalValue:string;\n\t\tif( Utils.isString( literalValueOrLiteral ) ) {\n\t\t\tliteralValue = literalValueOrLiteral;\n\t\t} else {\n\t\t\tlet literal:Class = literalValueOrLiteral;\n\t\t\tif( ! literal ) return null;\n\t\t\tif( ! Utils.hasProperty( literal, \"@value\" ) ) return null;\n\n\t\t\tliteralDataType = \"@type\" in literal ? literal[ \"@type\" ] : null;\n\t\t\tliteralValue = literal[ \"@value\" ];\n\t\t}\n\n\t\tlet value:any = literalValue;\n\t\tlet parts:string[];\n\t\tswitch( literalDataType ) {\n\t\t\t// Dates\n\t\t\tcase XSD.date:\n\t\t\tcase XSD.dateTime:\n\t\t\t\tvalue = new Date( literalValue );\n\t\t\t\tbreak;\n\t\t\tcase XSD.time:\n\t\t\t\tparts = literalValue.match( /(\\d+):(\\d+):(\\d+)\\.(\\d+)Z/ );\n\t\t\t\tvalue = new Date();\n\t\t\t\tvalue.setUTCHours( parseFloat( parts[ 1 ] ), parseFloat( parts[ 2 ] ), parseFloat( parts[ 3 ] ), parseFloat( parts[ 4 ] ) );\n\t\t\t\tbreak;\n\t\t\tcase XSD.duration:\n\t\t\t\t// TODO: Support duration values (create a class or something...)\n\t\t\t\tbreak;\n\t\t\tcase XSD.gDay:\n\t\t\tcase XSD.gMonth:\n\t\t\tcase XSD.gMonthDay:\n\t\t\tcase XSD.gYear:\n\t\t\tcase XSD.gYearMonth:\n\t\t\t\t// TODO: Decide. Should we return it as a Date?\n\t\t\t\tbreak;\n\n\t\t\t// Numbers\n\t\t\tcase XSD.byte :\n\t\t\tcase XSD.decimal :\n\t\t\tcase XSD.int :\n\t\t\tcase XSD.integer :\n\t\t\tcase XSD.long :\n\t\t\tcase XSD.negativeInteger :\n\t\t\tcase XSD.nonNegativeInteger :\n\t\t\tcase XSD.nonPositiveInteger :\n\t\t\tcase XSD.positiveInteger :\n\t\t\tcase XSD.short :\n\t\t\tcase XSD.unsignedLong :\n\t\t\tcase XSD.unsignedInt :\n\t\t\tcase XSD.unsignedShort :\n\t\t\tcase XSD.unsignedByte :\n\t\t\tcase XSD.double :\n\t\t\tcase XSD.float :\n\t\t\t\tvalue = parseFloat( literalValue );\n\t\t\t\tbreak;\n\n\t\t\t// Misc\n\t\t\tcase XSD.boolean :\n\t\t\t\tvalue = Utils.parseBoolean( literalValue );\n\t\t\t\tbreak;\n\t\t\tcase XSD.string:\n\t\t\t\tvalue = literalValue;\n\t\t\t\tbreak;\n\t\t\tcase XSD.object:\n\t\t\t\tvalue = JSON.parse( literalValue );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tstatic is( value:any ):boolean {\n\t\treturn Utils.hasProperty( value, \"@value\" )\n\t\t\t&& Utils.isString( value[ \"@value\" ] );\n\t}\n\n\tstatic hasType( value:Class, type:string ):boolean {\n\t\tif( ! value[ \"@type\" ] && type === XSD.string ) return true;\n\t\treturn value[ \"@type\" ] === type;\n\t}\n}\n\nexport default Class;\n\nexport {\n\tSerializer,\n\tSerializers\n};\n"]}