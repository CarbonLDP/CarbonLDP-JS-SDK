{"version":3,"sources":["core/ModelDecorator.ts"],"names":[],"mappings":";;AAAA,kCAGkB;AAuBL,QAAA,cAAc,GAAyB;IACnD,iBAAiB,EAAjB,UAAmB,SAAgB,EAAE,MAAa;QACjD,OAAO,MAAM;aACX,IAAI,CAAE,SAAS,CAAE;aACjB,KAAK,CAAE,UAAA,GAAG;YACV,IAAM,UAAU,GAAsB,MAAM;iBAC1C,wBAAwB,CAAE,SAAS,EAAE,GAAG,CAAE,CAAC;YAE7C,IAAI,UAAU,CAAC,KAAK,IAAI,kBAAU,CAAE,UAAU,CAAC,KAAK,CAAE;gBACrD,OAAO,mBAAW,CAAE,MAAM,EAAE,GAAG,CAAE,CAAC;YAEnC,OAAO,MAAM,CAAC,cAAc,CAAE,GAAG,CAAE,CAAC;QACrC,CAAC,CAAE,CACF;IACH,CAAC;IAED,oBAAoB,EAApB,UAA0D,SAAW,EAAE,MAAQ;QAC9E,MAAM;aACJ,IAAI,CAAE,SAAS,CAAE;aACjB,OAAO,CAAE,UAAA,GAAG;YACZ,IAAM,UAAU,GAAsB;gBACrC,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;gBAClB,QAAQ,EAAE,IAAI;aACd,CAAC;YAEF,IAAM,KAAK,GAAO,SAAS,CAAE,GAAG,CAAE,CAAC;YACnC,IAAI,kBAAU,CAAE,KAAK,CAAE,EAAG;gBACzB,UAAU,CAAC,QAAQ,GAAG,KAAK,CAAC;gBAC5B,UAAU,CAAC,KAAK,GAAG,KAAK,CAAC;aACzB;iBAAM;gBACN,UAAU,CAAC,KAAK,GAAG,MAAM,CAAE,GAAG,CAAE,KAAK,KAAK,CAAC,CAAC,CAAC;oBAC5C,MAAM,CAAE,GAAG,CAAE,CAAC,CAAC,CAAC,KAAK,CAAC;aACvB;YAED,MAAM,CAAC,cAAc,CAAE,MAAM,EAAE,GAAG,EAAE,UAAU,CAAE,CAAC;QAClD,CAAC,CAAE,CACH;QAED,OAAO,MAAe,CAAC;IACxB,CAAC;IAED,gBAAgB,EAAhB,UAAsD,MAAQ;QAAE,gBAA6B;aAA7B,UAA6B,EAA7B,qBAA6B,EAA7B,IAA6B;YAA7B,+BAA6B;;QAC5F,MAAM,CAAC,OAAO,CAAE,UAAA,KAAK,IAAI,OAAA,KAAK,CAAC,QAAQ,CAAE,MAAM,CAAE,EAAxB,CAAwB,CAAE,CAAC;QACpD,OAAO,MAAe,CAAC;IACxB,CAAC;CACD,CAAC","file":"ModelDecorator.js","sourcesContent":["import {\n\thasFunction,\n\tisFunction\n} from \"../Utils\";\n\n\nexport interface ModelDecorator<T extends object, U extends object = object> {\n\tisDecorated( object:object ):object is T;\n\n\tdecorate<W extends U>( object:W ):W & T;\n}\n\n\nexport interface ModelDecoratorFactory {\n\thasPropertiesFrom<P extends object, O extends object>( prototype:P, object:O ):boolean;\n\n\tdefinePropertiesFrom<P extends object, O extends object>( prototype:P, object:O ):O & P;\n\n\tdecorateMultiple<O extends object, M1 extends object>( object:O, model1:ModelDecorator<M1> ):O & M1;\n\tdecorateMultiple<O extends object, M1 extends object, M2 extends object>( object:O, model1:ModelDecorator<M1>, model2:ModelDecorator<M2> ):O & M1 & M2;\n\tdecorateMultiple<O extends object, M1 extends object, M2 extends object, M3 extends object>( object:O, model1:ModelDecorator<M1>, model2:ModelDecorator<M2>, model3:ModelDecorator<M3> ):O & M1 & M2 & M3;\n\tdecorateMultiple<O extends object, M1 extends object, M2 extends object, M3 extends object, M4 extends object>( object:O, model1:ModelDecorator<M1>, model2:ModelDecorator<M2>, model3:ModelDecorator<M3>, model4:ModelDecorator<M4> ):O & M1 & M2 & M3 & M4;\n\tdecorateMultiple<O extends object, M1 extends object, M2 extends object, M3 extends object, M4 extends object, M5 extends object>( object:O, model1:ModelDecorator<M1>, model2:ModelDecorator<M2>, model3:ModelDecorator<M3>, model4:ModelDecorator<M4>, model5:ModelDecorator<M5> ):O & M1 & M2 & M3 & M4 & M5;\n\tdecorateMultiple<O extends object, M1 extends object, M2 extends object, M3 extends object, M4 extends object, M5 extends object, M6 extends object>( object:O, model1:ModelDecorator<M1>, model2:ModelDecorator<M2>, model3:ModelDecorator<M3>, model4:ModelDecorator<M4>, model5:ModelDecorator<M5>, model6:ModelDecorator<M6> ):O & M1 & M2 & M3 & M4 & M5 & M6;\n}\n\nexport const ModelDecorator:ModelDecoratorFactory = {\n\thasPropertiesFrom( prototype:object, object:object ):boolean {\n\t\treturn Object\n\t\t\t.keys( prototype )\n\t\t\t.every( key => {\n\t\t\t\tconst definition:PropertyDescriptor = Object\n\t\t\t\t\t.getOwnPropertyDescriptor( prototype, key );\n\n\t\t\t\tif( definition.value && isFunction( definition.value ) )\n\t\t\t\t\treturn hasFunction( object, key );\n\n\t\t\t\treturn object.hasOwnProperty( key );\n\t\t\t} )\n\t\t\t;\n\t},\n\n\tdefinePropertiesFrom<P extends object, O extends object>( prototype:P, object:O ):O & P {\n\t\tObject\n\t\t\t.keys( prototype )\n\t\t\t.forEach( key => {\n\t\t\t\tconst descriptor:PropertyDescriptor = {\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t};\n\n\t\t\t\tconst value:any = prototype[ key ];\n\t\t\t\tif( isFunction( value ) ) {\n\t\t\t\t\tdescriptor.writable = false;\n\t\t\t\t\tdescriptor.value = value;\n\t\t\t\t} else {\n\t\t\t\t\tdescriptor.value = object[ key ] !== void 0 ?\n\t\t\t\t\t\tobject[ key ] : value;\n\t\t\t\t}\n\n\t\t\t\tObject.defineProperty( object, key, descriptor );\n\t\t\t} )\n\t\t;\n\n\t\treturn object as P & O;\n\t},\n\n\tdecorateMultiple<O extends object, M extends object>( object:O, ...models:ModelDecorator<M>[] ):O & M {\n\t\tmodels.forEach( model => model.decorate( object ) );\n\t\treturn object as O & M;\n\t},\n};\n"]}