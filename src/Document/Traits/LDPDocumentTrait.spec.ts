import { spyOnDecorated } from "../../../test/helpers/jasmine/spies";

import { DocumentsContext } from "../../Context/DocumentsContext";

import { LDPDocumentsRepositoryTrait } from "../../DocumentsRepository/Traits/LDPDocumentsRepositoryTrait";

import { ModelDecorator } from "../../Model/ModelDecorator";
import { ModelPrototype } from "../../Model/ModelPrototype";

import { ResolvablePointer } from "../../Repository/ResolvablePointer";

import {
	extendsClass,
	hasProperty,
	hasSignature,
	interfaze,
	method,
	module,
	OBLIGATORY,
	property,
	STATIC
} from "../../test/JasmineExtender";

import { TransientDocument } from "../TransientDocument";

import { BaseLDPDocumentTrait, LDPDocumentTrait, LDPDocumentTraitFactory } from "./LDPDocumentTrait";


describe( module( "carbonldp/DocumentsRepository/Traits/LDPDocumentTrait" ), () => {

	let $context:DocumentsContext;
	let $repository:LDPDocumentsRepositoryTrait;
	beforeEach( ():void => {
		$context = new DocumentsContext( "https://example.com/" );
		$repository = LDPDocumentsRepositoryTrait.decorate( { $context } );
	} );


	describe( interfaze(
		"CarbonLDP.DocumentsRepository.Traits.LDPDocumentTrait",
		"Documents repository with the implementation for event subscriptions."
	), () => {

		it( extendsClass( "CarbonLDP.TransientDocument" ), () => {
			const target:TransientDocument = {} as LDPDocumentTrait;
			expect( target ).toBeDefined();
		} );

		it( extendsClass( "CarbonLDP.ResolvablePointer" ), () => {
			const target:ResolvablePointer = {} as LDPDocumentTrait;
			expect( target ).toBeDefined();
		} );


		it( hasProperty(
			OBLIGATORY,
			"$repository",
			"CarbonLDP.DocumentsRepository.Trait.LDPDocumentsRepositoryTrait"
		), ():void => {
			const target:LDPDocumentTrait[ "$repository" ] = {} as LDPDocumentsRepositoryTrait;
			expect( target ).toBeDefined();
		} );


		let resource:LDPDocumentTrait;
		beforeEach( ():void => {
			resource = LDPDocumentTrait.decorate( {
				$repository,
				$id: "https://example.com/resource/",
			} );
		} );


		describe( method( OBLIGATORY, "create" ), () => {

			it( hasSignature(
				[ "T extends object" ],
				"Persists the object as a child of the current document.", [
					{ name: "child", type: "T", description: "The object from where to create the child." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<T & CarbonLDP.Document>" }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists the object with the slug specified as a child of the current document.", [
					{ name: "child", type: "T", description: "The object from where to create the child." },
					{ name: "slug", type: "string", description: "The slug that will be used in the child URI." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<T & CarbonLDP.Document>" }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists multiple objects as children of the current document.", [
					{ name: "children", type: "T[]", description: "An array with the objects to be persisted as the new children." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for every the request." },
				],
				{ type: "Promise<(T & CarbonLDP.Document)[]>", description: "Promise that contains the new UNRESOLVED persisted children." }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists multiple objects as children of the current document.", [
					{ name: "children", type: "T[]", description: "An array with the objects to be persisted as the new children." },
					{ name: "slugs", type: "string[]", description: "Array with the slugs that corresponds to each object in `object` parameter, in the order in which they were defined. If an element in the array is undefined or null, the slug will be generated by the platform." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for every the request." },
				],
				{ type: "Promise<(T & CarbonLDP.Document)[]>", description: "Promise that contains the new UNRESOLVED persisted children." }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists the object as a child of the uri specified.", [
					{ name: "uri", type: "string", description: "URI of the document where to create the child." },
					{ name: "child", type: "T", description: "The object from where to create the child." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<T & CarbonLDP.Document>" }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists the object with the slug specified as a child of the uri specified.", [
					{ name: "uri", type: "string", description: "URI of the document where to create the child." },
					{ name: "child", type: "T", description: "The object from where to create the child." },
					{ name: "slug", type: "string", description: "The slug that will be used in the child URI." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<T & CarbonLDP.Document>" }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists multiple objects as children of the uri specified.", [
					{ name: "uri", type: "string", description: "URI of the document where to create the child." },
					{ name: "children", type: "T[]", description: "An array with the objects to be persisted as the new children." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for every the request." },
				],
				{ type: "Promise<(T & CarbonLDP.Document)[]>", description: "Promise that contains the new UNRESOLVED persisted children." }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists multiple objects as children of the uri specified.", [
					{ name: "uri", type: "string", description: "URI of the document where to create the child." },
					{ name: "children", type: "T[]", description: "An array with the objects to be persisted as the new children." },
					{ name: "slugs", type: "string[]", description: "Array with the slugs that corresponds to each object in `object` parameter, in the order in which they were defined. If an element in the array is undefined or null, the slug will be generated by the platform." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for every the request." },
				],
				{ type: "Promise<(T & CarbonLDP.Document)[]>", description: "Promise that contains the new UNRESOLVED persisted children." }
			), ():void => {} );

			it( "should exists", ():void => {
				expect( resource.create ).toBeDefined();
				expect( resource.create ).toEqual( jasmine.any( Function ) );
			} );


			let spy:jasmine.Spy;
			beforeEach( ():void => {
				spy = spyOnDecorated( $repository, "create" )
					.and.returnValue( Promise.resolve( null ) );
			} );


			it( "should call repository with $id when multiple child", async () => {
				await resource.create( [ { a: "child" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { a: "child" } ] );
			} );

			it( "should call repository with $id when multiple child and options", async () => {
				await resource.create( [ { a: "child" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { a: "child" } ], { timeout: 5050 } );
			} );

			it( "should call repository with $id when multiple child and slugs", async () => {
				await resource.create( [ { a: "child" } ], [ "child-slug" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { a: "child" } ], [ "child-slug" ] );
			} );

			it( "should call repository with $id when multiple child, slugs and options", async () => {
				await resource.create( [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
			} );

			it( "should call repository with $id when single child", async () => {
				await resource.create( { a: "child" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { a: "child" } );
			} );

			it( "should call repository with $id when single child and options", async () => {
				await resource.create( { a: "child" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { a: "child" }, { timeout: 5050 } );
			} );

			it( "should call repository with $id when single child and slug", async () => {
				await resource.create( { a: "child" }, "slug" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { a: "child" }, "slug" );
			} );

			it( "should call repository with $id when single child, slug and options", async () => {
				await resource.create( { a: "child" }, "slug", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { a: "child" }, "slug", { timeout: 5050 } );
			} );


			it( "should call repository absolute URI when multiple child", async () => {
				await resource.create( "https://example.com/another-resource/", [ { a: "child" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { a: "child" } ] );
			} );

			it( "should call repository absolute URI when multiple child and options", async () => {
				await resource.create( "https://example.com/another-resource/", [ { a: "child" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { a: "child" } ], { timeout: 5050 } );
			} );

			it( "should call repository absolute URI when multiple child and slugs", async () => {
				await resource.create( "https://example.com/another-resource/", [ { a: "child" } ], [ "child-slug" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { a: "child" } ], [ "child-slug" ] );
			} );

			it( "should call repository absolute URI when multiple child, slugs and options", async () => {
				await resource.create( "https://example.com/another-resource/", [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
			} );

			it( "should call repository absolute URI when single child", async () => {
				await resource.create( "https://example.com/another-resource/", { a: "child" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { a: "child" } );
			} );

			it( "should call repository absolute URI when single child and options", async () => {
				await resource.create( "https://example.com/another-resource/", { a: "child" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { a: "child" }, { timeout: 5050 } );
			} );

			it( "should call repository absolute URI when single child and slug", async () => {
				await resource.create( "https://example.com/another-resource/", { a: "child" }, "slug" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { a: "child" }, "slug" );
			} );

			it( "should call repository absolute URI when single child, slug and options", async () => {
				await resource.create( "https://example.com/another-resource/", { a: "child" }, "slug", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { a: "child" }, "slug", { timeout: 5050 } );
			} );


			it( "should call repository resolved relative URI when multiple child", async () => {
				await resource.create( "relative/", [ { a: "child" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { a: "child" } ] );
			} );

			it( "should call repository resolved relative URI when multiple child and options", async () => {
				await resource.create( "relative/", [ { a: "child" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { a: "child" } ], { timeout: 5050 } );
			} );

			it( "should call repository resolved relative URI when multiple child and slugs", async () => {
				await resource.create( "relative/", [ { a: "child" } ], [ "child-slug" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { a: "child" } ], [ "child-slug" ] );
			} );

			it( "should call repository resolved relative URI when multiple child, slugs and options", async () => {
				await resource.create( "relative/", [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
			} );

			it( "should call repository resolved relative URI when single child", async () => {
				await resource.create( "relative/", { a: "child" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { a: "child" } );
			} );

			it( "should call repository resolved relative URI when single child and options", async () => {
				await resource.create( "relative/", { a: "child" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { a: "child" }, { timeout: 5050 } );
			} );

			it( "should call repository resolved relative URI when single child and slug", async () => {
				await resource.create( "relative/", { a: "child" }, "slug" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { a: "child" }, "slug" );
			} );

			it( "should call repository resolved relative URI when single child, slug and options", async () => {
				await resource.create( "relative/", { a: "child" }, "slug", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { a: "child" }, "slug", { timeout: 5050 } );
			} );

		} );

		describe( method( OBLIGATORY, "createAndRetrieve" ), () => {

			it( hasSignature(
				[ "T extends object" ],
				"Persists the object as a child of the current document and retrieves the updated data from the server.", [
					{ name: "child", type: "T", description: "The object from where to create the child." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<T & CarbonLDP.Document>" }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists the object with the slug specified as a child of the current document and retrieves the updated data from the server.", [
					{ name: "child", type: "T", description: "The object from where to create the child." },
					{ name: "slug", type: "string", description: "The slug that will be used in the child URI." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<T & CarbonLDP.Document>" }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists multiple objects as children of the current document and retrieves the updated data from the server.", [
					{ name: "children", type: "T[]", description: "An array with the objects to be persisted as the new children." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for every the request." },
				],
				{ type: "Promise<(T & CarbonLDP.Document)[]>", description: "Promise that contains the new UNRESOLVED persisted children." }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists multiple objects as children of the current document and retrieves the updated data from the server.", [
					{ name: "children", type: "T[]", description: "An array with the objects to be persisted as the new children." },
					{ name: "slugs", type: "string[]", description: "Array with the slugs that corresponds to each object in `object` parameter, in the order in which they were defined. If an element in the array is undefined or null, the slug will be generated by the platform." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for every the request." },
				],
				{ type: "Promise<(T & CarbonLDP.Document)[]>", description: "Promise that contains the new UNRESOLVED persisted children." }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists the object as a child of the uri specified and retrieves the updates data from the server.", [
					{ name: "uri", type: "string", description: "URI of the document where to create the child." },
					{ name: "child", type: "T", description: "The object from where to create the child." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<T & CarbonLDP.Document>" }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists the object with the slug specified as a child of the uri specified and retrieves the updates data from the server.", [
					{ name: "uri", type: "string", description: "URI of the document where to create the child." },
					{ name: "child", type: "T", description: "The object from where to create the child." },
					{ name: "slug", type: "string", description: "The slug that will be used in the child URI." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<T & CarbonLDP.Document>" }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists multiple objects as children of the uri specified and retrieves the updates data from the server.", [
					{ name: "uri", type: "string", description: "URI of the document where to create the child." },
					{ name: "children", type: "T[]", description: "An array with the objects to be persisted as the new children." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for every the request." },
				],
				{ type: "Promise<(T & CarbonLDP.Document)[]>", description: "Promise that contains the new UNRESOLVED persisted children." }
			), ():void => {} );

			it( hasSignature(
				[ "T extends object" ],
				"Persists multiple objects as children of the uri specified and retrieves the updates data from the server.", [
					{ name: "uri", type: "string", description: "URI of the document where to create the child." },
					{ name: "children", type: "T[]", description: "An array with the objects to be persisted as the new children." },
					{ name: "slugs", type: "string[]", description: "Array with the slugs that corresponds to each object in `object` parameter, in the order in which they were defined. If an element in the array is undefined or null, the slug will be generated by the platform." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for every the request." },
				],
				{ type: "Promise<(T & CarbonLDP.Document)[]>", description: "Promise that contains the new UNRESOLVED persisted children." }
			), ():void => {} );

			it( "should exists", ():void => {
				expect( resource.createAndRetrieve ).toBeDefined();
				expect( resource.createAndRetrieve ).toEqual( jasmine.any( Function ) );
			} );


			let spy:jasmine.Spy;
			beforeEach( ():void => {
				spy = spyOnDecorated( $repository, "createAndRetrieve" )
					.and.returnValue( Promise.resolve( null ) );
			} );


			it( "should call repository with $id when multiple child", async () => {
				await resource.createAndRetrieve( [ { a: "child" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { a: "child" } ] );
			} );

			it( "should call repository with $id when multiple child and options", async () => {
				await resource.createAndRetrieve( [ { a: "child" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { a: "child" } ], { timeout: 5050 } );
			} );

			it( "should call repository with $id when multiple child and slugs", async () => {
				await resource.createAndRetrieve( [ { a: "child" } ], [ "child-slug" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { a: "child" } ], [ "child-slug" ] );
			} );

			it( "should call repository with $id when multiple child, slugs and options", async () => {
				await resource.createAndRetrieve( [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
			} );

			it( "should call repository with $id when single child", async () => {
				await resource.createAndRetrieve( { a: "child" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { a: "child" } );
			} );

			it( "should call repository with $id when single child and options", async () => {
				await resource.createAndRetrieve( { a: "child" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { a: "child" }, { timeout: 5050 } );
			} );

			it( "should call repository with $id when single child and slug", async () => {
				await resource.createAndRetrieve( { a: "child" }, "slug" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { a: "child" }, "slug" );
			} );

			it( "should call repository with $id when single child, slug and options", async () => {
				await resource.createAndRetrieve( { a: "child" }, "slug", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { a: "child" }, "slug", { timeout: 5050 } );
			} );


			it( "should call repository absolute URI when multiple child", async () => {
				await resource.createAndRetrieve( "https://example.com/another-resource/", [ { a: "child" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { a: "child" } ] );
			} );

			it( "should call repository absolute URI when multiple child and options", async () => {
				await resource.createAndRetrieve( "https://example.com/another-resource/", [ { a: "child" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { a: "child" } ], { timeout: 5050 } );
			} );

			it( "should call repository absolute URI when multiple child and slugs", async () => {
				await resource.createAndRetrieve( "https://example.com/another-resource/", [ { a: "child" } ], [ "child-slug" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { a: "child" } ], [ "child-slug" ] );
			} );

			it( "should call repository absolute URI when multiple child, slugs and options", async () => {
				await resource.createAndRetrieve( "https://example.com/another-resource/", [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
			} );

			it( "should call repository absolute URI when single child", async () => {
				await resource.createAndRetrieve( "https://example.com/another-resource/", { a: "child" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { a: "child" } );
			} );

			it( "should call repository absolute URI when single child and options", async () => {
				await resource.createAndRetrieve( "https://example.com/another-resource/", { a: "child" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { a: "child" }, { timeout: 5050 } );
			} );

			it( "should call repository absolute URI when single child and slug", async () => {
				await resource.createAndRetrieve( "https://example.com/another-resource/", { a: "child" }, "slug" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { a: "child" }, "slug" );
			} );

			it( "should call repository absolute URI when single child, slug and options", async () => {
				await resource.createAndRetrieve( "https://example.com/another-resource/", { a: "child" }, "slug", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { a: "child" }, "slug", { timeout: 5050 } );
			} );


			it( "should call repository resolved relative URI when multiple child", async () => {
				await resource.createAndRetrieve( "relative/", [ { a: "child" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { a: "child" } ] );
			} );

			it( "should call repository resolved relative URI when multiple child and options", async () => {
				await resource.createAndRetrieve( "relative/", [ { a: "child" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { a: "child" } ], { timeout: 5050 } );
			} );

			it( "should call repository resolved relative URI when multiple child and slugs", async () => {
				await resource.createAndRetrieve( "relative/", [ { a: "child" } ], [ "child-slug" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { a: "child" } ], [ "child-slug" ] );
			} );

			it( "should call repository resolved relative URI when multiple child, slugs and options", async () => {
				await resource.createAndRetrieve( "relative/", [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { a: "child" } ], [ "child-slug" ], { timeout: 5050 } );
			} );

			it( "should call repository resolved relative URI when single child", async () => {
				await resource.createAndRetrieve( "relative/", { a: "child" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { a: "child" } );
			} );

			it( "should call repository resolved relative URI when single child and options", async () => {
				await resource.createAndRetrieve( "relative/", { a: "child" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { a: "child" }, { timeout: 5050 } );
			} );

			it( "should call repository resolved relative URI when single child and slug", async () => {
				await resource.createAndRetrieve( "relative/", { a: "child" }, "slug" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { a: "child" }, "slug" );
			} );

			it( "should call repository resolved relative URI when single child, slug and options", async () => {
				await resource.createAndRetrieve( "relative/", { a: "child" }, "slug", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { a: "child" }, "slug", { timeout: 5050 } );
			} );

		} );


		describe( method( OBLIGATORY, "addMember" ), () => {

			it( hasSignature(
				"Adds the provided resource as member of the current document.", [
					{ name: "member", type: "CarbonLDP.Pointer | string", description: "URI or Pointer to add as a member." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<void>" }
			), ():void => {} );

			it( hasSignature(
				"Adds the provided resource as member of the specified document.", [
					{ name: "uri", type: "string", description: "URI of the document to add the specified member." },
					{ name: "member", type: "CarbonLDP.Pointer | string", description: "URI or Pointer to add as a member." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<void>" }
			), ():void => {} );

			it( "should exists", ():void => {
				expect( resource.addMember ).toBeDefined();
				expect( resource.addMember ).toEqual( jasmine.any( Function ) );
			} );


			let spy:jasmine.Spy;
			beforeEach( ():void => {
				spy = spyOnDecorated( $repository, "addMember" )
					.and.returnValue( Promise.resolve( null ) );
			} );


			it( "should call repository with $id when string member", async () => {
				await resource.addMember( "member/" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", "member/" );
			} );

			it( "should call repository with $id when pointer member", async () => {
				await resource.addMember( { $id: "member/" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { $id: "member/" } );
			} );

			it( "should call repository with $id when string member and options", async () => {
				await resource.addMember( "member/", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", "member/", { timeout: 5050 } );
			} );

			it( "should call repository with $id when pointer member and options", async () => {
				await resource.addMember( { $id: "member/" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { $id: "member/" }, { timeout: 5050 } );
			} );


			it( "should call repository with absolute URI when string member", async () => {
				await resource.addMember( "https://example.com/another-resource/", "member/" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", "member/" );
			} );

			it( "should call repository with absolute URI when pointer member", async () => {
				await resource.addMember( "https://example.com/another-resource/", { $id: "member/" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { $id: "member/" } );
			} );

			it( "should call repository with absolute URI when string member and options", async () => {
				await resource.addMember( "https://example.com/another-resource/", "member/", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", "member/", { timeout: 5050 } );
			} );

			it( "should call repository with absolute URI when pointer member and options", async () => {
				await resource.addMember( "https://example.com/another-resource/", { $id: "member/" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { $id: "member/" }, { timeout: 5050 } );
			} );


			it( "should call repository with resolved relative URI when string member", async () => {
				await resource.addMember( "relative/", "member/" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", "member/" );
			} );

			it( "should call repository with resolved relative URI when pointer member", async () => {
				await resource.addMember( "relative/", { $id: "member/" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { $id: "member/" } );
			} );

			it( "should call repository with resolved relative URI when string member and options", async () => {
				await resource.addMember( "relative/", "member/", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", "member/", { timeout: 5050 } );
			} );

			it( "should call repository with resolved relative URI when pointer member and options", async () => {
				await resource.addMember( "relative/", { $id: "member/" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { $id: "member/" }, { timeout: 5050 } );
			} );

		} );

		describe( method( OBLIGATORY, "addMembers" ), () => {

			it( hasSignature(
				"Adds the provided resources as members of the current document.", [
					{ name: "member", type: "CarbonLDP.Pointer | string", description: "URI or Pointer to add as a member." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<void>" }
			), ():void => {} );

			it( hasSignature(
				"Adds the provided resources as members of the specified document.", [
					{ name: "uri", type: "string", description: "URI of the document to add the specified member." },
					{ name: "member", type: "CarbonLDP.Pointer | string", description: "URI or Pointer to add as a member." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<void>" }
			), ():void => {} );

			it( "should exists", ():void => {
				expect( resource.addMembers ).toBeDefined();
				expect( resource.addMembers ).toEqual( jasmine.any( Function ) );
			} );


			let spy:jasmine.Spy;
			beforeEach( ():void => {
				spy = spyOnDecorated( $repository, "addMembers" )
					.and.returnValue( Promise.resolve( null ) );
			} );


			it( "should call repository with $id when string member", async () => {
				await resource.addMembers( [ "member/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ "member/" ] );
			} );

			it( "should call repository with $id when pointer member", async () => {
				await resource.addMembers( [ { $id: "member/" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { $id: "member/" } ] );
			} );

			it( "should call repository with $id when pointer & string member", async () => {
				await resource.addMembers( [ { $id: "member1/" }, "member2/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { $id: "member1/" }, "member2/" ] );
			} );

			it( "should call repository with $id when string member and options", async () => {
				await resource.addMembers( [ "member/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ "member/" ], { timeout: 5050 } );
			} );

			it( "should call repository with $id when pointer member and options", async () => {
				await resource.addMembers( [ { $id: "member/" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { $id: "member/" } ], { timeout: 5050 } );
			} );

			it( "should call repository with $id when pointer & string member and options", async () => {
				await resource.addMembers( [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
			} );


			it( "should call repository with absolute URI when string member", async () => {
				await resource.addMembers( "https://example.com/another-resource/", [ "member/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ "member/" ] );
			} );

			it( "should call repository with absolute URI when pointer member", async () => {
				await resource.addMembers( "https://example.com/another-resource/", [ { $id: "member/" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { $id: "member/" } ] );
			} );

			it( "should call repository with absolute URI when pointer & string member", async () => {
				await resource.addMembers( "https://example.com/another-resource/", [ { $id: "member1/" }, "member2/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { $id: "member1/" }, "member2/" ] );
			} );

			it( "should call repository with absolute URI when string member and options", async () => {
				await resource.addMembers( "https://example.com/another-resource/", [ "member/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ "member/" ], { timeout: 5050 } );
			} );

			it( "should call repository with absolute URI when pointer member and options", async () => {
				await resource.addMembers( "https://example.com/another-resource/", [ { $id: "member/" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { $id: "member/" } ], { timeout: 5050 } );
			} );

			it( "should call repository with absolute URI when pointer member and options", async () => {
				await resource.addMembers( "https://example.com/another-resource/", [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
			} );


			it( "should call repository with resolved relative URI when string member", async () => {
				await resource.addMembers( "relative/", [ "member/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ "member/" ] );
			} );

			it( "should call repository with resolved relative URI when pointer member", async () => {
				await resource.addMembers( "relative/", [ { $id: "member/" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { $id: "member/" } ] );
			} );

			it( "should call repository with resolved relative URI when pointer member", async () => {
				await resource.addMembers( "relative/", [ { $id: "member1/" }, "member2/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { $id: "member1/" }, "member2/" ] );
			} );

			it( "should call repository with resolved relative URI when string member and options", async () => {
				await resource.addMembers( "relative/", [ "member/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ "member/" ], { timeout: 5050 } );
			} );

			it( "should call repository with resolved relative URI when pointer member and options", async () => {
				await resource.addMembers( "relative/", [ { $id: "member/" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { $id: "member/" } ], { timeout: 5050 } );
			} );

			it( "should call repository with resolved relative URI when pointer member and options", async () => {
				await resource.addMembers( "relative/", [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
			} );

		} );


		describe( method( OBLIGATORY, "removeMember" ), () => {

			it( hasSignature(
				"Removes the provided resource as member of the current document.", [
					{ name: "member", type: "CarbonLDP.Pointer | string", description: "URI or Pointer to remove as a member." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<void>" }
			), ():void => {} );

			it( hasSignature(
				"Removes the provided resource as member of the specified document.", [
					{ name: "uri", type: "string", description: "URI of the document to remove the specified member." },
					{ name: "member", type: "CarbonLDP.Pointer | string", description: "URI or Pointer to remove as a member." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<void>" }
			), ():void => {} );

			it( "should exists", ():void => {
				expect( resource.removeMember ).toBeDefined();
				expect( resource.removeMember ).toEqual( jasmine.any( Function ) );
			} );


			let spy:jasmine.Spy;
			beforeEach( ():void => {
				spy = spyOnDecorated( $repository, "removeMember" )
					.and.returnValue( Promise.resolve( null ) );
			} );


			it( "should call repository with $id when string member", async () => {
				await resource.removeMember( "member/" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", "member/" );
			} );

			it( "should call repository with $id when pointer member", async () => {
				await resource.removeMember( { $id: "member/" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { $id: "member/" } );
			} );

			it( "should call repository with $id when string member and options", async () => {
				await resource.removeMember( "member/", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", "member/", { timeout: 5050 } );
			} );

			it( "should call repository with $id when pointer member and options", async () => {
				await resource.removeMember( { $id: "member/" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { $id: "member/" }, { timeout: 5050 } );
			} );


			it( "should call repository with absolute URI when string member", async () => {
				await resource.removeMember( "https://example.com/another-resource/", "member/" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", "member/" );
			} );

			it( "should call repository with absolute URI when pointer member", async () => {
				await resource.removeMember( "https://example.com/another-resource/", { $id: "member/" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { $id: "member/" } );
			} );

			it( "should call repository with absolute URI when string member and options", async () => {
				await resource.removeMember( "https://example.com/another-resource/", "member/", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", "member/", { timeout: 5050 } );
			} );

			it( "should call repository with absolute URI when pointer member and options", async () => {
				await resource.removeMember( "https://example.com/another-resource/", { $id: "member/" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { $id: "member/" }, { timeout: 5050 } );
			} );


			it( "should call repository with resolved relative URI when string member", async () => {
				await resource.removeMember( "relative/", "member/" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", "member/" );
			} );

			it( "should call repository with resolved relative URI when pointer member", async () => {
				await resource.removeMember( "relative/", { $id: "member/" } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { $id: "member/" } );
			} );

			it( "should call repository with resolved relative URI when string member and options", async () => {
				await resource.removeMember( "relative/", "member/", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", "member/", { timeout: 5050 } );
			} );

			it( "should call repository with resolved relative URI when pointer member and options", async () => {
				await resource.removeMember( "relative/", { $id: "member/" }, { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { $id: "member/" }, { timeout: 5050 } );
			} );

		} );

		describe( method( OBLIGATORY, "removeMembers" ), () => {

			it( hasSignature(
				"Removes the provided resources as members of the current document.", [
					{ name: "member", type: "CarbonLDP.Pointer | string", description: "URI or Pointer to remove as a member." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<void>" }
			), ():void => {} );

			it( hasSignature(
				"Removes the provided resources as members of the specified document.", [
					{ name: "uri", type: "string", description: "URI of the document to remove the specified member." },
					{ name: "member", type: "CarbonLDP.Pointer | string", description: "URI or Pointer to remove as a member." },
					{ name: "requestOptions", type: "CarbonLDP.HTTP.RequestOptions", optional: true, description: "Customizable options for the request." },
				],
				{ type: "Promise<void>" }
			), ():void => {} );

			it( "should exists", ():void => {
				expect( resource.removeMembers ).toBeDefined();
				expect( resource.removeMembers ).toEqual( jasmine.any( Function ) );
			} );


			let spy:jasmine.Spy;
			beforeEach( ():void => {
				spy = spyOnDecorated( $repository, "removeMembers" )
					.and.returnValue( Promise.resolve( null ) );
			} );


			it( "should call repository with $id when string member", async () => {
				await resource.removeMembers( [ "member/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ "member/" ] );
			} );

			it( "should call repository with $id when pointer member", async () => {
				await resource.removeMembers( [ { $id: "member/" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { $id: "member/" } ] );
			} );

			it( "should call repository with $id when pointer & string member", async () => {
				await resource.removeMembers( [ { $id: "member1/" }, "member2/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { $id: "member1/" }, "member2/" ] );
			} );

			it( "should call repository with $id when string member and options", async () => {
				await resource.removeMembers( [ "member/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ "member/" ], { timeout: 5050 } );
			} );

			it( "should call repository with $id when pointer member and options", async () => {
				await resource.removeMembers( [ { $id: "member/" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { $id: "member/" } ], { timeout: 5050 } );
			} );

			it( "should call repository with $id when pointer & string member and options", async () => {
				await resource.removeMembers( [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
			} );

			it( "should call repository with $id when no member", async () => {
				await resource.removeMembers();
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/" );
			} );

			it( "should call repository with $id when options", async () => {
				await resource.removeMembers( { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/", { timeout: 5050 } );
			} );


			it( "should call repository with absolute URI when string member", async () => {
				await resource.removeMembers( "https://example.com/another-resource/", [ "member/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ "member/" ] );
			} );

			it( "should call repository with absolute URI when pointer member", async () => {
				await resource.removeMembers( "https://example.com/another-resource/", [ { $id: "member/" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { $id: "member/" } ] );
			} );

			it( "should call repository with absolute URI when pointer & string member", async () => {
				await resource.removeMembers( "https://example.com/another-resource/", [ { $id: "member1/" }, "member2/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { $id: "member1/" }, "member2/" ] );
			} );

			it( "should call repository with absolute URI when string member and options", async () => {
				await resource.removeMembers( "https://example.com/another-resource/", [ "member/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ "member/" ], { timeout: 5050 } );
			} );

			it( "should call repository with absolute URI when pointer member and options", async () => {
				await resource.removeMembers( "https://example.com/another-resource/", [ { $id: "member/" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { $id: "member/" } ], { timeout: 5050 } );
			} );

			it( "should call repository with absolute URI when pointer member and options", async () => {
				await resource.removeMembers( "https://example.com/another-resource/", [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
			} );

			it( "should call repository with absolute URI when no member", async () => {
				await resource.removeMembers( "https://example.com/another-resource/" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/" );
			} );

			it( "should call repository with absolute URI when options", async () => {
				await resource.removeMembers( "https://example.com/another-resource/", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/another-resource/", { timeout: 5050 } );
			} );


			it( "should call repository with resolved relative URI when string member", async () => {
				await resource.removeMembers( "relative/", [ "member/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ "member/" ] );
			} );

			it( "should call repository with resolved relative URI when pointer member", async () => {
				await resource.removeMembers( "relative/", [ { $id: "member/" } ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { $id: "member/" } ] );
			} );

			it( "should call repository with resolved relative URI when pointer member", async () => {
				await resource.removeMembers( "relative/", [ { $id: "member1/" }, "member2/" ] );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { $id: "member1/" }, "member2/" ] );
			} );

			it( "should call repository with resolved relative URI when string member and options", async () => {
				await resource.removeMembers( "relative/", [ "member/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ "member/" ], { timeout: 5050 } );
			} );

			it( "should call repository with resolved relative URI when pointer member and options", async () => {
				await resource.removeMembers( "relative/", [ { $id: "member/" } ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { $id: "member/" } ], { timeout: 5050 } );
			} );

			it( "should call repository with resolved relative URI when pointer member and options", async () => {
				await resource.removeMembers( "relative/", [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", [ { $id: "member1/" }, "member2/" ], { timeout: 5050 } );
			} );

			it( "should call repository with resolved relative URI when no member", async () => {
				await resource.removeMembers( "relative/" );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/" );
			} );

			it( "should call repository with resolved relative URI when options", async () => {
				await resource.removeMembers( "relative/", { timeout: 5050 } );
				expect( spy ).toHaveBeenCalledWith( "https://example.com/resource/relative/", { timeout: 5050 } );
			} );

		} );

	} );

	describe( interfaze(
		"CarbonLDP.DocumentsRepository.Traits.LDPDocumentTraitFactory",
		"Interface with the decoration, factory and utils for `CarbonLDP.DocumentsRepository.Traits.LDPDocumentTrait` objects."
	), () => {

		it( extendsClass( "CarbonLDP.Model.ModelPrototype<CarbonLDP.DocumentsRepository.Traits.LDPDocumentTrait, CarbonLDP.TransientDocument, CarbonLDP.ResolvablePointer" ), () => {
			const target:ModelPrototype<LDPDocumentTrait, TransientDocument & ResolvablePointer> = {} as LDPDocumentTraitFactory;
			expect( target ).toBeDefined();
		} );

		it( extendsClass( "CarbonLDP.Model.ModelDecorator<CarbonLDP.DocumentsRepository.Traits.LDPDocumentTrait<any>, CarbonLDP.BaseLDPDocumentTrait>" ), () => {
			const target:ModelDecorator<LDPDocumentTrait, BaseLDPDocumentTrait> = {} as LDPDocumentTraitFactory;
			expect( target ).toBeDefined();
		} );


		describe( "LDPDocumentTrait.isDecorated", () => {

			it( "should exists", ():void => {
				expect( LDPDocumentTrait.isDecorated ).toBeDefined();
				expect( LDPDocumentTrait.isDecorated ).toEqual( jasmine.any( Function ) );
			} );


			it( "should call ModelDecorator.hasPropertiesFrom with the PROTOTYPE", () => {
				const spy:jasmine.Spy = spyOn( ModelDecorator, "hasPropertiesFrom" );

				LDPDocumentTrait.isDecorated( { the: "object" } );

				expect( spy ).toHaveBeenCalledWith( LDPDocumentTrait.PROTOTYPE, { the: "object" } );
			} );

		} );

		describe( "LDPDocumentTrait.decorate", () => {

			it( "should exists", ():void => {
				expect( LDPDocumentTrait.decorate ).toBeDefined();
				expect( LDPDocumentTrait.decorate ).toEqual( jasmine.any( Function ) );
			} );


			it( "should call ModelDecorator.definePropertiesFrom with PROTOTYPE", () => {
				const spy:jasmine.Spy = spyOn( ModelDecorator, "definePropertiesFrom" )
					.and.callThrough();

				LDPDocumentTrait.decorate( { $repository, the: "object" } );

				expect( spy ).toHaveBeenCalledWith( LDPDocumentTrait.PROTOTYPE, { the: "object" } );
			} );

			it( "should no call ModelDecorator.definePropertiesFrom when already decorated", () => {
				spyOn( LDPDocumentTrait, "isDecorated" )
					.and.returnValue( true );

				const spy:jasmine.Spy = spyOn( ModelDecorator, "definePropertiesFrom" );
				LDPDocumentTrait.decorate( { $repository } );

				expect( spy ).not.toHaveBeenCalled();
			} );


			it( "should decorate with TransientDocument", () => {
				const spy:jasmine.Spy = spyOn( TransientDocument, "decorate" )
					.and.callThrough();

				LDPDocumentTrait.decorate( { $repository, the: "object" } );

				expect( spy ).toHaveBeenCalledWith( { the: "object" } );
			} );

			it( "should decorate with ResolvablePointer", () => {
				const spy:jasmine.Spy = spyOn( ResolvablePointer, "decorate" )
					.and.callThrough();

				LDPDocumentTrait.decorate( { $repository, the: "object" } );

				expect( spy ).toHaveBeenCalledWith( { the: "object" } );
			} );

		} );

	} );

	describe( property(
		STATIC,
		"LDPDocumentTrait",
		"CarbonLDP.DocumentsRepository.Traits.LDPDocumentTraitFactory"
	), () => {

		it( "should exists", ():void => {
			expect( LDPDocumentTrait ).toBeDefined();
			expect( LDPDocumentTrait ).toEqual( jasmine.any( Object ) );
		} );

	} );

} );
